--
-- Parkour v2
-- MIT License

-- Copyright (c) 2020 Iv√°n Gabriel (Tocutoeltuco)

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--


math.randomseed(os.time())

local data_version = 0
local room = tfm.get.room
local links = {
	donation = "https://a801-luadev.github.io/?redirect=parkour",
	github = "https://github.com/a801-luadev/parkour",
	discord = "https://discord.gg/RXaCyWz",
	maps = "https://bit.ly/submit-parkour-maps",
	records = "https://tfmrecords.home.kg/",
}

local starting = string.sub(room.name, 1, 2)

local is_tribe
local tribe, module_name, submode
local flags = ""

room.lowerName = string.lower(room.name)

--[[ Package translations ]]--
--[[ File translations/init.lua ]]--
local translations
translations = setmetatable({}, {
	__index = function()
		return translations.en
	end
})
translations.en = {}
--[[ End of file translations/init.lua ]]--
--[[ End of package translations ]]--
--[[ Package global ]]--
--[[ Package tech/json ]]--
--[[ File tech/json/init.lua ]]--
--
-- json.lua
--
-- Copyright (c) 2019 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-- NOTE: This is a slightly modified version of the script you will find here:
-- https://github.com/rxi/json.lua
-- It has been modified so it uses less runtime, by making the next functions
-- accessible via a single variable and by disabling some encoding/decoding
-- checks. It is not recommended to use this version if you're not 100% sure your
-- data is totally valid.

local string_format = string.format
local string_byte = string.byte
local table_concat = table.concat
local string_gsub = string.gsub
local string_sub = string.sub
local string_find = string.find
local string_char = string.char
local math_floor = math.floor

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------


local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { [ "\\/" ] = "/" }
for k, v in next, escape_char_map do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return escape_char_map[c] or string_format("\\u%04x", string_byte(c))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val)--, stack)
  local res = {}
  -- stack = stack or {}

  -- Circular reference?
  -- if stack[val] then error("circular reference") end

  -- stack[val] = true

  if rawget(val, 1) ~= nil then-- or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    -- local n = 0
    -- for k in next, val do
    --   if type(k) ~= "number" then
    --     error("invalid table: mixed or invalid key types")
    --   end
    --   n = n + 1
    -- end
    -- if n ~= #val then
    --   error("invalid table: sparse array")
    -- end
    -- Encode
    for i = 1, #val do
      res[i] = encode(val[i])--, stack)
    end
    --stack[val] = nil
    return "[" .. table_concat(res, ",") .. "]"

  else
    -- Treat as an object
    local n = 0
    for k, v in next, val do
      -- if type(k) ~= "string" then
      --   error("invalid table: mixed or invalid key types")
      -- end
      n = n + 1
      res[n] = encode(k) .. ":" .. encode(v)--, stack) .. ":" .. encode(v, stack)
    end
    --stack[val] = nil
    return "{" .. table_concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. string_gsub(val, '[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  -- if val ~= val or val <= -math.huge or val >= math.huge then
  --   error("unexpected number value '" .. tostring(val) .. "'")
  -- end
  if val % 1 == 0 then
    return tostring(val)
  else
    return string_format("%.14g", val)
  end
end


local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val)--, stack)
  return type_func_map[type(val)](val)--, stack)
end


json.encode = encode


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[string_sub(str, i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if string_sub(str, i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string_format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  if n <= 0x7f then
    return string_char(n)
  elseif n <= 0x7ff then
    return string_char(math_floor(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string_char(math_floor(n / 4096) + 224, math_floor(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string_char(math_floor(n / 262144) + 240, math_floor(n % 262144 / 4096) + 128,
                       math_floor(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string_format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( string_sub(s, 3, 6),  16 )
  local n2 = tonumber( string_sub(s, 9, 12), 16 )
  -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local has_unicode_escape = false
  local has_surrogate_escape = false
  local has_escape = false
  local last
  for j = i + 1, #str do
    local x = string_byte(str, j)

    if x < 32 then
      decode_error(str, j, "control character in string")
    end

    if last == 92 then -- "\\" (escape char)
      if x == 117 then -- "u" (unicode escape sequence)
        local hex = string_sub(str, j + 1, j + 5)
        if not string_find(hex, "%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        if string_find(hex, "^[dD][89aAbB]") then
          has_surrogate_escape = true
        else
          has_unicode_escape = true
        end
      else
        local c = string_char(x)
        if not escape_chars[c] then
          decode_error(str, j, "invalid escape char '" .. c .. "' in string")
        end
        has_escape = true
      end
      last = nil

    elseif x == 34 then -- '"' (end of string)
      local s = string_sub(str, i + 1, j - 1)
      if has_surrogate_escape then
        s = string_gsub(s, "\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
      end
      if has_unicode_escape then
        s = string_gsub(s, "\\u....", parse_unicode_escape)
      end
      if has_escape then
        s = string_gsub(s, "\\.", escape_char_map_inv)
      end
      return s, j + 1

    else
      last = x
    end
  end
  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = string_sub(str, i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = string_sub(str, i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if string_sub(str, i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = string_sub(str, i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if string_sub(str, i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if string_sub(str, i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if string_sub(str, i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = string_sub(str, i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = string_sub(str, idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end
--[[ End of file tech/json/init.lua ]]--
--[[ End of package tech/json ]]--
--[[ Package tech/filemanager ]]--
--[[ File tech/filemanager/init.lua ]]--
local FileManager
do
	FileManager = {}
	FileManager.__index = FileManager

	local string_byte = string.byte
	local string_char = string.char
	local string_sub = string.sub

	local parsers
	parsers = {
		["dictionary"] = function(str, obj, idx)
			local result = {}
			if obj.length then -- premade dict!
				local child
				for i = 1, obj.length do
					child = obj.map[i]
					result[child.name], idx = parsers[child.type](str, child, idx)
				end
			else
				local length
				length, idx = parsers.number(str, nil, idx)

				local strparser = parsers.string
				local parser, child = parsers[obj.objects.type], obj.objects
				local name
				for i = 1, length do
					name, idx = strparser(str, nil, idx)
					result[name], idx = parser(str, child, idx)
				end
			end
			return result, idx
		end,

		["array"] = function(str, obj, idx)
			local result = {}
			if obj.length then -- premade map!
				local child
				for i = 1, obj.length do
					child = obj.map[i]
					result[i], idx = parsers[child.type](str, child, idx)
				end
			else
				local length
				length, idx = parsers.number(str, nil, idx)

				local parser, child = parsers[obj.objects.type], obj.objects
				for i = 1, length do
					result[i], idx = parser(str, child, idx)
				end
			end
			return result, idx
		end,

		["boolean"] = function(str, obj, idx)
			return string_sub(str, idx, idx) == "1", idx + 1
		end,

		["string"] = function(str, obj, idx)
			local length = obj and obj.length
			if not length then
				length, idx = parsers.number(str, nil, idx)
			end

			return string_sub(str, idx, idx - 1 + length), idx + length
		end,

		["number"] = function(str, obj, idx)
			local length = string_byte(str, idx)
			return tonumber(string_sub(str, idx + 1, idx + length)), idx + 1 + length
		end
	}

	local writers
	writers = {
		["dictionary"] = function(data, obj, str)
			if obj.length then -- premade map
				local child
				for i = 1, obj.length do
					child = obj.map[i]
					str = writers[child.type](data[child.name], child, str)
				end
			else
				local _str = ""
				local length = 0

				local strwriter = writers.string
				local writer, child = writers[obj.objects.type], obj.objects
				for key, value in next, data do
					_str = strwriter(key, nil, _str)
					_str = writer(value, child, _str)
					length = length + 1
				end

				str = writers.number(length, nil, str) .. _str
			end
			return str
		end,

		["array"] = function(data, obj, str)
			if obj.length then -- premade map
				local child
				for i = 1, obj.length do
					child = obj.map[i]
					str = writers[child.type](data[i], child, str)
				end
			else
				local length = #data
				str = writers.number(length, nil, str)

				local writer, child = writers[obj.objects.type], obj.objects
				for i = 1, #data do
					str = writer(data[i], child, str)
				end
			end
			return str
		end,

		["boolean"] = function(data, obj, str)
			return str .. (data and "1" or "0")
		end,

		["string"] = function(data, obj, str)
			if not (obj and obj.length) then
				str = writers.number(#data, nil, str)
			end
			return str .. data
		end,

		["number"] = function(data, obj, str)
			local encoded = tostring(data)
			return str .. string_char(#encoded) .. encoded
		end
	}

	local prepare_object
	function prepare_object(obj)
		assert(obj.type, "every object must have a type")

		if obj.type == "dictionary" then
			assert(obj.objects or obj.map, "a dictionary must have either a premade map or an objects list")
			assert(not (obj.objects and obj.map), "a dictionary can't have both a premade map and an objects list")
			assert(not obj.length, "a dictionary can't have the length variable set to it")

			if obj.map then
				obj.length = #obj.map

				local child
				for index = 1, obj.length do
					child = obj.map[index]
					assert(child.name, "every object in the map of a dictionary must have a name")

					prepare_object(child)
				end
			else
				assert(not obj.objects.name, "the object type in a dynamic dictionary can't have a premade name")

				prepare_object(obj.objects)
			end

		elseif obj.type == "array" then
			assert(obj.objects or obj.map, "an array must have either a premade map or an objects list")
			assert(not (obj.objects and obj.map), "an array can't have both a premade map and an objects list")
			assert(not obj.length, "an array can't have the length variable set to it")

			if obj.map then
				obj.length = #obj.map

				local child
				for index = 1, obj.length do
					prepare_object(obj.map[index])
				end
			else
				prepare_object(obj.objects)
			end

		elseif obj.type == "boolean" then
			-- nothing

		elseif obj.type == "string" then
			if obj.length then
				assert(type(obj.length) == "number", "length attribute of a string must be either nil or a number")
			end

		elseif obj.type == "number" then
			-- nothing

		else
			error("unknown object type: '" .. obj.type .. "'")
		end
	end

	local validity_checks
	function validity_checks(data, obj)
		local data_type = type(data)

		if obj.type == "dictionary" then
			assert(data_type == "table", "object must be a table in order to be casted to a dictionary")
			if obj.length then
				local length = 0

				local valid
				for key, value in next, data do
					valid = false
					length = length + 1
					for i = 1, obj.length do
						if obj.map[i].name == key then
							valid = true
							validity_checks(value, obj.map[i])
							break
						end
					end
					assert(valid, "table must have the same keys as the premade dictionary map")
				end

				assert(length == obj.length, "table must have the same length as the premade dictionary map")
			else
				local object = obj.objects
				for key, value in next, data do
					assert(type(key) == "string", "table indexes must be strings in order to be casted to a dynamic dictionary")
					validity_checks(value, object)
				end
			end

		elseif obj.type == "array" then
			assert(data_type == "table", "object must be a table in order to be casted to a array")
			if obj.length then
				assert(#data == obj.length, "table must have the same length as the premade array map")

				for i = 1, #data do
					validity_checks(data[i], obj.map[i])
				end
			else
				local object = obj.objects
				for i = 1, #data do
					validity_checks(data[i], object)
				end
			end

		elseif obj.type == "boolean" then
			-- no specific type needed

		elseif obj.type == "string" then
			assert(data_type == "string", "object must be a string in order to be written as one")
			if obj.length then
				assert(#data == obj.length, "string must have the same length as the allocated for the string")
			end

		elseif obj.type == "number" then
			assert(data_type == "number", "object must be a number in order to be written as one")
		end
	end

	function FileManager.new(struct)
		return setmetatable({
			ready = false,
			struct = struct,
			validity = true
		}, FileManager)
	end

	function FileManager:disableValidityChecks()
		self.validity = false
		return self
	end

	function FileManager:prepare()
		prepare_object(self.struct)
		self.ready = true
		return self
	end

	function FileManager:load(string)
		assert(self.ready, "FileManager needs to be prepared before using it")
		return parsers[self.struct.type](string, self.struct, 1)
	end

	function FileManager:check(data)
		validity_checks(data, self.struct)
		return self
	end

	function FileManager:dump(data)
		assert(self.ready, "FileManager needs to be prepared before using it")

		if self.validity then
			self:check(data)
		end

		return writers[self.struct.type](data, self.struct, "")
	end
end
--[[ End of file tech/filemanager/init.lua ]]--
--[[ End of package tech/filemanager ]]--
--[[ File global/event-handler.lua ]]--
local translatedChatMessage
local packet_handler
local send_channel
local sendPacket
local add_packet_data, buffer
local initializingModule = true

local onEvent
do
	-- Configuration
	local CYCLE_DURATION = 4100
	local RUNTIME_LIMIT = 30
	local DONT_SCHEDULE = {
		["Loop"] = true,
		["Keyboard"] = true
	}

	-- Optimization
	local os_time = os.time
	local math_floor = math.floor

	-- Runtime breaker
	local cycleId = 0
	local usedRuntime = 0
	local stopingAt = 0
	local checkingRuntime = false
	local paused = false
	local scheduled = {_count = 0, _pointer = 1}

	-- Listeners
	local events = {}

	local function errorHandler(name, msg)
		tfm.exec.disableAutoNewGame(true)
		tfm.exec.disableAfkDeath(true)
		tfm.exec.disablePhysicalConsumables(true)
		tfm.exec.disableMortCommand(true)
		tfm.exec.disableAutoShaman(true)
		tfm.exec.newGame(7688481)
		tfm.exec.setGameTime(99999)

		for _, event in next, events do
			event._count = 0
		end

		if room.name == "*#parkour4bots" then
			ui.addTextArea(bit32.lshift(255, 8) + 255, name .. "\000" .. msg)
			return
		end

		tfm.exec.chatMessage(name .. " - " .. msg)
		translatedChatMessage("emergency_mode")

		if is_tribe then return end

		tfm.exec.setRoomMaxPlayers(1)

		sendPacket(0, room.name .. "\000" .. name .. "\000" .. msg)
		system.loadPlayerData(send_channel)
		buffer = add_packet_data

		events.PlayerDataLoaded._count = 2
		events.PlayerDataLoaded[1] = packet_handler
		events.PlayerDataLoaded[2] = function(player)
			if player == send_channel then
				events.PlayerDataLoaded._count = 0
			end
		end
	end

	local function callListeners(evt, a, b, c, d, e, offset)
		for index = offset, evt._count do
			evt[index](a, b, c, d, e)

			if not initializingModule and os_time() >= stopingAt then
				if index < evt._count then
					-- If this event didn't end, we need to resume from
					-- where it has been left!
					scheduled._count = scheduled._count + 1
					scheduled[ scheduled._count ] = {evt, a, b, c, d, e, index + 1}
				end

				paused = true
				cycleId = cycleId + 2
				translatedChatMessage("paused_events")
				break
			end
		end
	end

	local function resumeModule()
		local count = scheduled._count

		local event
		for index = scheduled._pointer, count do
			event = scheduled[index]
			callListeners(event[1], event[2], event[3], event[4], event[5], event[6], event[7])

			if paused then
				if scheduled._count > count then
					-- If a new event has been scheduled, it is this one.
					-- It should be the first one to run on the next attempt to resume.
					event[7] = scheduled[ scheduled._count ][7]

					-- So we set it to start from here
					scheduled._pointer = index
					-- and remove the last item, since we don't want it to
					-- execute twice!
					scheduled._count = scheduled._count - 1
				else
					-- If no event has been scheduled, this one has successfully ended.
					-- We just tell the next attempt to resume to start from the next one.
					scheduled._pointer = index + 1
				end
				return
			end
		end

		-- delete all the scheduled tables since they just use ram!
		scheduled = {_count = 0, _pointer = 1}
		translatedChatMessage("resumed_events")
	end

	local function registerEvent(name)
		local evt = events[name]
		local schedule = not DONT_SCHEDULE[name]

		local event
		event = function(a, b, c, d, e)
			if initializingModule then
				local done, result = pcall(callListeners, evt, a, b, c, d, e, 1)
				if not done then
					errorHandler(name, result)
				end
				return
			end

			if checkingRuntime then
				if paused then
					if schedule then
						scheduled._count = scheduled._count + 1
						scheduled[ scheduled._count ] = {evt, a, b, c, d, e, 1}
					end
					return
				end
				-- Directly call callListeners since there's no need of
				-- two error handlers
				callListeners(evt, a, b, c, d, e, 1)
				return
			end

			-- If we call any event inside this one, we don't need to
			-- perform all the runtime breaker checks.
			checkingRuntime = true
			local start = os_time()
			local thisCycle = math_floor(start / CYCLE_DURATION)

			if thisCycle > cycleId then
				-- new runtime cycle
				cycleId = thisCycle
				usedRuntime = 0
				stopingAt = start + RUNTIME_LIMIT

				-- if this was paused, we need to resume!
				if paused then
					paused = false
					checkingRuntime = false

					local done, result = pcall(resumeModule)
					if not done then
						errorHandler("resuming", result)
						return
					end

					usedRuntime = usedRuntime + os_time() - start

					-- if resuming took a lot of runtime, we have to
					-- pause again
					if paused then
						if schedule then
							scheduled._count = scheduled._count + 1
							scheduled[ scheduled._count ] = {evt, a, b, c, d, e, 1}
						end
						return
					end
				end
			else
				stopingAt = start + RUNTIME_LIMIT - usedRuntime
			end

			if paused then
				if schedule then
					scheduled._count = scheduled._count + 1
					scheduled[ scheduled._count ] = {evt, a, b, c, d, e, 1}
				end
				checkingRuntime = false
				return
			end

			local done, result = pcall(callListeners, evt, a, b, c, d, e, 1)
			if not done then
				errorHandler(name, result)
				return
			end

			checkingRuntime = false
			usedRuntime = usedRuntime + os_time() - start
		end

		return event
	end

	function onEvent(name, callback)
		local evt = events[name]

		if not evt then
			-- Unregistered event
			evt = {_count = 0}
			events[name] = evt

			_G["event" .. name] = registerEvent(name)
		end

		-- Register callback
		evt._count = evt._count + 1
		evt[ evt._count ] = callback
	end
end
--[[ End of file global/event-handler.lua ]]--
--[[ File global/translation-handler.lua ]]--
local player_langs = {}

local translatedMessage
do
	local community = tfm.get.room.community
	function translatedMessage(what, who, ...)
		local lang
		if who then
			lang = player_langs[who]
		else
			lang = translations[community]
		end
		local text = lang and lang[what] or nil
		if not text then
			return "%" .. what .. "%"
		elseif select("#", ...) > 0 then
			done, text = pcall(string.format, text, ...)
			if not done then
				error(debug.traceback(what .. "," .. text))
			end
		end
		return text
	end
end

--local translatedChatMessage
do
	local chatMessage = tfm.exec.chatMessage
	function translatedChatMessage(what, who, ...)
		if not who then
			for player in next, player_langs do
				translatedChatMessage(what, player, ...)
			end
			return
		end
		local msg = translatedMessage(what, who, ...)
		local length = #msg

		while length > 1000 do
			chatMessage(string.sub(msg, 1, 1000), who)
			msg = string.sub(msg, 1001)
			length = length - 1000
		end
		if length > 0 then
			chatMessage(msg, who)
		end
	end
end

onEvent("NewPlayer", function(player)
	if room.playerList[player] then
		player_langs[player] = translations[room.playerList[player].community]
	else
		player_langs[player] = translations[room.community]
	end
end)
--[[ End of file global/translation-handler.lua ]]--
--[[ End of package global ]]--

local function initialize_parkour() -- so it uses less space after building
	--[[ Package modes/parkour ]]--
	--[[ File modes/parkour/filemanagers.lua ]]--
	local filemanagers = {
		["20"] = FileManager.new({
			type = "dictionary",
			map = {
				{
					name = "maps",
					type = "array",
					objects = {
						type = "number"
					}
				},
				{
					name = "ranks",
					type = "dictionary",
					objects = {
						type = "number"
					}
				},
				{
					name = "chats",
					type = "dictionary",
					map = {
						{
							name = "mod",
							type = "string",
							length = 10
						},
						{
							name = "mapper",
							type = "string",
							length = 10
						}
					}
				}
			}
		}):disableValidityChecks():prepare(),

		["21"] = FileManager.new({
			type = "dictionary",
			map = {
				{
					name = "ranking",
					type = "array",
					objects = {
						type = "array",
						map = {
							{
								type = "number"
							},
							{
								type = "string",
							},
							{
								type = "number"
							},
							{
								type = "string",
								length = 2
							}
						}
					}
				},
				{
					name = "weekranking",
					type = "array",
					objects = {
						type = "array",
						map = {
							{
								type = "number"
							},
							{
								type = "string",
							},
							{
								type = "number"
							},
							{
								type = "string",
								length = 2
							}
						}
					}
				}
			}
		}):disableValidityChecks():prepare(),

		["22"] = FileManager.new({
			type = "dictionary",
			map = {
				{
					name = "lowmaps",
					type = "array",
					objects = {
						type = "number"
					}
				},
				{
					name = "banned",
					type = "dictionary",
					objects = {
						type = "number"
					}
				}
			}
		}):disableValidityChecks():prepare()
	}
	--[[ End of file modes/parkour/filemanagers.lua ]]--
	--[[ Directory translations/parkour ]]--
	--[[ File translations/parkour/ru.lua ]]--
	translations.ru = {
		name = "ru",
		fullname = "–†—É—Å—Å–∫–∏–π",

		-- –°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö
		corrupt_map = "<r>–ü–æ–≤—Ä–µ–∂–¥–µ–Ω–Ω–∞—è –∫–∞—Ä—Ç–∞. –∑–∞–≥—Ä—É–∑–∏—Ç–µ –¥—Ä—É–≥—É—é.",
		corrupt_map_vanilla = "<r>[–û–®–ò–ë–ö–ê] <n>–ù–µ —É–¥–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–∞—Ä—Ç–µ.",
		corrupt_map_mouse_start = "<r>[–û–®–ò–ë–ö–ê] <n>–ö–∞—Ä—Ç–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é (—Ç–æ—á–∫—É –ø–æ—è–≤–ª–µ–Ω–∏—è –º—ã—à–∏).",
		corrupt_map_needing_chair = "<r>[–û–®–ò–ë–ö–ê] <n>–ù–∞ –∫–∞—Ä—Ç–µ –¥–æ–ª–∂–Ω–æ –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –∫—Ä–µ—Å–ª–æ –¥–ª—è –æ–∫–æ–Ω—á–∞–Ω–∏—è —Ä–∞—É–Ω–¥–∞.",
		corrupt_map_missing_checkpoints = "<r>[–û–®–ò–ë–ö–ê] <n>–ö–∞—Ä—Ç–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —á–µ–∫–ø–æ–∏–Ω—Ç (–∂–µ–ª—Ç—ã–π –≥–≤–æ–∑–¥—å).",
		corrupt_data = "<r>–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω—ã –∏ –±—ã–ª–∏ —Å–±—Ä–æ—à–µ–Ω—ã.",
		min_players = "<r>–ß—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ, –≤ –∫–æ–º–Ω–∞—Ç–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∫–∞–∫ –º–∏–Ω–∏–º—É–º 4 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∏–≥—Ä–æ–∫–∞. <bl>[%s/%s]",
		tribe_house = "<r>–î–∞–Ω–Ω—ã–µ –Ω–µ –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –∫–æ–º–Ω–∞—Ç–µ –ø–ª–µ–º–µ–Ω–∏.",
		invalid_syntax = "<r>–ù–µ–≤–µ—Ä–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å.",
		code_error = "<r>–ü–æ—è–≤–∏–ª–∞—Å—å –æ—à–∏–±–∫–∞: <bl>%s-%s-%s %s",
		emergency_mode = "<r>–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ –∞–≤–∞—Ä–∏–π–Ω–æ–µ –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ, –Ω–æ–≤—ã–µ –∏–≥—Ä–æ–∫–∏ –Ω–µ —Å–º–æ–≥—É—Ç –∑–∞–π—Ç–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –¥—Ä—É–≥—É—é –∫–æ–º–Ω–∞—Ç—É #pourour.",
		leaderboard_not_loaded = "<r>–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ –µ—â–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –º–∏–Ω—É—Ç—É.",
		max_power_keys = "<v>[#] <r>You can only have at most %s powers in the same key.",

		-- Help window
		help = "–ü–æ–º–æ—â—å",
		staff = "–ö–æ–º–∞–Ω–¥–∞ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤",
		rules = "–ü—Ä–∞–≤–∏–ª–∞",
		contribute = "–°–æ–¥–µ–π—Å—Ç–≤–∏–µ",
		changelog = "–ò–∑–º–µ–Ω–µ–Ω–∏—è",
		help_help = "<p align = 'center'><font size = '14'>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>–í–∞—à–∞ —Ü–µ–ª—å - —Å–æ–±—Ä–∞—Ç—å –≤—Å–µ —á–µ–∫–ø–æ–∏–Ω—Ç—ã, —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å –∫–∞—Ä—Ç—É.</J></p>\n\n<N>‚Ä¢ –ù–∞–∂–º–∏—Ç–µ <O>O</O>, –≤–≤–µ–¥–∏—Ç–µ <O>!op</O> –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ <O> —à–µ—Å—Ç–µ—Ä–µ–Ω–∫—É</O> —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å <T>–º–µ–Ω—é –Ω–∞—Å—Ç—Ä–æ–µ–∫</T>.\n‚Ä¢ –ù–∞–∂–º–∏—Ç–µ <O>P</O> –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ <O>—Ä—É–∫—É</O> –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å <T>–º–µ–Ω—é —Å–æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º–∏</T>.\n‚Ä¢ –ù–∞–∂–º–∏—Ç–µ <O>L</O> –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ <O>!lb</O> —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å <T>–°–ø–∏—Å–æ–∫ –ª–∏–¥–µ—Ä–æ–≤</T>.\n‚Ä¢ –ù–∞–∂–º–∏—Ç–µ <O>M</O> –∏–ª–∏ <O>Delete</O> —á—Ç–æ–±—ã –Ω–µ –ø—Ä–æ–ø–∏—Å—ã–≤–∞—Ç—å <T>/mort</T>.\n‚Ä¢ –ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ –æ –Ω–∞—à–µ–π <O>–∫–æ–º–∞–Ω–¥–µ</O> –∏ –æ <O>–ø—Ä–∞–≤–∏–ª–∞—Ö –ø–∞—Ä–∫—É—Ä–∞</O>, –Ω–∞–∂–º–∏ –Ω–∞ <T>–ö–æ–º–∞–Ω–¥–∞</T> –∏ <T>–ü—Ä–∞–≤–∏–ª–∞</T>.\n‚Ä¢ –ù–∞–∂–º–∏—Ç–µ <a href='event:discord'><o>here</o></a> —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –Ω–∞—à –î–∏—Å–∫–æ—Ä–¥ –∫–∞–Ω–∞–ª. –ù–∞–∂–º–∏—Ç–µ <a href='event:map_submission'><o>here</o></a> —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–µ–º—É –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–∞—Ä—Ç—ã.\n‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª–∞–≤–∏—à–∏ <o>–≤–≤–µ—Ä—Ö</o> –∏ <o>–≤–Ω–∏–∑</o> —á—Ç–æ–±—ã –ª–∏—Å—Ç–∞—Ç—å –º–µ–Ω—é.\n\n<p align = 'center'><font size = '13'><T>–í–∫–ª–∞–¥–∫–∏ —Ç–µ–ø–µ—Ä—å –æ—Ç–∫—Ä—ã—Ç—ã! –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –≤–∫–ª–∞–¥–∫—É <O>–°–æ–¥–µ–π—Å—Ç–≤–∏–µ</O> !</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>–û–ë–Ø–ó–ê–ù–ù–û–°–¢–ò: –ö–æ–º–∞–Ω–¥–∞ –ü–∞—Ä–∫—É—Ä–∞ –ù–ï –∫–æ–º–∞–Ω–¥–∞ Transformice –∏ –ù–ï –∏–º–µ–µ—Ç –Ω–∏–∫–∞–∫–æ–π –≤–ª–∞—Å—Ç–∏ –≤ —Å–∞–º–æ–π –∏–≥—Ä–µ, —Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ –º–æ–¥—É–ª—è.</r>\n–ö–æ–º–∞–Ω–¥–∞ Parkour –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç –∏—Å–ø—Ä–∞–≤–Ω—É—é —Ä–∞–±–æ—Ç—É –º–æ–¥—É–ª—è —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –ø—Ä–æ–±–ª–µ–º–∞–º–∏ –∏ –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤–∞ –ø–æ–º–æ—á—å –∏–≥—Ä–æ–∫–∞–º –≤ —Å–ª—É—á–∞–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏.</font></p>\n–í—ã –º–æ–∂–µ—Ç–µ –≤–≤–µ—Å—Ç–∏ <D>!staff</D> –≤ —á–∞—Ç, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –Ω–∞—à—É –∫–æ–º–∞–Ω–¥—É.\n\n<font color = '#E7342A'>–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã:</font> H–µ—Å—É—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–∞–º–æ–≥–æ –º–æ–¥—É–ª—è, –¥–æ–±–∞–≤–ª—è—è –Ω–æ–≤—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ –∏—Å–ø—Ä–∞–≤–ª—è—è –æ—à–∏–±–∫–∏.\n\n<font color = '#D0A9F0'>–†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–∏ –∫–æ–º–∞–Ω–¥:</font> K–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É—é—Ç –∫–æ–º–∞–Ω–¥—ã –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –∏ –∫–∞—Ä—Ç–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–µ–π, —Å–ª–µ–¥—è –∑–∞ —Ç–µ–º, —á—Ç–æ–±—ã –æ–Ω–∏ —Ö–æ—Ä–æ—à–æ –≤—ã–ø–æ–ª–Ω—è–ª–∏ —Å–≤–æ—é —Ä–∞–±–æ—Ç—É. –û–Ω–∏ —Ç–∞–∫–∂–µ –Ω–µ—Å—É—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ –Ω–∞–±–æ—Ä –Ω–æ–≤—ã—Ö —á–ª–µ–Ω–æ–≤ –≤ –∫–æ–º–∞–Ω–¥—É.\n\n<font color = '#FFAAAA'>–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã:</font> H–µ—Å—É—Ç –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å –∑–∞ —Å–æ–±–ª—é–¥–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª –º–æ–¥—É–ª—è –∏ –Ω–∞–∫–∞–∑—ã–≤–∞—é—Ç —Ç–µ—Ö, –∫—Ç–æ –Ω–µ —Å–ª–µ–¥—É–µ—Ç –∏–º.\n\n<font color = '#25C059'>–ö–∞—Ä—Ç–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª–∏:</font> O—Ç–≤–µ—á–∞—é—Ç –∑–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏ —É–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç –≤ –º–æ–¥—É–ª–µ, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—è –≤–∞–º –ø—Ä–∏—è—Ç–Ω—ã–π –∏–≥—Ä–æ–≤–æ–π –ø—Ä–æ—Ü–µ—Å—Å.",
		help_rules = "<font size = '13'><B><J>–í—Å–µ –ø—Ä–∞–≤–∏–ª–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —É—Å–ª–æ–≤–∏—è Transformice —Ç–∞–∫–∂–µ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –∫ #parkour </J></B></font>\n\n–ï—Å–ª–∏ –≤—ã –æ–±–Ω–∞—Ä—É–∂–∏–ª–∏, —á—Ç–æ –∫—Ç–æ-—Ç–æ –Ω–∞—Ä—É—à–∞–µ—Ç —ç—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –Ω–∞—à–∏–º –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–∞–º. –ï—Å–ª–∏ –º–æ–¥–µ—Ä–∞—Ç–æ—Ä–æ–≤ –Ω–µ—Ç –≤ —Å–µ—Ç–∏, –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ–æ–±—â–∏—Ç—å –æ–± —ç—Ç–æ–º –Ω–∞ –Ω–∞ –Ω–∞—à–µ–º —Å–µ—Ä–≤–µ—Ä–µ –≤ Discord\n–ü—Ä–∏ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ —Ä–µ–ø–æ—Ä—Ç–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä, –∏–º—è –∫–æ–º–Ω–∞—Ç—ã –∏ –∏–º—è –∏–≥—Ä–æ–∫–∞.\n‚Ä¢ –ü—Ä–∏–º–µ—Ä: en-#parkour10 Blank#3495 —Ç—Ä–æ–ª–ª–∏–Ω–≥\n–î–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–∞, —Ç–∞–∫–∏–µ –∫–∞–∫ —Å–∫—Ä–∏–Ω—à–æ—Ç—ã, –≤–∏–¥–µ–æ –∏ –≥–∏—Ñ–∫–∏, –ø–æ–ª–µ–∑–Ω—ã –∏ —Ü–µ–Ω–Ω—ã, –Ω–æ –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã.\n\n<font size = '11'>‚Ä¢ <font color = '#ef1111'>—á–∏—Ç—ã, –≥–ª—é–∫–∏ –∏–ª–∏ –±–∞–≥–∏</font> –Ω–µ –¥–æ–ª–∂–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –∫–æ–º–Ω–∞—Ç–∞—Ö #parkour\n‚Ä¢ <font color = '#ef1111'>–§–∞—Ä–º —á–µ—Ä–µ–∑ VPN</font> —Å—á–∏—Ç–∞–µ—Ç—Å—è <B>–Ω–∞—Ä—É—à–µ–Ω–∏–µ–º</B> –∏ –Ω–µ –¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è. <p align = 'center'><font color = '#cc2222' size = '12'><B>\n–õ—é–±–æ–π, –∫—Ç–æ –ø–æ–π–º–∞–Ω –∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏–µ —ç—Ç–∏—Ö –ø—Ä–∞–≤–∏–ª, –±—É–¥–µ—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –∑–∞–±–∞–Ω–µ–Ω.</B></font></p>\n\n<font size = '12'>Transformice –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ–Ω—Ü–µ–ø—Ü–∏—é —Ç—Ä–æ–ª–ª–∏–Ω–≥–∞. –û–¥–Ω–∞–∫–æ, <font color='#cc2222'><B>–º—ã –Ω–µ –¥–æ–ø—É—Å—Ç–∏–º —ç—Ç–æ–≥–æ –≤ –ø–∞—Ä–∫—É—Ä–µ.</B></font></font>\n\n<p align = 'center'><J>–¢—Ä–æ–ª–ª–∏–Ω–≥ - —ç—Ç–æ –∫–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ –Ω–∞–º–µ—Ä–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–≤–æ–∏ —Å–∏–ª—ã –∏–ª–∏ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å, —á—Ç–æ–±—ã –ø–æ–º–µ—à–∞—Ç—å –¥—Ä—É–≥–∏–º –∏–≥—Ä–æ–∫–∞–º –ø—Ä–æ–π—Ç–∏/–∑–∞–∫–æ–Ω—á–∏—Ç—å –∫–∞—Ä—Ç—É.</J></p>\n‚Ä¢ –¢—Ä–æ–ª–ª–∏–Ω–≥ —Ä–∞–¥–∏ –º–µ—Å—Ç–∏ <B>–Ω–µ —è–≤–ª—è–µ—Ç—Å—è –≤–µ—Å–∫–æ–π –ø—Ä–∏—á–∏–Ω–æ–π,</B> –¥–ª—è —Ç—Ä–æ–ª–ª–∏–Ω–≥–∞ –∫–æ–≥–æ-–ª–∏–±–æ –∏ –≤—ã –≤—Å–µ —Ä–∞–≤–Ω–æ –±—É–¥–µ—Ç–µ –Ω–∞–∫–∞–∑–∞–Ω—ã.\n‚Ä¢ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –ø–æ–º–æ—â—å –∏–≥—Ä–æ–∫–∞–º, –∫–æ—Ç–æ—Ä—ã–µ –ø—ã—Ç–∞—é—Ç—Å—è –ø—Ä–æ–π—Ç–∏ –∫–∞—Ä—Ç—É —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –∏ –æ—Ç–∫–∞–∑—ã–≤–∞—é—Å—è –æ—Ç –ø–æ–º–æ—â–∏, –∫–æ–≥–¥–∞ –∏—Ö –æ–± —ç—Ç–æ–º –ø—Ä–æ—Å—è—Ç, —Ç–∞–∫–∂–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è —Ç—Ä–æ–ª–ª–∏–Ω–≥–æ–º. \n‚Ä¢ <J>–ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –Ω–µ —Ö–æ—á–µ—Ç –ø–æ–º–æ–≥–∞—Ç—å –∏–ª–∏ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç –∏–≥—Ä–∞—Ç—å –≤ –æ–¥–∏–Ω–æ—á–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ, –ø–æ—Å—Ç–∞—Ä–∞–π—Ç–µ—Å—å –ø–æ–º–æ—á—å –¥—Ä—É–≥–∏–º –∏–≥—Ä–æ–∫–∞–º</J>. –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ –¥—Ä—É–≥–æ–π –∏–≥—Ä–æ–∫ –Ω—É–∂–¥–∞–µ—Ç—Å—è –≤ –ø–æ–º–æ—â–∏ –Ω–∞ —Ç–æ–º –∂–µ —á–µ–∫–ø–æ–∏–Ω—Ç–µ, —á—Ç–æ –∏ —Å–æ–ª–æ –∏–≥—Ä–æ–∫, –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–º–æ—á—å –∏–º [–æ–±–æ–∏–º].\n\n–ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø–æ–π–º–∞–Ω –∑–∞ —Ç—Ä–æ–ª–ª–∏–Ω–≥–æ–º, –æ–Ω –±—É–¥–µ—Ç –Ω–∞–∫–∞–∑–∞–Ω –Ω–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ–π –æ—Å–Ω–æ–≤–µ. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –ø–æ–≤—Ç–æ—Ä–Ω—ã–π —Ç—Ä–æ–ª–ª–∏–Ω–≥ –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –±–æ–ª–µ–µ –¥–ª–∏—Ç–µ–ª—å–Ω—ã–º –∏ —Å—É—Ä–æ–≤—ã–º –Ω–∞–∫–∞–∑–∞–Ω–∏—è–º.",
		help_contribute = "<font size='14'>\n<p align='center'>–ö–æ–º–∞–Ω–¥–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞—Ä–∫—É—Ä–æ–º –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã–π –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω <t>–ø–æ–º–æ–≥–∞–µ—Ç —Å–æ–æ–±—â–µ—Å—Ç–≤—É</t>. –í—ã –º–æ–∂–µ—Ç–µ <o>–ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å</o> –∏ <o>—É–ª—É—á—à–∏—Ç—å</o> –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –Ω–∞ <o><u><a href='event:github'>GitHub</a></u></o>.\n–ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –º–æ–¥—É–ª—è<t>—Å—Ç—Ä–æ–≥–æ –¥–æ–±—Ä–æ–≤–æ–ª—å–Ω–æ</t>, —Ç–∞–∫ —á—Ç–æ –ª—é–±–∞—è –ø–æ–º–æ—â—å –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ <t>code</t>, <t>–±–∞–≥ —Ä–µ–ø–æ—Ä—Ç–æ–≤</t>, <t>–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π</t> and <t>—Å–æ–∑–¥–∞–Ω–∏—é –∫–∞—Ä—Ç</t> is always <u>–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç—Å—è –∏ —Ü–µ–Ω–∏—Ç—Å—è</u>.\n–í—ã –º–æ–∂–µ—Ç–µ <vp>–æ—Å—Ç–∞–≤–ª—è—Ç—å –∂–∞–ª–æ–±—É</vp> –∏ <vp>–ø—Ä–µ–¥–ª–∞–≥–∞—Ç—å —É–ª—É—á—à–µ–Ω–∏—è</vp> –≤ –Ω–∞—à–µ–º <o><u><a href='event:discord'>–î–∏—Å–∫–æ—Ä–¥–µ</a></u></o> –∏/–∏–ª–∏ –≤ <o><u><a href='event:github'>GitHub</a></u></o>.\n–í—ã –º–æ–∂–µ—Ç–µ <vp>–æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–≤–æ–∏ –∫–∞—Ä—Ç—ã</vp> –Ω–∞ –Ω–∞—à–µ–º <o><u><a href='event:map_submission'>—Ñ–æ—Ä—É–º–µ</a></u></o>.\n\n–ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ –ø–∞—Ä–∫—É—Ä–∞ –Ω–µ –¥–æ—Ä–æ–≥–æ–µ, –Ω–æ –∏ –Ω–µ –±–µ—Å–ø–ª–∞—Ç–Ω–æ–µ. –ú—ã –±—É–¥–µ–º —Ä–∞–¥—ã, –µ—Å–ª–∏ –≤—ã –ø–æ–º–æ–∂–µ—Ç–µ –Ω–∞–º <t>–ª—é–±–æ–π —Å—É–º–º–æ–π</t> <o><u><a href='event:donate'>here</a></u></o>.\n<u>–í—Å–µ –ø–æ–∂–µ—Ä—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–π–¥—É—Ç –Ω–∞ —É–ª—É—á—à–µ–Ω–∏–µ –º–æ–¥—É–ª—è.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>–í–µ—Ä—Å–∏—è 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–∞ <cep>—Å–∏—Å—Ç–µ–º–∞ —Ä–µ–∫–æ—Ä–¥–æ–≤</cep>! –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –∫–æ–º–Ω–∞—Ç—É <vp><u>*#parkour0records –í–∞—à–µ –∏–º—è#–¢—ç–≥</u></vp>\n‚Ä¢ –£–ª—É—á—à–µ–Ω–æ –≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã..\n‚Ä¢ –£–ª—É—á—à–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–∫–∫–∞—É–Ω—Ç–∞<o><u><a href='event:discord'>Discord</a></u></o>.",

		-- Congratulation messages
		reached_level = "<d>–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –¥–æ—Å—Ç–∏–≥–ª–∏ —É—Ä–æ–≤–Ω—è <vp>%s</vp>.",
		finished = "<d><o>%s</o> –∑–∞–≤–µ—Ä—à–∏–ª –ø–∞—Ä–∫—É—Ä –∑–∞ <vp>%s</vp> —Å–µ–∫—É–Ω–¥, <fc>–ø–æ–∑–¥—Ä–∞–≤–ª—è–µ–º!",
		unlocked_power = "<ce><d>%s</d> —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–ª —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å <vp>%s</vp>.",

		-- Information messages
		staff_power = "<r>–ö–æ–º–∞–Ω–¥–∞ –ø–∞—Ä–∫—É—Ä–∞ <b>–Ω–µ</b> –∏–º–µ–µ—Ç –≤–ª–∞—Å—Ç–∏ –≤–Ω–µ #parkour –∫–æ–º–Ω–∞—Ç.",
		donate = "<vp>–í–≤–µ–¥–∏—Ç–µ <b>!donate</b>, –µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –ø–æ–∂–µ—Ä—Ç–≤–æ–≤–∞—Ç—å –Ω–∞ —ç—Ç–æ—Ç –º–æ–¥—É–ª—å!",
		paused_events = "<cep><b>[–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ!]</b> <n> –ú–æ–¥—É–ª—å –¥–æ—Å—Ç–∏–≥ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø—Ä–µ–¥–µ–ª–∞ –∏ —Å–µ–π—á–∞—Å –≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.",
		resumed_events = "<n2>–ú–æ–¥—É–ª—å –±—ã–ª –≤–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω.",
		welcome = "<n>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤<t>#parkour</t>!",
		module_update = "<r><b>[–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ!]</b> <n>–ú–æ–¥—É–ª—å –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω –≤ <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤ –±—ã–ª–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞. –ù–∞–∂–º–∏—Ç–µ L, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –µ–µ.",
		kill_minutes = "<R>–í–∞—à–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã –Ω–∞ %s –º–∏–Ω—É—Ç.",
		permbanned = "<r>–í—ã –±—ã–ª–∏ –Ω–∞–≤—Å–µ–≥–¥–∞ –∑–∞–±–∞–Ω–µ–Ω—ã –≤ #parkour.",
		tempbanned = "<r>–í—ã –±—ã–ª–∏ –∑–∞–±–∞–Ω–µ–Ω—ã –≤ #parkour –Ω–∞ %s –º–∏–Ω—É—Ç.",

		-- Records
		records_enabled = "<v>[#] <d>R–í —ç—Ç–æ–π –∫–æ–º–Ω–∞—Ç–µ –≤–∫–ª—é—á–µ–Ω —Ä–µ–∂–∏–º —Ä–µ–∫–æ—Ä–¥–æ–≤. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è, –∞ —É–º–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã!\n–í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–π—Ç–∏ –±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –≤ <b>%s</b>",
		records_admin = "<v>[#] <d>–í—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —ç—Ç–æ–π –∫–æ–º–Ω–∞—Ç—ã. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã <b>!map</b>, <b>!pw</b> –∏ <b>!time</b>.",
		records_completed = "<v>[#] <d>–í—ã –ø—Ä–æ—à–ª–∏ –∫–∞—Ä—Ç—É! –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ –∑–∞–Ω–æ–≤–æ, –≤–≤–µ–¥–∏—Ç–µ <b>!redo</b>.",
		records_submit = "<v>[#] <d>–í–æ—Ç –≠—Ç–æ –î–∞! –ü–æ—Ö–æ–∂–µ, —Ç—ã –±—ã—Å—Ç—Ä–µ–µ –≤—Å–µ—Ö –ø—Ä–æ—à–µ–ª –∫–∞—Ä—Ç—É. –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –ø–æ–¥–µ–ª–∏—Ç—å—Å—è —Å–≤–æ–∏–º —Ä–µ–∫–æ—Ä–¥–æ–º, –≤–≤–µ–¥–∏  <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>–ü–æ—Ö–æ–∂–µ, —ç—Ç–∞ –∫–∞—Ä—Ç–∞ –Ω–µ –≤ —Ä–æ—Ç–∞—Ü–∏–∏ –ø–∞—Ä–∫—É—Ä–∞ ... –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∫–æ—Ä–¥ –¥–ª—è –Ω–µ–µ!",
		records_not_fastest = "<v>[#] <r>–ö–∞–∂–µ—Ç—Å—è, —Ç—ã –Ω–µ —Å–∞–º—ã–π –±—ã—Å—Ç—Ä—ã–π –∏–≥—Ä–æ–∫ –≤ –∫–æ–º–Ω–∞—Ç–µ ...",
		records_already_submitted = "<v>[#] <r>–í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ —Å–≤–æ–π —Ä–µ–∫–æ—Ä–¥ –¥–ª—è —ç—Ç–æ–π –∫–∞—Ä—Ç—ã!",
		records_submitted = "<v>[#] <d>–í–∞—à —Ä–µ–∫–æ—Ä–¥ –Ω–∞ —ç—Ç–æ–π –∫–∞—Ä—Ç–µ <b>%s</b> –±—ã–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ü–∞—Ä–∫—É—Ä–∞</font></p>\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∂–µ–ª—Ç—ã–µ –∫—Ä–µ–ø–ª–µ–Ω–∏—è –¥–ª—è —á–µ–∫–ø–æ–∏–Ω—Ç–æ–≤\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ <b>QWERTY</b> –Ω–∞ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–µ (–æ—Ç–∫–ª—é—á–∏—Ç—å if <b>AZERTY</b>)\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ <b>M</b> –≥–æ—Ä—è—á—É—é –∫–ª–∞–≤–∏—à—É <b>/mort</b> (–æ—Ç–∫–ª—é—á–∏—Ç—å <b>DEL</b>)\n\n–ü–æ–∫–∞–∑–∞—Ç—å –≤–∞—à–µ –≤—Ä–µ–º—è –ø–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∏\n\n–ü–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π\n\n–ü–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É –ø–æ–º–æ—â—å\n\n–ü–æ–∫–∞–∑–∞—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∫–∞—Ä—Ç—ã\n\n–ü–æ–∫–∞–∑–∞—Ç—å —Å–∏–º–≤–æ–ª –ø–æ–º–æ—â—å –Ω–µ –Ω—É–∂–Ω–∞",
		cooldown = "<v>[#] <r>–ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç, —á—Ç–æ–±—ã –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ.",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞" ..
						 "\n\n<b>Hide</b> map count"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>–ü—Ä–æ–π–¥–µ–Ω–Ω—ã–µ <v>%s</v> –∫–∞—Ä—Ç—ã" ..
						"<font size='5'>\n\n</font>—Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>–ü—Ä–æ–π–¥–µ–Ω–Ω—ã–µ <v>%s</v> –∫–∞—Ä—Ç—ã" ..
						"<font size='5'>\n\n</font>–æ–±–Ω–æ–≤–ª–µ–Ω—ã" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>–†–∞–Ω–≥ <v>%s</v>" ..
						"<font size='5'>\n\n</font>—Ä–∞–∑–±–æ–∫–∏—Ä–æ–≤–∞–Ω" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>–†–∞–Ω–≥ <v>%s</v>" ..
						"<font size='5'>\n\n</font>–æ–±–Ω–æ–≤–ª–µ–Ω" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>–ü—Ä–æ–π–¥–µ–Ω—ã–µ –∫–∞—Ä—Ç—ã"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>–û–±—â–∞—è —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Badges (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç–Ω—ã–º.<a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"–û–±—â–∞—è —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤: <b><v>%s</v></b>\n\n" ..
					"–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–∞—á—è —Ç–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤: <b><v>%s</v></b>"),
		map_count = "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "–ó–Ω–∞—á–∫–∏ - —ç—Ç–æ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –ø–æ–ª—É—á–∏—Ç—å –∏–≥—Ä–æ–∫. –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω–∏—Ö, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –∏—Ö –æ–ø–∏—Å–∞–Ω–∏–µ.",
		help_private_maps = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –Ω–µ –ª—é–±–∏—Ç –ø—É–±–ª–∏—á–Ω–æ –ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–æ–∏—Ö –∫–∞—Ä—Ç! –í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ —Å–∫—Ä—ã—Ç—å –∏—Ö –≤ —Å–≤–æ–µ–º –ø—Ä–æ—Ñ–∏–ª–µ.",
		help_badge_1 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –≤ –ø—Ä–æ—à–ª–æ–º –±—ã–ª —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–º –ø–∞—Ä–∫—É—Ä–∞.",
		help_badge_2 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏–ª–∏ –±—ã–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 1 –æ–±—â–µ–π —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤.",
		help_badge_3 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏–ª–∏ –±—ã–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 2 –æ–±—â–µ–π —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤.",
		help_badge_4 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏–ª–∏ –±—ã–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 3 –æ–±—â–µ–π —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤.",
		help_badge_5 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏–ª–∏ –±—ã–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 4 –æ–±—â–µ–π —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤.",
		help_badge_6 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∏–ª–∏ –±—ã–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ 5 –æ–±—â–µ–π —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤.",
		help_badge_7 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –±—ã–ª –≤ –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã –ª–∏–¥–µ—Ä–æ–≤.",
		help_badge_8 = "–£ —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Ä–µ–∫–æ—Ä–¥ - 30 –∫–∞—Ä—Ç –≤ —á–∞—Å.",
		help_badge_9 = "–£ —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Ä–µ–∫–æ—Ä–¥ - 35 –∫–∞—Ä—Ç –≤ —á–∞—Å.",
		help_badge_10 = "–£ —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Ä–µ–∫–æ—Ä–¥ - 40 –∫–∞—Ä—Ç –≤ —á–∞—Å.",
		help_badge_11 = "–£ —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Ä–µ–∫–æ—Ä–¥ - 45 –∫–∞—Ä—Ç –≤ —á–∞—Å.",
		help_badge_12 = "–£ —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Ä–µ–∫–æ—Ä–¥ - 50 –∫–∞—Ä—Ç –≤ —á–∞—Å.",
		help_badge_13 = "–£ —ç—Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞ —Ä–µ–∫–æ—Ä–¥ - 55 –∫–∞—Ä—Ç –≤ —á–∞—Å.",
		help_badge_14 = "–≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª —Å–≤–æ—é —É—á–µ—Ç–Ω—É—é –∑–∞–ø–∏—Å—å –Ω–∞ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–º –∫–∞–Ω–∞–ª–µ —Å–µ—Ä–≤–µ—Ä–∞ –ø–∞—Ä–∫—É—Ä–∞ (–Ω–∞–∂–º–∏—Ç–µ <b>!discord</b>).",
		help_badge_15 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 1 –∫–∞—Ä—Ç–µ.",
		help_badge_16 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 5 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_17 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 10 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_18 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 15 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_19 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 20 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_20 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 25 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_21 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 30 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_22 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 35 –∫–∞—Ä—Ç–∞—Ö.",
		help_badge_23 = "–≠—Ç–æ—Ç –∏–≥—Ä–æ–∫ –ø–æ–∫–∞–∑–∞–ª –ª—É—á—à–µ–µ –≤—Ä–µ–º—è –Ω–∞ 40 –∫–∞—Ä—Ç–∞—Ö.",
		make_public = "—Å–¥–µ–ª–∞—Ç—å –ø—É–±–ª–∏—á–Ω—ã–º",
		make_private = "—Å–¥–µ–ª–∞—Ç—å –ø—Ä–∏–≤–∞—Ç—ã–º",
		moderators = "–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã",
		mappers = "Ma–ø–ø–µ—Ä—ã",
		managers = "M–µ–Ω–µ–¥–∂–µ—Ä—ã",
		administrators = "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏—è",
		close = "–ó–∞–∫—Ä—ã—Ç—å",
		cant_load_bot_profile = "<v>[#] <r>You can't see this bot's profile since #parkour uses it internally to work properly.",
		cant_load_profile = "<v>[#] <r>The player <b>%s</b> seems to be offline or does not exist.",
		like_map = "Do you like this map?",
		yes = "Yes",
		no = "No",
		idk = "I don't know",
		unknown = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
		powers = "–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏",
		press = "<vp>–ù–∞–∂–º–∏—Ç–µ %s",
		click = "<vp>–©–µ–ª—á–æ–∫ –ª–µ–≤–æ–π –∫–Ω–æ–ø–∫–æ–π –º—ã—à–∏",
		ranking_pos = "–†–µ–π—Ç–∏–Ω–≥ #%s",
		completed_maps = "<p align='center'><BV><B>–ü—Ä–æ–π–¥–µ–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã: %s</B></p></BV>",
		leaderboard = "–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤",
		position = "<V><p align=\"center\">–î–æ–ª–∂–Ω–æ—Å—Ç—å",
		username = "<V><p align=\"center\">–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è",
		community = "<V><p align=\"center\">–°–æ–æ–±—â–µ—Å—Ç–≤–æ",
		completed = "<V><p align=\"center\">–ü—Ä–æ–π–¥–µ–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã",
		overall_lb = "–í —Ü–µ–ª–æ–º",
		weekly_lb = "–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ",
		new_lang = "<v>[#] <d>–Ø–∑—ã–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ –†—É—Å—Å–∫–∏–π",

		-- Power names
		balloon = "–®–∞—Ä",
		masterBalloon = "–ú–∞—Å—Ç–µ—Ä —à–∞—Ä",
		bubble = "–ü—É–∑—ã—Ä—å",
		fly = "–ü–æ–ª–µ—Ç",
		snowball = "–°–Ω–µ–∂–æ–∫",
		speed = "–°–∫–æ—Ä–æ—Å—Ç—å",
		teleport = "–¢–µ–ª–µ–ø–æ—Ä—Ç",
		smallbox = "–ú–∞–ª–µ–Ω—å–∫–∏–π —è—â–∏–∫",
		cloud = "–û–±–ª–∞–∫–æ",
		rip = "–ú–æ–≥–∏–ª–∞",
		choco = "–®–æ–∫–æ–ª–∞–¥–Ω–∞—è –ø–∞–ª–∫–∞",
		bigBox = "–ë–æ–ª—å—à–∞—è –∫–æ—Ä–æ–±–∫–∞",
		trampoline = "–ë–∞—Ç—É—Ç",
		toilet = "–¢—É–∞–ª–µ—Ç",
		pig = "–°–≤–∏–Ω—å—è",
		sink = "—Ç–æ–Ω—É—Ç—å",
		bathtub = "–í–∞–Ω–Ω–∞",
		campfire = "–ö–æ—Å—Ç—ë—Ä",
		chair = "–°—Ç—É–ª",
	}
	--[[ End of file translations/parkour/ru.lua ]]--
	--[[ File translations/parkour/id.lua ]]--
	translations.id = {
	    name = "id",
	    fullname = "Bahasa Indonesia",

	    -- Error messages
	    corrupt_map = "<r>Peta rusak. Sedang Memuat lainnya.",
	    corrupt_map_vanilla = "<r>[KESALAHAN] <n>Tidak bisa mendapatkan informasi dari peta ini.",
	    corrupt_map_mouse_start = "<r>[KESALAHAN] <n>Peta ini harus memiliki posisi awal (titik spawn tikus).",
	    corrupt_map_needing_chair = "<r>[KESALAHAN] <n>Peta harus memiliki kursi di akhir.",
	    corrupt_map_missing_checkpoints = "<r>[KESALAHAN] <n>Peta harus memiliki setidaknya satu cekpoin (paku kuning).",
	    corrupt_data = "<r>Sayangnya, data kamu rusak dan telah disetel ulang.",
	    min_players = "<r>Untuk menyimpan data kamu, setidaknya ada 4 pemain di ruangan ini. <bl>[%s/%s]",
	    tribe_house = "<r>Data tidak akan tersimpan di rumah suku.",
	    invalid_syntax = "<r>Sintaks tidak valid.",
	    code_error = "<r>Terjadi kesalahan: <bl>%s-%s-%s %s",
	    emergency_mode = "<r>Memulai penghentian darurat, tidak ada pemain baru diizinkan. Dimohon untuk pergi ke ruangan #parkour lain.",
	    leaderboard_not_loaded = "<r>Papan peringkat belum dimuat. Mohon Tunggu sebentar.",
	    max_power_keys = "<v>[#] <r>Kamu dapat memiliki paling banyak %s kemampuan pada key yang sama.",

	    -- Help window
	    help = "Bantuan",
	    staff = "Staff",
	    rules = "Peraturan",
	    contribute = "Kontribusi",
	    changelog = "Berita",
	    help_help = "<p align = 'center'><font size = '14'>Selamat datang di ruangan <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Tujuan kamu adalah meraih semua cekpoin sebelum menyelesaikan peta</J></p>\n\n<N>‚Ä¢ Tekan <O>O</O>, ketik <O>!op</O> atau klik pada <O>tombol konfigurasi</O> untuk membuka <T>menu opsi</T>.\n‚Ä¢ Tekan <O>P</O> atau klik <O>ikon tangan</O> pada kanan atas untuk membuka <T>menu kemampuan</T>.\n‚Ä¢ Tekan <O>L</O> atau ketik <O>!lb</O> untuk membuka <T>papan peringkat</T>.\n‚Ä¢ Tekan <O>M</O> atau tombol <O>Delete</O> untuk <T>/mort</T>, kamu bisa mengaktifkan tombol di menu <J>Opsi</J>.\n‚Ä¢ Untuk mengetahui <O>staf</O> kami dan <O>aturan parkur</O>, klik pada tab <T>Staf</T> dan <T>Aturan</T>.\n‚Ä¢ Klik <a href='event:discord'><o>disini</o></a> untuk mendapatkan tautan discord dan <a href='event:map_submission'><o>disini</o></a> untuk mendapatkan tautan topik mengenai pengajuan peta.\n‚Ä¢ Gunakan <o>atas</o> dan <o>bawah</o> tombol panah ketika kamu ingin melakukan scroll.\n\n<p align = 'center'><font size = '13'><T>Kontribusi sekarang telat dibuka! Untuk info lebih lanjut, klik pada tab <O>Kontribusi</O>!</T></font></p>",
	    help_staff = "<p align = 'center'><font size = '13'><r>DISCLAIMER: Staf Parkur BUKAN staff Transformice dan TIDAK memiliki kemampuan apapun didalam game itu sendiri, hanya di dalam modul.</r>\nStaff parkur memastikan modul berjalan sempurna dengan masalah yang minim, dan akan selalu tersedia untuk membantu pemain kapan pun dibutuhkan.</font></p>\nKamu bisa mengetik <D>!staff</D> di chat untuk melihat list staf.\n\n<font color = '#E7342A'>Admin:</font> Mereka bertanggung jawab dalam mengembangkan modul dengan menambahkan update baru ataupun memperbaiki bug.\n\n<font color = '#D0A9F0'>Manager Tim:</font> Mereka mengawasi tim dari moderator dan mappers untuk memastikan mereka mengerjakan perkerjaan mereka dengan baik. Mereka juga bertanggung jawab untuk merekrut anggota baru ke tim staf.\n\n<font color = '#FFAAAA'>Moderator:</font> Mereka bertanggung jawab untuk menegakkan aturan dari modul dan memberikan sanksi untuk individu yang tidak mengikutinya.\n\n<font color = '#25C059'>Mappers:</font> Mereka bertanggung jawab dalam meninjau, menambahkan, menghapus peta yang ada di modul untuk memastikan permainan yang menyenangkan.",
	    help_rules = "<font size='13'><B><J>Semua aturan dalam Syarat dan Ketentuan Transformice berlaku juga di #parkour</J></B></font>\n\nJika kamu menemukan pemain yang melanggar aturan tersebut, bisik moderator di game. Jika tidak ada moderator yang online, direkomendasikan untuk melaporkan melalui server discord. \nKetika melaporkan, mohon untuk melampirkan server, nama ruangan, dan nama pemain. \n‚Ä¢ Contoh: en-#parkour10 Blank#3495 trolling\nBukti seperti tangkapan layar, video, dan gif sangat membantu dan dihargai, tetapi tidak perlu.\n\n<font size='11'>‚Ä¢ Tidak ada <font color='#ef1111'>hacks, glitches or bugs</font> yang digunakan di ruangan #parkour\n‚Ä¢ <font color='#ef1111'>VPN farming</font> akan dianggap sebagai <B>mengeksploitasi</B> dan tidak diizinkan.<p align='center'><font color='#cc2222' size='12'><B>\nSiapapun yang ketahuan melanggar aturan ini akan segera diblokir.</B></font></p>\n\n<font size='12'>Transformice mengizinkan konsep trolling. Namun, <font color='#cc2222'><B>kami tidak mengizinkannya di parkour.</B></font></font>\n\n<p align='center'><J>Trolling adalah ketika seorang pemain dengan sengaja menggunakan kemampuan atau consumables untuk mencegah pemain lain dalam menyelesaikan peta.</j></p>\n‚Ä¢ Trolling balas dendam<B> bukan sebuah alasan yang valid</B> untuk melakukan troll kepada seseorang dan kamu akan tetap diberi hukuman.\n‚Ä¢ Memaksa membantu pemain yang mencoba untuk menyelesaikan peta sendirian dan menolak untuk berhenti melakukannya jika diminta juga termasuk sebagai trolling\n‚Ä¢ <J>Jika seorang pemain tidak ingin bantuan dan lebih memilih solo, lebih baik membantu pemain yang lain</J>. Namun jika ada pemain lain yang meminta bantuan di cekpoin yang sama dengan pemain solo, kamu bisa membantu mereka [Keduanya].\n\nJika pemain tertangkap melakukan trolling, mereka akan mendapatkan hukuman berbasis waktu. Perlu diperhatikan bahwa trolling yang berulang akan mengakibatkan hukuman yang lebih lama dan lebih berat.",
	    help_contribute = "<font size='14'>\n<p align='center'>Tim managemen parkur menyukai kode sumber terbuka karena itu  <t>membantu komunitas</t>. Kamu bisa <o>melihat</o> dan <o>memodifikasi</o> kode sumber dari <o><u><a href='event:github'>GitHub</a></u></o>.\n\nMemelihara modul <t>sepenuhnya bersifat sukarela</t>, sehingga bantuan mengenai <t>kode</t>, <t>laporan bug</t>, <t>saran</t> dan <t>pembuatan peta</t> selalu <u>diterima dan dihargai</u>.\nKamu bisa <vp>melaporkan bug</vp> dan <vp>memberikan saran</vp> pada <o><u><a href='event:discord'>Discord</a></u></o> dan/atau <o><u><a href='event:github'>GitHub</a></u></o>.\nKamu bisa <vp>mengirimkan peta kamu</vp> di <o><u><a href='event:map_submission'>Forum Thread</a></u></o> kami.\n\nMemelihara parkur memang tidak mahal, tapi juga tidak gratis. Kami akan senang jika kamu bisa membantu kami dengan <t>berdonasi berapapun jumlahnya</t> <o><u><a href='event:donate'>disini</a></u></o>.\n<u>Semua donasi akan digunakna untuk meningkatkan modul.</u></p>",
	    help_changelog = "<font size='13'><p align='center'><o>Versi 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ Implementasi <cep>sistem rekor</cep>! Silahkan cek pada <vp><u>*#parkour0records NamaKamu#Tag</u></vp>\n‚Ä¢ Peningkatan rotasi peta.\n‚Ä¢ Peningkatan <o><u><a href='event:discord'>Discord</a></u></o> verifikasi.",

	    -- Congratulation messages
	    reached_level = "<d>Selamat! Kamu meraih level <vp>%s</vp>.",
	    finished = "<d><o>%s</o> menyelesaikan parkur dalam <vp>%s</vp> detik, <fc>selamat!",
	    unlocked_power = "<ce><d>%s</d> membuka kemampuan <vp>%s</vp>.",

	    -- Information messages
	    staff_power = "<p align='center'><font size='12'><r>Staf parkur <b>tidak memiliki</b> kemampuan apapun diluar ruangan #parkour.",
	    donate = "<vp>Tulis <b>!donate</b> jika kamu ingin berdonasi untuk modul ini!",
	    paused_events = "<cep><b>[Perhatian!]</b> <n>Modul mencapai batas kritis dan akan dihentikan.",
	    resumed_events = "<n2>Modul telah dilanjutkan.",
	    welcome = "<n>Selamat datang di <t>#parkour</t>!",
	    module_update = "<r><b>[Perhatian!]</b> <n>Modul akan diperbarui dalam <d>%02d:%02d</d>.",
	    leaderboard_loaded = "<j>Papan peringkat sudah dimuat. Tekan L untuk membukanya.",
	    kill_minutes = "<R>Kemampuan kamu dimatikan dalam %s menit.",
	    permbanned = "<r>Kamu diblokir secara permanen di #parkour.",
	    tempbanned = "<r>Kamu diblokir dari #parkour selama %s menit.",

	    -- Records
	    records_enabled = "<v>[#] <d>Mode rekor diaktifkan di room ini. Statistik tidak dihitung dan kekuatan tidak diaktifkan!\nKamu bisa mencari informasi lebih lanjut mengenai rekor di <b>%s</b>",
	    records_admin = "<v>[#] <d>Kamu adalah admin di ruangan rekor ini. Kamu bisa menggunakan perintah <b>!map</b>, <b>!pw</b> dan <b>!time</b>.",
	    records_completed = "<v>[#] <d>Kamu telah menyelesaikan peta! Jika kamu ingin mengulanginya lagi, ketik <b>!redo</b>.",
	    records_submit = "<v>[#] <d>Wow! Sepertinya kamu memiliki waktu tercepat di ruangan. Jika kamu ingin mengirimkan rekor kamu, ketik <b>!submit</b>.",
	    records_invalid_map = "<v>[#] <r>Sepertinya ruangan ini tidak masuk dalam rotasi parkur... Kamu tidak bisa mengirim rekor ini!",
	    records_not_fastest = "<v>[#] <r>Sepertinya kamu bukan pemain tercepat di ruangan ini...",
	    records_already_submitted = "<v>[#] <r>Kamu sudah mengirimkan rekor kamu untuk peta ini!",
	    records_submitted = "<v>[#] <d>Rekor kamu untuk peta <b>%s</b> telah dikirim.",

	    -- Miscellaneous
	    options = "<p align='center'><font size='20'>Opsi Parkur</font></p>\n\nGunakan partikel untuk cekpoin\n\nGunakan keyboard <b>QWERTY</b> (nonaktifkan jika <b>AZERTY</b>)\n\nGunakan <b>M</b> hotkey untuk <b>/mort</b> (nonaktifkan untuk <b>DEL</b>)\n\nPerlihatkan cooldown kemampuan kamu\n\nPerlihatkan tombol kemampuan\n\nPerlihatkan tombol bantuan\n\nPerlihatkan pengumuman penyelesaian peta\n\nPerlihatkan simbol tidak memerlukan bantuan",
	    cooldown = "<v>[#] <r>Mohon Tunggu beberapa detik untuk melakukannya kembali.",
	    power_options = ("<font size='13' face='Lucida Console'>Keyboard <b>QWERTY</b>" ..
	                    "\n\n<b>Tutup</b> penghitung peta"),
	    unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Selesaikan <v>%s</v> peta" ..
	                    "<font size='5'>\n\n</font>untuk membuka" ..
	                    "<font size='5'>\n\n</font><v>%s</v>"),
	    upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Selesaikan <v>%s</v> peta" ..
	                    "<font size='5'>\n\n</font>untuk meningkatkan ke" ..
	                    "<font size='5'>\n\n</font><v>%s</v>"),
	    unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Peringkat <v>%s</v>" ..
	                    "<font size='5'>\n\n</font>untuk membuka" ..
	                    "<font size='5'>\n\n</font><v>%s</v>"),
	    upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Peringkat <v>%s</v>" ..
	                    "<font size='5'>\n\n</font>untuk meningkatkan ke" ..
	                    "<font size='5'>\n\n</font><v>%s</v>"),
	    maps_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
	                "<font size='5'>\n\n</font>Peta yang diselesaikan"),
	    overall_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
	                    "<font size='5'>\n\n</font>Papan Peringkat Keseluruhan"),
	    weekly_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
	                    "<font size='5'>\n\n</font>Papan Peringkat Mingguan"),
	    badges = "<font size='14' face='Lucida Console,Verdana'>Lencana (%s): <a href='event:_help:badge'><j>[?]</j></a>",
	    private_maps = "<bl>Jumlah peta pada pemain ini bersifat Pribadi. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
	    profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
	                "Posisi papan peringkat keseluruhan: <b><v>%s</v></b>\n\n" ..
	                "Posisi papan peringkat mingguan: <b><v>%s</v></b>"),
	    map_count = "Jumlah peta: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
	    help_badge = "Lencana adalah pencapaian yang bisa didapatkan pemain. Klik diatasnya untuk melihat deskripsinya.",
	    help_private_maps = "Pemain ini tidak mau membagikan jumlah peta mereka ke publik! Kamu bisa menyembunyikannya juga di profil.",
	    help_badge_1 = "Pemain ini pernah menjadi anggota staf parkur sebelumnya.",
	    help_badge_2 = "Pemain ini berada atau pernah di halaman 1 dari papan perungkat keseluruhan.",
	    help_badge_3 = "Pemain ini berada atau pernah di halaman 2 dari papan perungkat keseluruhan.",
	    help_badge_4 = "Pemain ini berada atau pernah di halaman 3 dari papan perungkat keseluruhan.",
	    help_badge_5 = "Pemain ini berada atau pernah di halaman 4 dari papan perungkat keseluruhan.",
	    help_badge_6 = "Pemain ini berada atau pernah di halaman 5 dari papan perungkat keseluruhan.",
	    help_badge_7 = "Pemain ini pernah berada di podium pada akhir papan peringkat mingguan.",
	    help_badge_8 = "Pemain ini memiliki rekor 30 peta per jam.",
	    help_badge_9 = "Pemain ini memiliki rekor 35 peta per jam.",
	    help_badge_10 = "Pemain ini memiliki rekor 40 peta per jam.",
	    help_badge_11 = "Pemain ini memiliki rekor 45 peta per jam.",
	    help_badge_12 = "Pemain ini memiliki rekor 50 peta per jam.",
	    help_badge_13 = "Pemain ini memiliki rekor 55 peta per jam.",
	    help_badge_14 = "Pemain ini telah memverifikasi akun mereka di server discord resmi parkur (ketik <b>!discord</b>).",
	    help_badge_15 = "Pemain ini menjadi yang tercepat pada 1 peta.",
	    help_badge_16 = "Pemain ini menjadi yang tercepat pada 5 peta.",
	    help_badge_17 = "Pemain ini menjadi yang tercepat pada 10 peta.",
	    help_badge_18 = "Pemain ini menjadi yang tercepat pada 15 peta.",
	    help_badge_19 = "Pemain ini menjadi yang tercepat pada 20 peta.",
	    help_badge_20 = "Pemain ini menjadi yang tercepat pada 25 peta.",
	    help_badge_21 = "Pemain ini menjadi yang tercepat pada 30 peta.",
	    help_badge_22 = "Pemain ini menjadi yang tercepat pada 35 peta.",
	    help_badge_23 = "Pemain ini menjadi yang tercepat pada 40 peta.",
	    make_public = "jadikan publik",
	    make_private = "jadikan privasi",
	    moderators = "Moderator",
	    mappers = "Mappers",
	    managers = "Manager",
	    administrators = "Admin",
	    close = "Tutup",
	    cant_load_bot_profile = "<v>[#] <r>Kamu tidak bisa melihat profil bot ketika #parkour menggunakannya secara internal untuk bekerja lebih baik.",
	    cant_load_profile = "<v>[#] <r>Pemain <b>%s</b> sepertinya offline atau tidak tersedia.",
	    like_map = "Apakah kamu menyukai peta ini?",
	    yes = "Ya",
	    no = "Tidak",
	    idk = "Tidak tahu",
	    unknown = "Tidak diketahui",
	    powers = "Kemampuan",
	    press = "<vp>Tekan %s",
	    click = "<vp>Klik kiri",
	    ranking_pos = "Peringkat #%s",
	    completed_maps = "<p align='center'><BV><B>Peta diselesaikan: %s</B></p></BV>",
	    leaderboard = "Papan Peringkat",
	    position = "Posisi",
	    username = "Nama panggilan",
	    community = "Komunitas",
	    completed = "Peta diselesaikan",
	    overall_lb = "Keseluruhan",
	    weekly_lb = "Mingguan",
	    new_lang = "<v>[#] <d>Bahasa telah diubah ke Bahasa Indonesia",

	    -- Power names
	    balloon = "Balon",
	    masterBalloon = "Master Balon",
	    bubble = "Gelembung",
	    fly = "Terbang",
	    snowball = "Bola Salju",
	    speed = "Speed",
	    teleport = "Teleport",
	    smallbox = "Kotak Kecil",
	    cloud = "Awan",
	    rip = "Batu Nisan",
	    choco = "Papan Cokelat",
	    bigBox = "Kotak besar",
	    trampoline = "Trampolin",
	    toilet = "Toilet",
	    pig = "Babi",
	    sink = "Wastafel",
	    bathtub = "Bak Mandi",
	    campfire = "Api Unggun",
	    chair = "Kursi",
	}
	--[[ End of file translations/parkour/id.lua ]]--
	--[[ File translations/parkour/cn.lua ]]--
	translations.cn = {
		name = "cn",
		fullname = "‰∏≠Êñá",

		-- Error messages
		corrupt_map = "<r>Âú∞ÂúñÂ¥©Â£û„ÄÇÊ≠£Âú®ËºâÂÖ•Âè¶‰∏ÄÂºµ„ÄÇ",
		corrupt_map_vanilla = "<r>[ÈåØË™§] <n>ÁÑ°Ê≥ïÂèñÂæóÊ≠§Âú∞ÂúñÁöÑË≥áË®ä„ÄÇ",
		corrupt_map_mouse_start = "<r>[ÈåØË™§] <n>Ê≠§Âú∞ÂúñÈúÄË¶ÅÊúâËµ∑Âßã‰ΩçÁΩÆ (Â∞èÈº†Âá∫ÁîüÈªû)„ÄÇ",
		corrupt_map_needing_chair = "<r>[ÈåØË™§] <n>Âú∞ÂúñÈúÄË¶ÅÂåÖÊã¨ÁµÇÈªûÊ§ÖÂ≠ê„ÄÇ",
		corrupt_map_missing_checkpoints = "<r>[ÈåØË™§] <n>Âú∞ÂúñÈúÄË¶ÅÊúâÊúÄÂ∞ë‰∏ÄÂÄãÈáçÁîüÈªû (ÈªÉËâ≤ÈáòÂ≠ê)„ÄÇ",
		corrupt_data = "<r>‰∏çÂπ∏Âú∞, ‰Ω†ÁöÑË≥áÊñôÂ¥©Â£û‰∫ÜËÄåË¢´ÈáçÁΩÆ‰∫Ü„ÄÇ",
		min_players = "<r>ÊàøÈñìË£°ÈúÄË¶ÅËá≥Â∞ë4ÂêçÁé©ÂÆ∂ÊâçÂèØ‰ª•‰øùÂ≠òË≥áÊñô„ÄÇ <bl>[%s/%s]",
		tribe_house = "<r>Âú®ÈÉ®ËêΩ‰πãÂÆ∂ÈÅäÁé©ÁöÑË≥áÊñô‰∏çÊúÉË¢´ÂÑ≤Â≠ò„ÄÇ",
		invalid_syntax = "<r>ÁÑ°ÊïàÁöÑÊ†ºÂºè„ÄÇ",
		code_error = "<r>ÁôºÁîü‰∫ÜÈåØË™§: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Ê≠£Âú®ÂïüÂãïÁ∑äÊÄ•ÁµÇÊ≠¢Ê®°Âºè, Êñ∞Áé©ÂÆ∂ÁÑ°Ê≥ïÂä†ÂÖ•ÈÅäÊà≤„ÄÇË´ãÂâçÂæÄÂè¶‰∏ÄÂÄã„ÄÄ#parkour ÊàøÈñì„ÄÇ",
		leaderboard_not_loaded = "<r>ÊéíË°åÊ¶úÊ≤íË¢´Âä†Ëºâ„ÄÇË´ãÁ®çÂæåÁâáÂàª„ÄÇ",
		max_power_keys = "<v>[#] <r>‰Ω†Âè™ÂèØ‰ª•Âú®Âêå‰∏ÄÂÄãÊåâÈçµ‰ΩøÁî®ÊúÄÂ§ö %s ÂÄãËÉΩÂäõ„ÄÇ",

		-- Help window
		help = "Âπ´Âä©",
		staff = "ËÅ∑Âì°",
		rules = "Ë¶èÂâá",
		contribute = "Ë≤¢Áçª",
		changelog = "Êñ∞ËÅû",
		help_help = "<p align = 'center'><font size = '14'>Ê≠°Ëøé‰æÜÂà∞ <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>‰Ω†ÁöÑÁõÆÊ®ôÊòØÂà∞ÈÅîÊâÄÊúâÈáçÁîüÈªûÁõ¥Âà∞ÂÆåÊàêÂú∞Âúñ„ÄÇ</J></p>\n\n<N>‚Ä¢ Êåâ <O>O</O>Èçµ, Ëº∏ÂÖ• <O>!op</O> ÊàñÊòØÈªûÊìäÂè≥‰∏äÊñπÁöÑ <O>ÈΩíËº™</O> ‰æÜÈñãÂïü <T>ÈÅ∏È†ÖÁõÆÈåÑ</T>„ÄÇ\n‚Ä¢ Êåâ <O>P</O> ÈçµÊàñÊòØÈªûÊìäÂè≥‰∏äÊñπÁöÑ <O>Êã≥È†≠Ê®ôË™å</O> ‰æÜÈñãÂïü <T>ËÉΩÂäõÁõÆÈåÑ</T>„ÄÇ\n‚Ä¢ Êåâ <O>L</O> ÈçµÊàñÊòØËº∏ÂÖ• <O>!lb</O> ‰æÜÈñãÂïü <T>ÊéíË°åÊ¶ú</T>„ÄÇ\n‚Ä¢ Êåâ <O>M</O> ÈçµÊàñÊòØ <O>Âà™Èô§</O> Èçµ‰æÜ <T>Ëá™ÊÆ∫</T>, ‰Ω†ÂèØ‰ª•Âú® <J>ÈÅ∏È†Ö</J> ÁõÆÈåÑ‰∏≠ÊøÄÊ¥ªÊåâÈçµ„ÄÇ\n‚Ä¢ Ë¶ÅÁü•ÈÅìÊõ¥Â§öÈóúÊñºÊàëÂÄë <O>ËÅ∑Âì°</O> ÁöÑË≥áË®ä‰ª•Âèä <O>parkour ÁöÑË¶èÂâá</O>, ÂèØÈªûÊìä <T>ËÅ∑Âì°</T> Âèä <T>Ë¶èÂâá</T> ÁöÑÂàÜÈ†ÅÊü•Áúã„ÄÇ\n‚Ä¢ ÈªûÊìä <a href='event:discord'><o>ÈÄôË£°</o></a> ‰æÜÂèñÂæó discord ÈÇÄË´ãÈÄ£ÁµêÂèä <a href='event:map_submission'><o>ÈÄôË£°</o></a> ‰æÜÂæóÂà∞Êèê‰∫§Âú∞ÂúñÁöÑË´ñÂ£áÈÄ£Áµê„ÄÇ\n‚Ä¢ Áï∂‰Ω†ÊÉ≥ÊªæÂãïÈ†ÅÈù¢ÂèØ‰ΩøÁî® <o>‰∏ä</o> ÈçµÂèä <o>‰∏ã</o> Èçµ„ÄÇ\n\n<p align = 'center'><font size = '13'><T>Ë≤¢ÁçªÁèæÂú®ÊòØÈñãÊîæÁöÑ! ÈªûÊìä <O>Ë≤¢Áçª</O> ÂàÜÈ†Å‰æÜ‰∫ÜËß£Êõ¥Â§ö!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>ÂÖçË≤¨ËÅ≤Êòé: Parkour ÁöÑËÅ∑Âì°‰∏¶‰∏çÊòØ Transformice ËÅ∑Âì°ËÄå‰∏îÂú®ÈÅäÊà≤Ë£°Ê≤íÊúâ‰ªª‰ΩïÊ¨äÂäõ, Âè™Ë≤†Ë≤¨ÈÄôÂ∞èÈÅäÊà≤ÁöÑË¶èÁÆ°„ÄÇ</r>\nParkour ËÅ∑Âì°Á¢∫‰øùÂ∞èÈÅäÊà≤Ê∏õÂ∞ëÈåØË™§ËÄåÈÅã‰ΩúÈ†ÜÊö¢, ËÄå‰∏îÂèØ‰ª•Âú®ÊúâÈúÄË¶ÅÊôÇÂçîÂä©Áé©ÂÆ∂„ÄÇ</font></p>\n‰Ω†ÂèØ‰ª•Âú®ËÅäÂ§©Ê°ÜËº∏ÂÖ• <D>!staff</D> ‰æÜÊü•ÁúãËÅ∑Âì°ÂàóË°®„ÄÇ\n\n<font color = '#E7342A'>Â∑•‰Ωú‰∫∫Âì°:</font> ‰ªñÂÄëË≤†Ë≤¨ÈÄèÈÅéÊõ¥Êñ∞Âèä‰øÆÂæ©Êª¥ÊºèÊ¥û‰æÜÁ∂≠Ë≠∑Â∞èÈÅäÊà≤„ÄÇ\n\n<font color = '#D0A9F0'>Â∞èÈöä‰∏ªÁÆ°:</font> ‰ªñÂÄëÊúÉËßÄÂØüÁÆ°ÁêÜÂúòÈöäÂèäÂú∞ÂúñÂúòÈöä, Á¢∫‰øù‰ªñÂÄëÂú®Â∑•‰Ωú‰∏äÁöÑË°®Áèæ„ÄÇ‰ªñÂÄë‰πüË≤†Ë≤¨ÊãõÂãüÊñ∞ÊàêÂì°Âä†ÂÖ•ËÅ∑Âì°ÂúòÈöä‰∏≠„ÄÇ\n\n<font color = '#FFAAAA'>ÁÆ°ÁêÜÂì°:</font> ‰ªñÂÄëË≤†Ë≤¨Âü∑Ë°åÂ∞èÈÅäÊà≤Ë£°ÁöÑË¶èÂâá‰ª•ÂèäËôïÂàÜÈÅïÂèçË¶èÂâáÁöÑÁé©ÂÆ∂„ÄÇ\n\n<font color = '#25C059'>Âú∞ÂúñÁÆ°ÁêÜÂì°:</font> ‰ªñÂÄëË≤†Ë≤¨ÂØ©Ê†∏, Êñ∞Â¢û, ‰ª•ÂèäÁßªÈô§Â∞èÈÅäÊà≤Ë£°ÁöÑÂú∞Âúñ‰æÜÁ¢∫‰øù‰Ω†ÂèØ‰ª•‰∫´ÂèóÈÅäÊà≤ÈÅéÁ®ã„ÄÇ",
		help_rules = "<font size = '13'><B><J>ÊâÄÊúâÈÅ©Áî®Êñº Transformice ÁöÑÊ¢ùÊ¨æÂèäÁ¥∞Ââá‰πüÈÅ©Áî®Êñº #parkour</J></B></font>\n\nÂ¶ÇÊûú‰Ω†ÁôºÁèæ‰ªª‰ΩïÁé©ÂÆ∂ÈÅïÂèçÈÄô‰∫õË¶èÂâá, ÂèØ‰ª•Âú®ÈÅäÊà≤‰∏≠ÁßÅËÅä parkour ÁöÑÁÆ°ÁêÜÂì°„ÄÇÂ¶ÇÊûúÊ≤íÊúâÁÆ°ÁêÜÂì°Âú®Á∑ö, ‰Ω†ÂèØ‰ª•Âú® discord ‰º∫ÊúçÂô®‰∏≠ËàâÂ†±‰∫ã‰ª∂„ÄÇ\nÁï∂‰Ω†ËàâÂ†±ÁöÑÊôÇÂÄô, Ë´ãÊèê‰æõ‰Ω†ÊâÄÂú®ÁöÑ‰º∫ÊúçÂô®, ÊàøÈñìÂêçÁ®±, ‰ª•ÂèäÁé©ÂÆ∂ÂêçÁ®±„ÄÇ\n‚Ä¢ ‰æãÂ¶Ç: en-#parkour10 Blank#3495 trolling\nË≠âÊòé, ‰æãÂ¶ÇÊòØÊà™Âúñ, ÈåÑË±°‰ª•ÂèägifÂúñËÉΩÊúâÊïàÂçîÂä©ËàâÂ†±, ‰ΩÜ‰∏çÊòØ‰∏ÄÂÆöÈúÄË¶ÅÁöÑ„ÄÇ\n\n<font size = '11'>‚Ä¢ ‰ªª‰Ωï <font color = '#ef1111'>Â§ñÊéõ, ÁëïÁñµÊàñÊºèÊ¥û</font> ÊòØ‰∏çËÉΩÂú® #parkour ÊàøÈñì‰∏≠‰ΩøÁî®\n‚Ä¢ <font color = '#ef1111'>VPN Âà∑Êï∏Êìö</font> ÊúÉË¢´Áï∂‰Ωú <B>Âà©Áî®ÊºèÊ¥û</B> ËÄå‰∏çË¢´ÂÖÅË®±ÁöÑ„ÄÇ <p align = 'center'><font color = '#cc2222' size = '12'><B>\n‰ªª‰Ωï‰∫∫Ë¢´ÊäìÂà∞ÈÅïÂèçË¶èÂâáÊúÉË¢´Âç≥ÊôÇÂ∞ÅÁ¶Å„ÄÇ</B></font></p>\n\n<font size = '12'>Transformice ÂÖÅË®±ÊêóËõãË°åÁÇ∫„ÄÇ‰ΩÜÊòØ, <font color='#cc2222'><B>ÊàëÂÄë‰∏çÂÖÅË®±Âú® parkour ÁöÑÊêóËõãË°åÁÇ∫„ÄÇ</B></font></font>\n\n<p align = 'center'><J>ÊÉ°‰ΩúÂäáÊòØÊåá‰∏ÄÂÄãÁé©ÂÆ∂ÊúâÊÑèÂúñÂú∞‰ΩøÁî®ËÉΩÂäõÊàñÊ∂àËÄóÂìÅ‰æÜÈòªÊ≠¢ÂÖ∂‰ªñÁé©ÂÆ∂ÂÆåÊàêÂú∞Âúñ„ÄÇ</j></p>\n‚Ä¢ Âæ©‰ªáÊÄßÁöÑÊêóËõãË°åÁÇ∫ <B>‰∏¶‰∏çÊòØ‰∏ÄÂÄãÂêàÁêÜËß£Èáã</B> ‰æÜÊêó‰∫ÇÂà•‰∫∫ËÄåÂõ†Ê≠§‰Ω†‰πüÊúÉË¢´ËôïÂàÜ„ÄÇ\n‚Ä¢ Âº∑Ëø´ÊÉ≥Ëá™ÁêÜÁöÑÁé©ÂÆ∂Êé•ÂèóÂçîÂä©ËÄåÁï∂‰ªñË™™‰∏çÁî®‰πãÂæå‰ªçËàäÊ≤íÊúâÂÅúÊ≠¢Ê≠§Ë°åÁÇ∫‰πüÊúÉË¢´Ë¶ñ‰ΩúÊêóËõã„ÄÇ\n‚Ä¢ <J>Â¶ÇÊûú‰∏ÄÂÄãÁé©ÂÆ∂‰∏çÊÉ≥Ë¢´ÂçîÂä©ÊàñÊòØÊÉ≥Ëá™ÁêÜÈÄöÈóú, Ë´ã‰Ω†Áõ°ÂäõÂçîÂä©ÂÖ∂‰ªñÁé©ÂÆ∂„ÄÇ</J> ‰ΩÜÊòØÂ¶ÇÊûúÊúâÂè¶Â§ñÁöÑÁé©ÂÆ∂ÈúÄË¶ÅÂçîÂä©ËÄåÂâõÂ•ΩË∑üËá™ÁêÜÁé©ÂÆ∂Âú®Âêå‰∏ÄÂÄãÈáçÁîüÈªû, ‰Ω†ÂèØ‰ª•ÂçîÂä©‰ªñÂÄë [ÂÖ©‰∫∫]„ÄÇ\n\nÂ¶ÇÊûúÁé©ÂÆ∂ÊÉ°‰ΩúÂäáË¢´Êäì, ÊúÉË¢´ËôïÂàÜÂü∫ÊñºÊôÇÈñìÁöÑÊá≤ÁΩ∞„ÄÇÈáçË¶ÜÁöÑÊêóËõãË°åÁÇ∫ÊúÉÂºïËá≥Êõ¥Èï∑ÂèäÊõ¥Âö¥ÈáçÁöÑËôïÂàÜ„ÄÇ",
		help_contribute = "<font size='14'>\n<p align='center'>Parkour ÁÆ°ÁêÜÂúòÈöäÂñúÊÑõÈñãÊîæÂéüÂßãÁ¢ºÊòØÂõ†ÁÇ∫ÂÆÉËÉΩÂ§†<t>ÂçîÂä©Á§æÁæ§</t>„ÄÇ ‰Ω†ÂèØ‰ª•Âú® <o><u><a href='event:github'>GitHub</a></u></o> <o>Êü•Áúã</o> ‰ª•Âèä <o>‰øÆÊîπ</o> ÂéüÂßãÁ¢º„ÄÇ\n\nÁ∂≠Ë≠∑ÈÄôÂÄãÂ∞èÈÅäÊà≤ÊòØ <t>Áæ©ÂãôÊÄßË≥™</t>, ÊâÄ‰ª•‰ªª‰ΩïÂú® <t>Á∑®Á®ã</t>, <t>ÊºèÊ¥ûÂõûÈ•ã</t>, <t>Âª∫Ë≠∞</t> Âèä <t>Âú∞ÂúñÂâµ‰Ωú</t> ‰∏äÊèê‰æõÁöÑÂπ´Âä©Â∞áÊúÉÊòØÂçÅÂàÜ <u>Ê≠°ËøéËÄå‰∏îÈùûÂ∏∏ÊÑüÊøÄ</u>„ÄÇ\n‰Ω†ÂèØ‰ª•Âú® <o><u><a href='event:discord'>Discord</a></u></o> Âèä/Êàñ <o><u><a href='event:github'>GitHub</a></u></o> <vp>ÂåØÂ†±ÊºèÊ¥û</vp> Âíå <vp>Êèê‰æõÊÑèË¶ã</vp>„ÄÇ\n‰Ω†ÂèØ‰ª•Âú®ÊàëÂÄëÁöÑ <o><u><a href='event:map_submission'>Ë´ñÂ£áÂ∏ñÂ≠ê</a></u></o> ‰∏≠ <vp>Êèê‰∫§‰Ω†ÁöÑÂú∞Âúñ</vp>„ÄÇ\n\nÁ∂≠Ë≠∑ Parkour ‰∏çÊòØÂæàËä±Ë≤ª, ‰ΩÜ‰πü‰∏çÂÆåÂÖ®ÊòØÂÖçË≤ª„ÄÇÊàëÂÄëÂ∏åÊúõ‰Ω†ËÉΩÂ§†Âú® <o><u><a href='event:donate'>ÈÄôË£°</a></u></o> <t>ÊçêË¥à‰ªª‰ΩïÈáëÈ°ç</t> ‰æÜÊîØÊåÅÊàëÂÄë„ÄÇ\n<u>ÊâÄÊúâÊçêÊ¨æÊúÉÁî®‰æÜÊîπÂñÑÈÄôÂÄãÂ∞èÈÅäÊà≤„ÄÇ</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>ÁâàÊú¨ 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ Êñ∞Â¢û‰∫Ü <cep>ÊôÇÈñìÁ¥ÄÈåÑÁ≥ªÁµ±</cep>! ÂèØ‰ª•Âà∞ <vp><u>*#parkour0records ‰Ω†ÁöÑÂêçÂ≠ó#Á∑®Ëôü</u></vp> ÁôºÊéò‰∏Ä‰∏ã„ÄÇ\n‚Ä¢ ÊîπÂñÑ‰∫ÜÂú∞ÂúñÂæ™Áí∞Á≥ªÁµ±„ÄÇ\n‚Ä¢ ÊîπÂñÑ‰∫Ü <o><u><a href='event:discord'>Discord</a></u></o> Ë™çË≠âÁ®ãÂ∫è„ÄÇ",

		-- Congratulation messages
		reached_level = "<d>ÊÅ≠Âñú! ‰Ω†Âà∞ÈÅî‰∫ÜÁ¨¨ <vp>%s</vp> ÂÄãÈáçÁîüÈªû„ÄÇ",
		finished = "<d><o>%s</o> Âú® <vp>%s</vp> ÁßíÂÖßÂÆåÊàê‰∫ÜÂú∞Âúñ, <fc>ÊÅ≠Âñú!",
		unlocked_power = "<ce><d>%s</d> Ëß£Èéñ‰∫Ü <vp>%s</vp> ËÉΩÂäõ„ÄÇ",

		-- Information messages
		staff_power = "<r>Parkour ËÅ∑Âì° <b>‰∏çÊúÉ</b> ÊìÅÊúâ‰ªª‰ΩïÂú® #parkour ÊàøÈñì‰ª•Â§ñÁöÑÊ¨äÂäõ„ÄÇ",
		donate = "<vp>Â¶ÇÊûú‰Ω†ÊÉ≥ÁÇ∫Ê≠§Â∞èÈÅäÊà≤ÊçêÊ¨æÔºåË´ãËº∏ÂÖ•<b>!donate</b>ÔºÅ",
		paused_events = "<cep><b>[Ë≠¶Âëä!]</b> <n>Â∞èÈÅäÊà≤Â∑≤ÈÅîÂà∞ÊúÄÈ´òÊµÅÈáèÈôêÂà∂ËÄåË¢´Êö´ÂÅú‰∫Ü„ÄÇ",
		resumed_events = "<n2>Â∞èÈÅäÊà≤Â∑≤ÁπºÁ∫åÂïüÁî®„ÄÇ",
		welcome = "<n>Ê≠°Ëøé‰æÜÂà∞ <t>#parkour</t>!",
		module_update = "<r><b>[Ë≠¶Âëä!]</b> <n>Â∞èÈÅäÊà≤Â∞áÊúÉÂú® <d>%02d:%02d</d> ÂæåÊõ¥Êñ∞„ÄÇ",
		leaderboard_loaded = "<j>ÊéíË°åÊ¶úÂ∑≤ËºâÂÖ•„ÄÇË´ãÊåâ L ÈçµÊâìÈñãÂÆÉ„ÄÇ",
		kill_minutes = "<R>‰Ω†ÁöÑËÉΩÂäõÂ∑≤Á∂ìÂú® %s ÂàÜÈêòÂÖßÊö´ÊôÇÂèñÊ∂à‰∫Ü„ÄÇ",
		permbanned = "<r>‰Ω†Â∑≤Á∂ìÂú® #parkour Ë¢´Ê∞∏‰πÖÂ∞ÅÁ¶Å„ÄÇ",
		tempbanned = "<r>‰Ω†Â∑≤Á∂ìÂú® #parkour Ë¢´Â∞ÅÁ¶Å‰∫Ü %s ÂàÜÈêò„ÄÇ",

		-- Records
		records_enabled = "<v>[#] <d>Ë®òÈåÑÊ®°ÂºèÂ∑≤Âú®ÈÄôÊàøÈñìÂïüÁî®„ÄÇÊï∏Êìö‰∏çÊúÉË¢´Ë®òÈåÑËÄå‰∏î‰∏çËÉΩ‰ΩøÁî®ËÉΩÂäõ!\n‰Ω†ÂèØ‰ª•Âú®ÈÄôË£°Êü•ÁúãÊõ¥Â§öÈóúÊñºË®òÈåÑÊ®°ÂºèÁöÑË≥áË®ä: <b>%s</b>",
		records_admin = "<v>[#] <d>‰Ω†ÊòØÈÄôÊàøÈñìÁöÑÁÆ°ÁêÜÂì°„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî®‰ª•‰∏ãÊåá‰ª§ <b>!map</b>, <b>!pw</b> and <b>!time</b>„ÄÇ",
		records_completed = "<v>[#] <d>‰Ω†Â∑≤Á∂ìÂÆåÊàê‰∫ÜÂú∞Âúñ! Â¶ÇÊûú‰Ω†ÊÉ≥ÈáçÊñ∞ÂòóË©¶, ÂèØËº∏ÂÖ• <b>!redo</b>„ÄÇ",
		records_submit = "<v>[#] <d>Âìá! Áúã‰æÜ‰Ω†ÈÅîÊàê‰∫ÜÊàøÈñìË£°ÊúÄÂø´ÁöÑÈÄöÈóúÊôÇÈñì„ÄÇÂ¶ÇÊûú‰Ω†Â∏åÊúõÊèê‰∫§‰Ω†ÁöÑË®òÈåÑ, ÂèØËº∏ÂÖ• <b>!submit</b>„ÄÇ",
		records_invalid_map = "<v>[#] <r>Áúã‰æÜÈÄôÂºµÂú∞Âúñ‰∏¶‰∏çÂú® parkour ÁöÑÂæ™Áí∞Ë£°... ‰Ω†‰∏çËÉΩÊèê‰∫§ÈÄôÂú∞ÂúñÁöÑË®òÈåÑ!",
		records_not_fastest = "<v>[#] <r>Áúã‰æÜ‰Ω†‰∏¶‰∏çÊòØÊàøÈñìË£°ÊúÄÂø´ÈÄöÈóúÁöÑÁé©ÂÆ∂...",
		records_already_submitted = "<v>[#] <r>‰Ω†Â∑≤Á∂ìÊèê‰∫§‰∫ÜÈÄôÂú∞ÂúñÁöÑÈÄöÈóúÊôÇÈñìË®òÈåÑ!",
		records_submitted = "<v>[#] <d>‰Ω†Âú®Âú∞Âúñ <b>%s</b> ÁöÑÊôÇÈñìË®òÈåÑÂ∑≤Ë¢´Êèê‰∫§„ÄÇ",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Parkour ÈÅ∏È†Ö</font></p>\n\nÂú®ÈáçÁîüÈªû‰ΩøÁî®Á≤íÂ≠êÊïàÊûú\n\n‰ΩøÁî® <b>QWERTY</b> ÈçµÁõ§ (‰ΩøÁî®<b>AZERTY</b>Ë´ãÈóúÈñâÊ≠§È†Ö)\n\n‰ΩøÁî®Âø´Êç∑Èçµ <b>M</b> ‰æÜ <b>Ëá™ÊÆ∫</b> (‰ΩøÁî®<b>DEL</b>Ë´ãÈóúÈñâÊ≠§È†Ö)\n\nÈ°ØÁ§∫‰Ω†ÁöÑËÉΩÂäõÁ∑©Ë°ùÊôÇÈñì\n\nÈ°ØÁ§∫ËÉΩÂäõÈÅ∏È†ÖÊåâÈàï\n\nÈ°ØÁ§∫Âπ´Âä©ÊåâÈàï\n\nÈ°ØÁ§∫ÂÆåÊàêÂú∞ÂúñÁöÑÂÖ¨Âëä\n\nÈ°ØÁ§∫‰∏çÁî®Ë¢´Âπ´Âä©ÁöÑÊ®ôÁ§∫",
		cooldown = "<v>[#] <r>Ë´ãÁ≠âÂÄôÂπæÁßíÂÜçÈáçÊñ∞ÂòóË©¶„ÄÇ",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> ÈçµÁõ§" ..
						 "\n\n<b>Èö±Ëóè</b> Âú∞ÂúñÈÄöÈÅéÊï∏"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>ÂÆåÊàê <v>%s</v> ÂºµÂú∞Âúñ" ..
						"<font size='5'>\n\n</font>‰æÜËß£Èéñ" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>ÂÆåÊàê <v>%s</v> ÂºµÂú∞Âúñ" ..
						"<font size='5'>\n\n</font>‰æÜÂçáÁ¥öÂà∞" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>ÈöéÁ¥ö <v>%s</v>" ..
						"<font size='5'>\n\n</font>‰æÜËß£Èéñ" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>ÈöéÁ¥ö <v>%s</v>" ..
						"<font size='5'>\n\n</font>‰æÜÂçáÁ¥öÂà∞" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>ÂÆåÊàêÂú∞ÂúñÊï∏"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Êï¥È´îÊéíË°åÊ¶ú"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>ÊØèÂë®ÊéíË°åÊ¶ú"),
		badges = "<font size='14' face='Lucida Console,Verdana'>ÂæΩÁ´† (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>Áé©ÂÆ∂ÁöÑÂú∞ÂúñÈÄöÈÅéÊï∏Â∑≤Ë®≠ÂÆöÁÇ∫ÁßÅ‰∫∫„ÄÇ <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Êï¥È´îÊéíË°åÊ¶úÂêçÊ¨°: <b><v>%s</v></b>\n\n" ..
					"ÊØèÂë®ÊéíË°åÊ¶úÂêçÊ¨°: <b><v>%s</v></b>"),
		map_count = "Âú∞ÂúñÈÄöÈÅéÊï∏: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "ÂæΩÁ´†ÊòØÁé©ÂÆ∂ÂèØ‰ª•ÂæóÂà∞ÁöÑÊàêÂ∞±„ÄÇÈªûÊìäÂÆÉÂÄëÊü•Áúã‰ªãÁ¥π„ÄÇ",
		help_private_maps = "ÈÄôÁé©ÂÆ∂‰∏çÊÉ≥ÂÖ¨ÈñãÂàÜ‰∫´‰ªñÁöÑÂú∞ÂúñÈÄöÈÅéÊï∏! ‰Ω†‰πüÂèØ‰ª•Âú®ÂÄã‰∫∫Ë≥áÊñô‰∏≠Ë®≠ÂÆöÈö±Ëóè„ÄÇ",
		help_badge_1 = "ÈÄôÁé©ÂÆ∂ÊõæÁ∂ìÊòØparkour ÁöÑËÅ∑Âì°„ÄÇ",
		help_badge_2 = "ÈÄôÁé©ÂÆ∂ÊòØÊàñÊõæÁ∂ìÈÅîÊàêÂú®Êï¥È´îÊéíË°åÊ¶úÁöÑÁ¨¨ 1 È†Å‰∏ä„ÄÇ",
		help_badge_3 = "ÈÄôÁé©ÂÆ∂ÊòØÊàñÊõæÁ∂ìÈÅîÊàêÂú®Êï¥È´îÊéíË°åÊ¶úÁöÑÁ¨¨ 2 È†Å‰ª•‰∏ä„ÄÇ",
		help_badge_4 = "ÈÄôÁé©ÂÆ∂ÊòØÊàñÊõæÁ∂ìÈÅîÊàêÂú®Êï¥È´îÊéíË°åÊ¶úÁöÑÁ¨¨ 3 È†Å‰ª•‰∏ä„ÄÇ",
		help_badge_5 = "ÈÄôÁé©ÂÆ∂ÊòØÊàñÊõæÁ∂ìÈÅîÊàêÂú®Êï¥È´îÊéíË°åÊ¶úÁöÑÁ¨¨ 4 È†Å‰ª•‰∏ä„ÄÇ",
		help_badge_6 = "ÈÄôÁé©ÂÆ∂ÊòØÊàñÊõæÁ∂ìÈÅîÊàêÂú®Êï¥È´îÊéíË°åÊ¶úÁöÑÁ¨¨ 5 È†Å‰ª•‰∏ä„ÄÇ",
		help_badge_7 = "ÈÄôÁé©ÂÆ∂ÊõæÁ∂ìÂú®ÊØèÂë®ÊéíË°åÊ¶ú‰∏≠ÂæóÂà∞Ââç‰∏âÂêç„ÄÇ",
		help_badge_8 = "ÈÄôÁé©ÂÆ∂ÈÅîÊàê‰∫ÜÂú®‰∏ÄÂ∞èÊôÇÂÖßÈÄöÈÅé 30 ÂºµÂú∞ÂúñÁöÑË®òÈåÑ„ÄÇ",
		help_badge_9 = "ÈÄôÁé©ÂÆ∂ÈÅîÊàê‰∫ÜÂú®‰∏ÄÂ∞èÊôÇÂÖßÈÄöÈÅé 35 ÂºµÂú∞ÂúñÁöÑË®òÈåÑ„ÄÇ",
		help_badge_10 = "ÈÄôÁé©ÂÆ∂ÈÅîÊàê‰∫ÜÂú®‰∏ÄÂ∞èÊôÇÂÖßÈÄöÈÅé 40 ÂºµÂú∞ÂúñÁöÑË®òÈåÑ„ÄÇ",
		help_badge_11 = "ÈÄôÁé©ÂÆ∂ÈÅîÊàê‰∫ÜÂú®‰∏ÄÂ∞èÊôÇÂÖßÈÄöÈÅé 45 ÂºµÂú∞ÂúñÁöÑË®òÈåÑ„ÄÇ",
		help_badge_12 = "ÈÄôÁé©ÂÆ∂ÈÅîÊàê‰∫ÜÂú®‰∏ÄÂ∞èÊôÇÂÖßÈÄöÈÅé 50 ÂºµÂú∞ÂúñÁöÑË®òÈåÑ„ÄÇ",
		help_badge_13 = "ÈÄôÁé©ÂÆ∂ÈÅîÊàê‰∫ÜÂú®‰∏ÄÂ∞èÊôÇÂÖßÈÄöÈÅé 55 ÂºµÂú∞ÂúñÁöÑË®òÈåÑ„ÄÇ",
		help_badge_14 = "ÈÄôÁé©ÂÆ∂Â∑≤Á∂ìÂú®ÂÆòÊñπ parkour discord ‰º∫ÊúçÂô®‰∏äÈ©óË≠â‰∫ÜÂ∏≥Êà∂ (Ëº∏ÂÖ• <b>!discord</b>)„ÄÇ",
		help_badge_15 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 1 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_16 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 5 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_17 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 10 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_18 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 15 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_19 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 20 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_20 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 25 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_21 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 30 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_22 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 35 ÂºµÂú∞Âúñ„ÄÇ",
		help_badge_23 = "ÈÄôÁé©ÂÆ∂‰ª•ÊúÄÂø´ÁöÑÊôÇÈñìÂÆåÊàê‰∫Ü 40 ÂºµÂú∞Âúñ„ÄÇ",
		make_public = "Ë®≠ÂÆöÁÇ∫ÂÖ¨Èñã",
		make_private = "Ë®≠ÂÆöÁÇ∫ÁßÅ‰∫∫",
		moderators = "ÁÆ°ÁêÜÂì°",
		mappers = "Âú∞ÂúñÁÆ°ÁêÜÂì°",
		managers = "Â∞èÈöä‰∏ªÁÆ°",
		administrators = "Â∑•‰Ωú‰∫∫Âì°",
		close = "ÈóúÈñâ",
		cant_load_bot_profile = "<v>[#] <r>‰Ω†‰∏çËÉΩÊü•ÁúãÈÄôÊ©üÂô®‰∫∫ÁöÑÂÄã‰∫∫Ë≥áÊñôÂõ†ÁÇ∫ #parkour Âà©Áî®ÂÆÉ‰æÜÈÄ≤Ë°åÂÖßÈÉ®ÈÅã‰Ωú„ÄÇ",
		cant_load_profile = "<v>[#] <r>Áé©ÂÆ∂ <b>%s</b> Áúã‰æÜ‰∏çÂú®Á∑öÊàñÊòØ‰∏çÂ≠òÂú®„ÄÇ",
		like_map = "‰Ω†ÂñúÊ≠°ÈÄôÂú∞ÂúñÂóé?",
		yes = "ÊòØ",
		no = "‰∏çÊòØ",
		idk = "Êàë‰∏çÁü•ÈÅì",
		unknown = "‰∏çÊòéÁâ©",
		powers = "ËÉΩÂäõ",
		press = "<vp>Êåâ %s",
		click = "<vp>Â∑¶ÈçµÈªûÊìä",
		ranking_pos = "ÊéíÂêç #%s",
		completed_maps = "<p align='center'><BV><B>ÂÆåÊàêÁöÑÂú∞ÂúñÊï∏: %s</B></p></BV>",
		leaderboard = "ÊéíË°åÊ¶ú",
		position = "<V><p align=\"center\">‰ΩçÁΩÆ",
		username = "<V><p align=\"center\">Áî®Êà∂Âêç",
		community = "<V><p align=\"center\">Á§æÂçÄ",
		completed = "<V><p align=\"center\">ÂÆåÊàêÂú∞ÂúñÊï∏",
		overall_lb = "‰∏ªË¶ÅÊéíÂêç",
		weekly_lb = "ÊØèÂë®ÊéíÂêç",
		new_lang = "<v>[#] <d>Ë™ûË®ÄÂ∑≤Ë¢´Êõ¥ÊèõÊàê ÁπÅÈ´î‰∏≠Êñá",

		-- Power names
		balloon = "Ê∞£ÁêÉ",
		masterBalloon = "ÈÄ≤ÈöéÊ∞£ÁêÉ",
		bubble = "Ê≥°Ê≥°",
		fly = "È£õË°å",
		snowball = "Èõ™ÁêÉ",
		speed = "Âä†ÈÄü",
		teleport = "ÂÇ≥ÈÄÅ",
		smallbox = "Â∞èÁÆ±Â≠ê",
		cloud = "ÁôΩÈõ≤",
		rip = "Â¢ìÁ¢ë",
		choco = "Â∑ßÂÖãÂäõÊ£í",
		bigBox = "Â§ßÁÆ±Â≠ê",
		trampoline = "ÂΩàÂ∫ä",
		toilet = "È¶¨Ê°∂",
		pig = "Ë±¨",
		sink = "‰∏ãÊ≤â",
		bathtub = "Êµ¥Áº∏",
		campfire = "ÁáüÁÅ´",
		chair = "Ê§ÖÂ≠ê",
	}
	translations.ch = translations.cn
	--[[ End of file translations/parkour/cn.lua ]]--
	--[[ File translations/parkour/hu.lua ]]--
	translations.hu = {
		name = "hu",
		fullname = "Magyar",

		-- Error messages
		corrupt_map = "<r>S√©r√ºlt p√°lya. Egy m√°sik p√°lya bet√∂lt√©se folyamatban...",
		corrupt_map_vanilla = "<r>[HIBA] <n>Nem tal√°lhat√≥ inform√°ci√≥ a p√°ly√°r√≥l.",
		corrupt_map_mouse_start = "<r>[HIBA] <n>Ennek a p√°ly√°nak rendelkeznie kell egy kezd≈ëponttal (eg√©r spawnpointja).",
		corrupt_map_needing_chair = "<r>[HIBA] <n>A p√°ly√°nak rendelkeznie kell egy fotellel.",
		corrupt_map_missing_checkpoints = "<r>[HIBA] <n>A p√°ly√°nak rendelkeznie kell legal√°bb egy ellen≈ërz≈ë ponttal (s√°rga sz√∂g).",
		corrupt_data = "<r>Sajnos az adataid megs√©r√ºltek, √≠gy √∫jra lettek √°ll√≠tva.",
		min_players = "<r>Az adatok ment√©s√©hez legal√°bb 4 eg√©rnek tart√≥zkodnia kell a szob√°ban. <bl>[%s/%s]",
		tribe_house = "<r>Az adatok nem ker√ºlnek megnt√©sre a t√∂rzsh√°zakban.",
		invalid_syntax = "<r>√ârv√©nytelen szintakszis.",
		code_error = "<r>Hiba jelent meg: <bl>%s-%s-%s %s",
		emergency_mode = "<r>V√©szle√°ll√≠t√°s kezdem√©nyez√©se, √∫j j√°t√©kosok nem enged√©lyezettek. K√©rj√ºk, menj egy m√°sik #parkour szob√°ba.",
		leaderboard_not_loaded = "<r>A ranglista m√©g nem t√∂lt√∂tt be. V√°rj egy percet.",
		max_power_keys = "<v>[#] <r>Legfeljebb %s k√©pess√©get haszn√°lhatsz ugyanazon a billenty≈±gombon.",

		-- Help window
		help = "Seg√≠ts√©g",
		staff = "Szem√©lyzet",
		rules = "Szab√°lyzat",
		contribute = "Hozz√°j√°rul√°s",
		changelog = "H√≠rek",
		help_help = "<p align = 'center'><font size = '14'>√údv√∂zl√ºnk a <T>#parkour</T>-on!</font></p>\n<font size = '11'><p align='center'><J>A c√©lod, hogy el√©rd az √∂sszes ellen≈ërz≈ë pontot, mik√∂zben teljes√≠ted a p√°ly√°t.</J></p>\n\n<N>‚Ä¢ Nyomd meg az <O>O</O> bet≈±t, √≠rd be a <O>!op</O> parancsot vagy kattints a  <O>konfigur√°ci√≥s gombra</O> a <T>be√°ll√≠t√°sok men√ºj√©hez</T> val√≥ megnyit√°shoz.\n‚Ä¢ Nyomd meg a <O>P</O> gombot vagy kattints a <O>k√©z ikonra</O> a jobb fels≈ë sarokban a <T>k√©pess√©gek men√ºj√©hez</T> val√≥ megnyit√°shoz.\n‚Ä¢ Nyomd meg az <O>L</O> gombot vagy √≠rd be a <O>!lb</O> parancsot a <T>ranglista</T> megnyit√°s√°hoz.\n‚Ä¢ Nyomd meg az <O>M</O> gombot vagy a <O>Delete</O> gombot <T>/mort</T> parancshoz, megv√°ltoztathatod a gombokat az <J>Be√°ll√≠t√°sok</J> men√ºben.\n‚Ä¢ Ha szeretn√©l t√∂bbet tudni a <O>szem√©lyzetr≈ël</O> √©s a <O>parkour szab√°lyair√≥l</O>, akkor kattints a <T>Szem√©lyzet</T> √©s <T>Szab√°lyzat</T> f√ºlre.\n‚Ä¢ Kattints <a href='event:discord'><o>ide</o></a> a Discord megh√≠v√≥ link√©rt √©s <a href='event:map_submission'><o>ide</o></a> kattintva megkaphatod a p√°lyabeny√∫jt√°si t√©ma linkj√©t.\n‚Ä¢ Haszn√°ld a <o>fel</o> √©s <o>le</o> nyilakat, amikor g√∂rgetned kell a men√ºben.\n\n<p align = 'center'><font size = '13'><T>A hozz√°j√°rul√°sok m√°r nyitva vannak! Tov√°bbi r√©szletek√©rt kattints a <O>Hozz√°j√°rul√°s</O> f√ºlre!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>FELH√çV√ÅS: A Parkour szem√©lyzet NEM Transformice szem√©lyzet √©s NEM rendelkeznek hatalommal a j√°t√©kban, csak a modulon bel√ºl.</r>\nA Parkour szem√©lyzete gondoskodik arr√≥l, hogy a modul z√∂kken≈ëmentesen m≈±k√∂dj√∂n minim√°lis probl√©m√°kkal. ≈êk mindig rendelkez√©sre √°llnak, hogy sz√ºks√©g eset√©n seg√≠ts√©k a j√°t√©kosokat.</font></p>\n√çrd be a <D>!staff</D> parancsot a chatbe, hogy l√°sd a szem√©lyzet list√°j√°t.\n\n<font color = '#E7342A'>Rendszergazd√°k <i>(admin)</i>:</font> ≈êk felelnek a modul karbantart√°s√°√©rt az √∫j friss√≠t√©sek √©s hib√°k kijav√≠t√°s√°val.\n\n<font color = '#D0A9F0'>Csapatvezet≈ëk <i>(manager)</i>:</font> ≈êk fel√ºgyelik a Moder√°torok √©s P√°lya leg√©nys√©g csapat√°t odafigyelve arra, hogy megfelel≈ëen v√©gezz√©k a munk√°jukat. Tov√°bb√° ≈ëk felel≈ësek az √∫j tagok toborz√°s√°√©rt a szem√©lyzet csapat√°ba.\n\n<font color = '#FFAAAA'>Moder√°torok <i>(mod)</i>:</font> ≈êk felelnek a modul szab√°lyzat√°nak betart√°s√°√©rt √©s a r√°juk nem hallgat√≥ szem√©lyek b√ºntet√©s√©√©rt.\n\n<font color = '#25C059'>P√°lya leg√©nys√©g <i>(mapper)</i>:</font> ≈êk felelnek a p√°ly√°k fel√ºlvizsg√°lat√°√©rt, hozz√°ad√°s√°√©rt √©s elt√°vol√≠t√°s√°√©rt a modulon bel√ºl annak √©rdek√©ben, hogy a j√°t√©kmenet √©lvezetes legyen.",
		help_rules = "<font size = '13'><B><J>A Transformice √Åltal√°nos Szerz≈ëd√©si felt√©teleinek minden szab√°lya vonatkozik a #parkour-ra</J></B></font>\n\nHa olyan j√°t√©kost tal√°lsz, aki megs√©rti a szab√°lyokat, akkor suttog√°sban sz√≥lj a moder√°toroknak. Ha nem √©rhet≈ë el moder√°tor, akkor jelentsd a j√°t√©kost a Discord fel√ºleten.\nJelent√©skor k√©rj√ºk, add meg a szerver-, a szoba- √©s a j√°t√©kos nev√©t.\n‚Ä¢ P√©ld√°ul: hu-#parkour10 Blank#3495 trolling\nA bizony√≠t√©kok, mint p√©ld√°ul k√©perny≈ëfot√≥k, vide√≥k √©s gifek hasznosak √©s √©rt√©kelj√ºk, de nem sz√ºks√©gesek.\n\n<font size = '11'>‚Ä¢ A #parkour szob√°kban nem lehet <font color = '#ef1111'>hacket, glitcheket vagy bugokat</font> haszn√°lni.\n‚Ä¢ A <font color = '#ef1111'>VPN farmol√°st</font> <B>kizs√°km√°nyol√°snak</B> tekintj√ºk, √©s nem enged√©lyezettek. <p align = 'center'><font color = '#cc2222' size = '12'><B>\n\nB√°rkit, akit szab√°lyszeg√©sen kapunk, azonnal kitiltjuk.</B></font></p>\n\n<font size = '12'>A Transformice enged√©lyezi a trollkod√°st, ett≈ël f√ºggetlen√ºl <font color='#cc2222'><B>a parkour-ban nem enged√©lyezz√ºk ezt.</B></font></font>\n\n<p align = 'center'><J>Trollkod√°s akkor k√∂vetkezik, ha egy j√°t√©kos sz√°nd√©kosan arra haszn√°lja a k√©pess√©geit vagy fogy√≥eszk√∂zeit, hogy m√°s j√°t√©kosokat megakad√°lyozzon a p√°lya v√©gig j√°tsz√°s√°ban.</j></p>\n‚Ä¢ Bossz√∫b√≥l trollkodni nem megfelel≈ë indok, √©s m√©g mindig b√ºntetj√ºk.\n‚Ä¢ Trollkod√°snak tekintj√ºk azt is, amikor egy j√°t√©kos a k√©r√©s ellen√©re is megpr√≥b√°lja seg√≠teni azt a j√°t√©kost, aki egyed√ºl akarja v√©gigj√°tszani a p√°ly√°t.\n‚Ä¢ <J>Ha egy j√°t√©kos nem akar seg√≠ts√©get vagy egy p√°ly√°t jobban szeretn√© egyed√ºl v√©gigj√°tszani, k√©rj√ºk, seg√≠ts m√°s j√°t√©kosnak</J>. Ett≈ël f√ºggetlen√ºl, ha egy m√°sik j√°t√©kosnak seg√≠ts√©gre van sz√ºks√©ge ugyan abban az ellen≈ërz≈ë pontban, akkor seg√≠thetsz nekik [mindkett≈ënek].\n\nHa egy j√°t√©kos trollkodik, azonnal b√ºntetve lesz. Vedd figyelembe, hogy az ism√©tl≈ëd≈ë trollkod√°s hosszabb √©s s√∫lyosabb b√ºntet√©sekkel j√°r.",
		help_contribute = "<font size='14'>\n<p align='center'>A parkour menedzsment csapata szereti a ny√≠lt forr√°sk√≥dot, mert ez <t>seg√≠t a k√∂z√∂ss√©gnek</t>. <o>Megtekintheted</o> √©s <o>m√≥dos√≠thatod</o> a ny√≠lt forr√°sk√≥dot a <o><u><a href='event:github'>GitHub</a></u></o√∫>-on.\n\nA modul karbantart√°sa <t>szigor√∫an √∂nk√©ntes</t>, ez√©rt a <t>k√≥d</t> olvas√°s√°val, <t>hibajelent√©sekkel</t>, <t>javaslatokkal</t> √©s <t>p√°lyak√©sz√≠t√©ssel</t> kapcsolatos b√°rmilyen seg√≠ts√©get <u>mindig √∂r√∂mmel fogadunk √©s √©rt√©kelj√ºk</u>.\nTehetsz <vp>hibajelent√©seket</vp> √©s <vp>javaslatokat</vp> a <o><u><a href='event:discord'>Discord</a></u></o>-on √©s/vagy <o><u><a href='event:github'>GitHub</a></u></o>-on.\nA <vp>p√°ly√°dat bek√ºldheted</vp> a mi <o><u><a href='event:map_submission'>F√≥rum t√©m√°nkba</a></u></o>.\n\nA parkour fenntart√°sa nem dr√°ga, de nem is ingyenes. Szeretn√©nk, ha <t>b√°rmekkora √∂sszeggel</t> t√°mogatn√°l minket <o><u><a href='event:donate'>ide</a></u></o> kattintva.\n<u>Minden t√°mogat√°s a modul fejleszt√©s√©re ir√°nyul.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Wersja 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ Zaimplementowano <cep>rekordowy system</cep>! Sprawd≈∫ to pod adresem <vp><u>*#parkour0records TwojaNazwa#Hasztag</u></vp>\n‚Ä¢ Poprawiona rotacja mapy.\n‚Ä¢ Poprawiona <o><u><a href='event:discord'>Discord</a></u></o> weryfikacja.",

		-- Congratulation messages
		reached_level = "<d>Gratul√°lunk! El√©rted a(z) <vp>%s</vp>. ellen≈ërz≈ë pontot.",
		finished = "<d><o>%s</o> befejezte a parkour p√°ly√°t <vp>%s</vp> m√°sodperc alatt. <fc>Gratul√°lunk!",
		unlocked_power = "<ce><d>%s</d> feloldotta a(z) <vp>%s</vp> k√©pess√©get.",

		-- Information messages
		staff_power = "<r>A parkour szem√©lyzet√©nek <b>nincs</b> hatalma a #parkour p√°ly√°kon k√≠v√ºl.",
		donate = "<vp>√çrd be a <b>!donate</b> parancsot, ha adom√°nyozni szeretn√©l a modul r√©sz√©re!",
		paused_events = "<cep><b>[Figyelem!]</b> <n>A modul el√©rte a kritikus hat√°r√°t, √≠gy sz√ºneteltet√©s alatt √°ll.",
		resumed_events = "<n2>A modul folytat√≥dik.",
		welcome = "<n>√údv√∂zl√ºnk a <t>#parkour</t>-on!",
		module_update = "<r><b>[Figyelem!]</b> <n>A modul friss√ºl <d>%02d:%02d</d> percen bel√ºl.",
		leaderboard_loaded = "<j>A ranglista be lett t√∂ltve. Nyomd meg az <b>L</b> gombot a megnyit√°s√°hoz.",
		kill_minutes = "<R>A k√©pess√©geidet %s percre letiltottuk.",
		permbanned = "<r>V√©glegesen ki lett√©l tiltva a #parkour-b√≥l.",
		tempbanned = "<r>Ki lett√©l tiltva %s m√°sodpercre a #parkour-b√≥l.",

		-- Records
		records_enabled = "<v>[#] <d>Rekord m√≥d lett aktiv√°lva ebben a szob√°ban. Az adatok nem sz√°m√≠tanak √©s a k√©pess√©gek nem enged√©lyezettek!\nT√∂bb inform√°ci√≥t tal√°lhatsz a Rekordr√≥l itt: <b>%s</b>",
		records_admin = "<v>[#] <d>Egy adminisztr√°tor vagy ebben a Rekord szob√°ban. Haszn√°lhatod a <b>!map</b>, <b>!pw</b> √©s <b>!time</b> parancsokat.",
		records_completed = "<v>[#] <d>Teljes√≠tetted a p√°ly√°t! Ha √∫jra akarod csin√°lni, √≠rd be: <b>!redo</b>.",
		records_submit = "<v>[#] <d>H≈±ha! √ögy t≈±nik, te volt√°l a leggyorsabb a szob√°ban. Ha be szeretn√©d k√ºldeni a rekordod, √≠rd be: <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>√ögy t≈±nik, hogy ez a p√°lya nincs a Parkour k√∂rforg√°s√°ban... Nem tudod beny√∫jtani a rekordod!",
		records_not_fastest = "<v>[#] <r>√ögy t≈±nik, nem te vagy a leggyorsabb j√°t√©kos a szob√°ban...",
		records_already_submitted = "<v>[#] <r>M√°r bek√ºldted a rekordod ehhez a p√°ly√°hoz!",
		records_submitted = "<v>[#] <d>A <b>%s</b> rekordod ehhez a p√°ly√°hoz be lett k√ºldve.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Parkour Be√°ll√≠t√°sok</font></p>\n\nHaszn√°lj effekteket az ellen≈ërz≈ë pontok megjelen√≠t√©s√©hez\n\nHaszn√°ld a <b>QWERTY</b> billenty≈±zetet (tiltsd le, ha <b>AZERTY</b>-d van)\n\nHaszn√°ld az <b>M</b> gombot a <b>/mort</b> parancshoz (tiltsd le, ha <b>DEL</b> legyen)\n\nMutassa a k√©pess√©gek √∫jrat√∂lt√©si idej√©t\n\nMutassa a <b>k√©pess√©gek</b> gombot\n\nMutassa a <b>seg√≠ts√©g</b> gombot\n\nMutassa a teljes√≠tett p√°ly√°k mennyis√©g√©t\n\nJelen√≠tse meg a <b>nincs seg√≠ts√©g</b> szimb√≥lumot",
		cooldown = "<v>[#] <r>V√°rj n√©h√°ny m√°sodpercet, miel≈ëtt √∫jra ezt tenn√©d.",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> billenty≈±zet" ..
						 "\n\nTeljes√≠tett p√°ly√°k <b>elrejt√©se</b>"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Teljes√≠ts <v>%s</v> p√°ly√°t" ..
						"<font size='5'>\n\n</font>a(z) <v>%s</v>" ..
						"<font size='5'>\n\n</font>felold√°s√°hoz"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Teljes√≠ts <v>%s</v> p√°ly√°t" ..
						"<font size='5'>\n\n</font>a(z) <v>%s</v>" ..
						"<font size='5'>\n\n</font>friss√≠t√©s√©hez"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>√ârd el a(z) <v>%s</v>" ..
						"<font size='5'>\n\n</font>rangot a(z) <v>%s</v>" ..
						"<font size='5'>\n\n</font>felold√°s√°hoz"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>√ârd el a(z) <v>%s</v>" ..
						"<font size='5'>\n\n</font>rangot a(z) <v>%s</v>" ..
						"<font size='5'>\n\n</font>friss√≠t√©s√©hez"),
		maps_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Teljes√≠tett p√°lya"),
		overall_info = ("<p align='center'><font size='11' face='Lucida Console'>Poz√≠ci√≥ a Teljes ranglist√°n:" ..
						"<font size='5'>\n\n</font><b><v>%s</v></b>"),
		weekly_info = ("<p align='center'><font size='11' face='Lucida Console'>Poz√≠ci√≥ a Heti ranglist√°n:" ..
					   "<font size='5'>\n\n</font><b><v>%s</v></b>"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Kit≈±z≈ëk (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>A j√°t√©kos teljes√≠tett p√°ly√°inak sz√°ma priv√°t. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Poz√≠ci√≥ a Teljes ranglist√°n: <b><v>%s</v></b>\n\n" ..
					"Poz√≠ci√≥ a Heti ranglist√°n: <b><v>%s</v></b>"),
		map_count = "P√°ly√°k sz√°ma: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "A Kit≈±z≈ëk olyan eredm√©nyek, melyeket a j√°t√©kosok szerezhetnek. Kattints r√°juk, hogy l√°sd a le√≠r√°sukat.",
		help_private_maps = "A j√°t√©kos nem szeretn√© nyilv√°nosan megosztani a Teljes√≠tett p√°ly√°inak a sz√°m√°t! Te is elrejtheted a profilodon.",
		help_badge_1 = "Ez a j√°t√©kos kor√°bban a parkour szem√©lyzet√©nek tagjai k√∂z√∂tt volt.",
		help_badge_2 = "Ez a j√°t√©kos Teljes ranglist√°n az 1. oldalon van/volt.",
		help_badge_3 = "Ez a j√°t√©kos Teljes ranglist√°n az 2. oldalon van/volt.",
		help_badge_4 = "Ez a j√°t√©kos Teljes ranglist√°n az 3. oldalon van/volt.",
		help_badge_5 = "Ez a j√°t√©kos Teljes ranglist√°n az 4. oldalon van/volt.",
		help_badge_6 = "Ez a j√°t√©kos Teljes ranglist√°n az 6. oldalon van/volt.",
		help_badge_7 = "Ez a j√°t√©kos a Heti ranglist√°n a dobog√≥n volt.",
		help_badge_8 = "Ennek a j√°t√©kosnak a rekordja 30 p√°lya/√≥ra.",
		help_badge_9 = "Ennek a j√°t√©kosnak a rekordja 35 p√°lya/√≥ra.",
		help_badge_10 = "Ennek a j√°t√©kosnak a rekordja 40 p√°lya/√≥ra.",
		help_badge_11 = "Ennek a j√°t√©kosnak a rekordja 45 p√°lya/√≥ra.",
		help_badge_12 = "Ennek a j√°t√©kosnak a rekordja 50 p√°lya/√≥ra.",
		help_badge_13 = "Ennek a j√°t√©kosnak a rekordja 55 p√°lya/√≥ra.",
		help_badge_14 = "Ez a j√°t√©kos hiteles√≠tette a discord fi√≥kj√°t a Parkour hivatalos Discord szerver√©n (√≠rd be <b>!discord</b>).",
		help_badge_15 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 1 alkalommal.",
		help_badge_16 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 5 alkalommal.",
		help_badge_17 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 10 alkalommal.",
		help_badge_18 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 15 alkalommal.",
		help_badge_19 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 20 alkalommal.",
		help_badge_20 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 25 alkalommal.",
		help_badge_21 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 30 alkalommal.",
		help_badge_22 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 35 alkalommal.",
		help_badge_23 = "Ez a j√°t√©kos volt a leggyorsabb a p√°ly√°n 40 alkalommal.",
		make_public = "nyilv√°nos",
		make_private = "priv√°t",
		moderators = "Moder√°torok",
		mappers = "P√°lya leg√©nys√©g",
		managers = "Csapatvezet≈ëk",
		administrators = "Rendszergazd√°k",
		close = "Bez√°r",
		cant_load_bot_profile = "<v>[#] <r>Nem l√°thatod ennek a BOT-nak a profilj√°t, mivel val√≥sz√≠n≈±leg a #parkour a bels≈ë m≈±k√∂d√©sekhez haszn√°lja.",
		cant_load_profile = "<v>[#] <r><b>%s</b> felhaszn√°l√≥ kijelentkezett √°llapotban van vagy nem l√©tezik.",
		like_map = "Tetszik ez a p√°lya?",
		yes = "Igen",
		no = "Nem",
		idk = "Nem tudom",
		unknown = "Ismeretlen",
		powers = "K√©pess√©gek",
		press = "<vp>Nyomd meg: %s",
		click = "<vp>Bal klikk",
		ranking_pos = "Rang #%s",
		completed_maps = "<p align='center'><BV><B>Teljes√≠tett p√°ly√°k: %s</B></p></BV>",
		leaderboard = "Ranglista",
		position = "<V><p align=\"center\">Poz√≠ci√≥",
		username = "<V><p align=\"center\">Felhaszn√°l√≥n√©v",
		community = "<V><p align=\"center\">K√∂z√∂ss√©g",
		completed = "<V><p align=\"center\">Teljes√≠tett p√°ly√°k",
		overall_lb = "Teljes",
		weekly_lb = "Heti",
		new_lang = "<v>[#] <d>A j√°t√©k nyelv√©t Magyarra v√°ltoztattad",

		-- Power names
		balloon = "L√©gg√∂mb",
		masterBalloon = "Mester L√©gg√∂mb",
		bubble = "Bubor√©k",
		fly = "Rep√ºl√©s",
		snowball = "H√≥goly√≥",
		speed = "Gyors√≠t√°s",
		teleport = "Teleport",
		smallbox = "Kis doboz",
		cloud = "Felh≈ë",
		rip = "S√≠rk≈ë",
		choco = "Csokol√°d√© deszka",
		bigBox = "Nagy doboz",
		trampoline = "Trambulin",
		toilet = "Toalet",
		pig = "Malac",
		sink = "Mosd√≥kagyl√≥",
		bathtub = "F√ºrd≈ëk√°d",
		campfire = "T√°bort≈±z",
		chair = "Sz√©k",
	}
	--[[ End of file translations/parkour/hu.lua ]]--
	--[[ File translations/parkour/ro.lua ]]--
	translations.ro = {
		name = "ro",
		fullname = "Rom√¢nƒÉ",

		-- Error messages
		corrupt_map = "<r>HartƒÉ coruptƒÉ. Se √ÆncarcƒÉ alta.",
		corrupt_map_vanilla = "<r>[EROARE] <n>Nu pot primi informa»õiile acestei hƒÉr»õi.",
		corrupt_map_mouse_start = "<r>[EROARE] <n>AceastƒÉ hartƒÉ are nevoie de o pozi»õie de start (punct de start pentru »ôoareci).",
		corrupt_map_needing_chair = "<r>[EROARE] <n>AceastƒÉ hartƒÉ are nevoie de un fotoliu de final.",
		corrupt_map_missing_checkpoints = "<r>[EROARE] <n>Harta are nevoie de mƒÉcar un checkpoint (cui galben).",
		corrupt_data = "<r>Din pƒÉcate, progresul tƒÉu era corupt »ôi a fost resetat.",
		min_players = "<r>Pentru a-»õi salva progresul, trebuie sƒÉ fie mƒÉcar 4 jucƒÉtori unici pe salƒÉ. <bl>[%s/%s]",
		tribe_house = "<r>Progresul nu va fi salvat √Æn casele de trib.",
		invalid_syntax = "<r>SintaxƒÉ invalidƒÉ.",
		code_error = "<r>O eroare a apƒÉrut: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Ini»õi√¢nd √Ænchidere de urgen»õƒÉ, niciun jucƒÉtor nou nu este permis. Te rugƒÉm sƒÉ te duci pe altƒÉ salƒÉ de #parkour.",
		leaderboard_not_loaded = "<r>Clasamentul nu a fost √ÆncƒÉ √ÆncƒÉrcat. A»ôteaptƒÉ un minut.",
		max_power_keys = "<v>[#] <r>Po»õi avea maximum %s puteri pe aceea»ôi tastƒÉ.",

		-- Help window
		help = "Ajutor",
		staff = "Personal",
		rules = "Reguli",
		contribute = "Contribuie",
		changelog = "NoutƒÉ»õi",
		help_help = "<p align = 'center'><font size = '14'>Bine ai venit pe <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Scopul tƒÉu este sƒÉ ajungi la toate checkpoint-urile p√¢nƒÉ completezi harta.</J></p>\n\n<N>‚Ä¢ ApasƒÉ <O>O</O>, scrie <O>!op</O> sau dƒÉ click pe <O>butonul de configura»õie</O> pentru a deschide <T>meniul de op»õiuni</T>.\n‚Ä¢ ApasƒÉ <O>P</O> sau dƒÉ click pe <O>iconi»õa m√¢nƒÉ</O> din col»õul din dreapta-sus pentru a deschide <T>meniul de puteri</T>.\n‚Ä¢ ApasƒÉ <O>L</O> sau scrie <O>!lb</O> pentru a deschide <T>clasamentul</T>.\n‚Ä¢ ApasƒÉ pe <O>M</O> sau <O>Delete</O> pentru a folosi <T>/mort</T>, po»õi schimba tastele √Æn meniul de  <J>Op»õiuni</J>.\n‚Ä¢ Pentru a afla mai multe despre <O>personalul nostru</O> sau despre <O>regulile parkourului</O>, dƒÉ click pe tab-urile <T>Personal</T> »ôi respectiv <T>Reguli</T>.\n‚Ä¢ DƒÉ click <a href='event:discord'><o>aici</o></a> pentru a primi link-ul de invita»õie pentru serverul de discord »ôi <a href='event:map_submission'><o>aici</o></a> pentru a putea trimite propriile hƒÉr»õi.\n‚Ä¢ Folose»ôte sƒÉge»õile <o>sus</o> »ôi <o>jos</o> c√¢nd vrei sƒÉ navighezi.\n\n<p align = 'center'><font size = '13'><T>Contribu»õiile sunt acum deschide! Pentru mai multe detalii, dƒÉ click pe tab-ul <O>Contribuie</O> tab!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>DISCLAIMER: Personalul parkour NU FAC PARTE din personalul Transformice »ôi NU au nicio putere √Æn joc ci doar √Æn acest modul.</r>\nPersonalul parkour se asigurƒÉ cƒÉ modulul ruleazƒÉ bine cu probleme minime, »ôi sunt mereu disponibili sƒÉ ajute jucƒÉtorii c√¢nd este nevoie.</font></p>\nPo»õi scrie <D>!staff</D> √Æn chat pentru a vedea personalul.\n\n<font color = '#E7342A'>Administratorii:</font> Ei sunt responsabili cu √Æntre»õinerea modulului, adƒÉug√¢nd actualizƒÉri noi »ôi rezolv√¢nd probleme.\n\n<font color = '#D0A9F0'>Managerii de echipƒÉ:</font> Ei au grijƒÉ ca Moderatorii »ôi Mapperii √Æ»ôi fac treaba cum trebuie.  Ei sunt de asemenea responsabili cu aducerea de personal nou √Æn echipƒÉ.\n\n<font color = '#FFAAAA'>Moderatorii:</font> Ei sunt responsabili cu aplicarea regulilor modulului »ôi pedepsirea celor care nu le respectƒÉ.\n\n<font color = '#25C059'>Mapperii:</font>Ei sunt responsabili cu verificarea, adƒÉugarea, »ôi eliminarea hƒÉr»õilor din modul pentru a-»õi asigura un experien»õƒÉ plƒÉcutƒÉ de joc.",
		help_rules = "<font size = '13'><B><J>Toate regulile din Termenii »ôi Condi»õiile Transformice se aplicƒÉ »ôi la #parkour</J></B></font>\n\nDacƒÉ observi vreun player care √ÆncalcƒÉ aceste reguli, dƒÉ-le »ôoaptƒÉ moderatorilor din joc. DacƒÉ nu este niciun moderator online, e recomandat sƒÉ-l raportezi √Æn server-ul de Discord.\nCand raportezi, te rugƒÉm sƒÉ incluzi server-ul, numele camerei »ôi numele jucƒÉtorului.\n‚Ä¢ Ex: ro-#parkour10 Blank#3495 trolleazƒÉ\nEviden»õa precum capturile de ecran, videourile »ôi gif-urile sunt folositoare »ôi apreciate, dar nu sunt necesare.\n\n<font size = '11'>‚Ä¢ Niciun <font color = '#ef1111'>hack, bug sau eroare</font> nu este acceptatƒÉ √Æn sƒÉlile #parkour\n‚Ä¢ <font color = '#ef1111'>VPN farming</font> va fi considerat un<B>abuz</B> »ôi nu este admis. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nOricine va fi prins cƒÉ √ÆncalcƒÉ aceste reguli va fi banat imediat.</B></font></p>\n\n<font size = '12'>Transformice acceptƒÉ conceptul de trolling. Cu toate acestea, <font color='#cc2222'><B>noi nu vom accepta acest lucru √Æn parkour</B></font></font>\n\n<p align = 'center'><J>Troll-ul este atunci c√¢nd un jucƒÉtor opre»ôte √Æn mod inten»õionat ceilal»õi jucƒÉtori din a termina hart folosindu-»ôi puterile sau consumabilele.</j></p>\n‚Ä¢ Trolling-ul ca revan»ôƒÉ <B>nu este un motiv valid</B>de a trolla pe cineva »ôi nu te scute»ôte de pedeapsƒÉ.\n‚Ä¢ Ajutatul cu for»õa al celorlal»õi jucƒÉtori care vor sƒÉ termine harta singuri, fƒÉrƒÉ a te opri c√¢nd »õi se cere, este considerat trolling.\n‚Ä¢ <J>DacƒÉ un jucƒÉtor nu vrea ajutor »ôi preferƒÉ sƒÉ facƒÉ harta de unul singur, te rugƒÉm sƒÉ √Æncerci sƒÉ aju»õi al»õi jucƒÉtori.</J>. Cu toate acestea, dacƒÉ un alt jucƒÉtor are nevoie de ajutor la acela»ôi checkpoint ca jucƒÉtorul care vrea sƒÉ joace singur,  √Æi po»õi ajuta [pe am√¢ndoi].\n\nDacƒÉ un jucƒÉtor este prins cƒÉ a fƒÉcut troll, va fi sanc»õionat pe bazƒÉ de timp.",
		help_contribute = "<font size='14'>\n<p align='center'>Echipa parkour adorƒÉ codul open source deoarece <t>ajutƒÉ comunitatea</t>. Po»õi <o>vedea</o> »ôi <o>modifica</o> codul sursƒÉ pe <o><u><a href='event:github'>GitHub</a></u></o>.\n\n√éntre»õinerea modulului este <t>strict voluntarƒÉ</t>, a»ôa cƒÉ orice ajutor √Æn legƒÉturƒÉ cu <t>codul</t>, <t>probleme ale jocului</t>, <t>sugestii</t> »ôi <t>crearea de hƒÉr»õi</t> este mereu <u>primitƒÉ »ôi apreciatƒÉ</u>.\nPo»õi <vp>raporta probleme</vp> »ôi <vp>da sugestii</vp> pe <o><u><a href='event:discord'>Discord</a></u></o> »ôi/sau <o><u><a href='event:github'>GitHub</a></u></o>.\nPo»õi sƒÉ <vp>trimi»õi hƒÉr»õile</vp> √Æn discu»õia <o><u><a href='event:map_submission'>de pe forum</a></u></o>.\n\n√éntre»õinerea parkourului nu este scumpƒÉ, dar nici gratis. Am aprecia dacƒÉ ne-ai ajuta <t>don√¢nd orice sumƒÉ</t> <o><u><a href='event:donate'>aici</a></u></o>.\n<u>Toate dona»õiile vor duce la √ÆmbunƒÉtƒÉ»õirea modulului.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Versiunea 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ A fost introdus <cep>sistem de recorduri</cep>! √éncearcƒÉ pe <vp><u>*#parkour0records YourName#Tag</u></vp>\n‚Ä¢ Rota»õia hƒÉr»õilor a fost √ÆmbunƒÉtƒÉ»õitƒÉ.\n‚Ä¢ Verificarea a fost eficientizatƒÉ pe <o><u><a href='event:discord'>Discord</a></u></o>.",

		-- Congratulation messages
		reached_level = "<d>FelicitƒÉri! Ai atins nivelul <vp>%s</vp>.",
		finished = "<d><o>%s</o> a terminat parkour √Æn <vp>%s</vp> secunde, <fc>felicitƒÉri!",
		unlocked_power = "<ce><d>%s</d> a deblocat puterea <vp>%s</vp>.",

		-- Information messages
		staff_power = "<r>Personalul parkour <b>nu are</b> nicio putere √Æn afara sƒÉlilor de #parkour.",
		donate = "<vp>Scrie <b>!donate</b> dacƒÉ dore»ôti sƒÉ donezi pentru acest modul!",
		paused_events = "<cep><b>[Aten»õie!]</b> <n>Modulul a atins limita critcƒÉ »ôi este pauzat.",
		resumed_events = "<n2>Modulul a fost eliberat.",
		welcome = "<n>Bine ai venit pe <t>#parkour</t>!",
		module_update = "<r><b>[Aten»õie!]</b> <n>Modulul se va actualiza √Æn <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>Clasamentul a fost √ÆncƒÉrcat. ApasƒÉ L pentru a-l deschide.",
		kill_minutes = "<R>Puterile tale au fost oprite pentru %s minute.",
		permbanned = "<r>Ai fost banat permanent de la #parkour.",
		tempbanned = "<r>Ai fost banat de la #parkour pentru %s minute.",

		-- Records
		records_enabled = "<v>[#] <d>Modul de record a fost pornit pe aceastƒÉ salƒÉ. Statisticile nu vor conta iar puterile sunt dezactivate!\nPo»õi afla mai multe pe <b>%s</b>",
		records_admin = "<v>[#] <d>E»ôti un administrator pe aceastƒÉ salƒÉ de recorduri. Po»õi folosi comenzile <b>!map</b>, <b>!pw</b> »ôi <b>!time</b>.",
		records_completed = "<v>[#] <d>Ai completat harta! DacƒÉ vrei sƒÉ √Æncerci din nou, scrie <b>!redo</b>.",
		records_submit = "<v>[#] <d>Wow! Se pare cƒÉ ai avut cel mai scurt timp de pe salƒÉ. DacƒÉ vrei sƒÉ √Æ»õi trimi»õi recordul, scrie <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>Se pare cƒÉ aceastƒÉ hartƒÉ nu este √Æn rota»õia parkour... Nu po»õi trimite un record pentru ea!",
		records_not_fastest = "<v>[#] <r>Se pare cƒÉ nu e»ôti cel mai rapid jucƒÉtor de pe salƒÉ...",
		records_already_submitted = "<v>[#] <r>Deja ai trimis un record pentru aceastƒÉ hartƒÉ!",
		records_submitted = "<v>[#] <d>Recordul tƒÉu pentru harta <b>%s</b> a fost trimis.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Op»õiuni Parkour</font></p>\n\nFolose»ôte particule pentru parkour\n\nFolose»ôte <b>QWERTY</b> (opre»ôte dacƒÉ <b>AZERTY</b>)\n\nFolose»ôte scurtƒÉtura <b>M</b> pentru <b>/mort</b> (opre»ôte pentru <b>DEL</b>)\n\nAratƒÉ-»õi cooldown-urile pentru puteri\n\nAratƒÉ butonul de puteri\n\nAratƒÉ butonul de ajutor\n\nAratƒÉ anun»õurile de completare a hƒÉr»õilor\n\nAratƒÉ simbolul de ‚ÄûfƒÉrƒÉ ajutor‚Äù",
		cooldown = "<v>[#] <r>A»ôteaptƒÉ c√¢teva secunde pentru a face asta din nou.",
		power_options = ("<font size='13' face='Lucida Console'>tastaturƒÉ <b>QWERTY</b>" ..
						 "\n\n<b>Ascunde</b> numƒÉrul hƒÉr»õilor completate"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>CompleteazƒÉ <v>%s</v> hƒÉr»õi" ..
						"<font size='5'>\n\n</font>pentru a debloca" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>CompleteazƒÉ <v>%s</v> hƒÉr»õi" ..
						"<font size='5'>\n\n</font>pentru a √ÆmbunƒÉtƒÉ»õi" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Fii pe locul <v>%s</v>" ..
						"<font size='5'>\n\n</font>pentru a debloca" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Fii pe locul <v>%s</v>" ..
						"<font size='5'>\n\n</font>pentru a √ÆmbunƒÉtƒÉ»õi" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>HƒÉr»õi completate"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Clasamentul general"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>Clasamentul sƒÉptƒÉm√¢nal"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Insigne (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>HƒÉr»õile acestui jucƒÉtor sunt private. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Pozi»õia √Æn clasamentul general: <b><v>%s</v></b>\n\n" ..
					"Pozi»õia √Æn clasamentul sƒÉptƒÉm√¢nal<b><v>%s</v></b>"),
		map_count = "HƒÉr»õi completate: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Insignele sunt realizƒÉri pe care jucƒÉtorii le pot debloca. ApasƒÉ pe ele pentru a afla mai multe.",
		help_private_maps = "Acest jucƒÉtor nu vrea sƒÉ-»ôi arate numƒÉrul hƒÉr»õilor! Le po»õi ascunde »ôi tu pe profil.",
		help_badge_1 = "Acest jucƒÉtor a fost parte din personalul parkour.",
		help_badge_2 = "Acest jucƒÉtor este sau a fost √Æn prima paginƒÉ a clasamentului general.",
		help_badge_3 = "Acest jucƒÉtor este sau a fost √Æn a doua paginƒÉ a clasamentului general.",
		help_badge_4 = "Acest jucƒÉtor este sau a fost √Æn a treia paginƒÉ a clasamentului general.",
		help_badge_5 = "Acest jucƒÉtor este sau a fost √Æn a patra paginƒÉ a clasamentului general.",
		help_badge_6 = "Acest jucƒÉtor este sau a fost √Æn a cincea paginƒÉ a clasamentului general.",
		help_badge_7 = "Acest jucƒÉtor a fost pe podium la finalul clasamentului sƒÉptƒÉm√¢nal.",
		help_badge_8 = "Acest jucƒÉtor a reu»ôit sƒÉ termine 30 de hƒÉr»õi √Æntr-o orƒÉ.",
		help_badge_9 = "Acest jucƒÉtor a reu»ôit sƒÉ termine 35 de hƒÉr»õi √Æntr-o orƒÉ.",
		help_badge_10 = "Acest jucƒÉtor a reu»ôit sƒÉ termine 40 de hƒÉr»õi √Æntr-o orƒÉ.",
		help_badge_11 = "Acest jucƒÉtor a reu»ôit sƒÉ termine 45 de hƒÉr»õi √Æntr-o orƒÉ.",
		help_badge_12 = "Acest jucƒÉtor a reu»ôit sƒÉ termine 50 de hƒÉr»õi √Æntr-o orƒÉ.",
		help_badge_13 = "Acest jucƒÉtor a reu»ôit sƒÉ termine 55 de hƒÉr»õi √Æntr-o orƒÉ.",
		help_badge_14 = "Acest jucƒÉtor »ôi-a verificat contul de discord pe serverul oficial parkour (scrie <b>!discord</b>).",
		help_badge_15 = "Acest jucƒÉtor are record pe o hartƒÉ.",
		help_badge_16 = "Acest jucƒÉtor are record pe 5 hƒÉr»õi.",
		help_badge_17 = "Acest jucƒÉtor are record pe 10 hƒÉr»õi.",
		help_badge_18 = "Acest jucƒÉtor are record pe 15 hƒÉr»õi.",
		help_badge_19 = "Acest jucƒÉtor are record pe 20 hƒÉr»õi.",
		help_badge_20 = "Acest jucƒÉtor are record pe 25 hƒÉr»õi.",
		help_badge_21 = "Acest jucƒÉtor are record pe 30 hƒÉr»õi.",
		help_badge_22 = "Acest jucƒÉtor are record pe 35 hƒÉr»õi.",
		help_badge_23 = "Acest jucƒÉtor are record pe 40 hƒÉr»õi.",
		make_public = "fƒÉ public",
		make_private = "fƒÉ privat",
		moderators = "Moderatori",
		mappers = "Mappers",
		managers = "Manageri",
		administrators = "Administratori",
		close = "√énchide",
		cant_load_bot_profile = "<v>[#] <r>Nu po»õi vedea profilul acestui bot √Æntruc√¢t #parkour √Æl folose»ôte intern pentru a func»õiona cum trebuie.",
		cant_load_profile = "<v>[#] <r>JucƒÉtorul <b>%s</b> pare sƒÉ fie offline sau nu existƒÉ.",
		like_map = "√é»õi place aceastƒÉ hartƒÉ?",
		yes = "Da",
		no = "Nu",
		idk = "Nu »ôtiu bro, nu-s de aici",
		unknown = "Necunoscut",
		powers = "Puteri",
		press = "<vp>ApasƒÉ %s",
		click = "<vp>Click st√¢nga",
		ranking_pos = "Rang #%s",
		completed_maps = "<p align='center'><BV><B>HƒÉr»õi completate: %s</B></p></BV>",
		leaderboard = "Clasament",
		position = "<V><p align=\"center\">Pozi»õie",
		username = "<V><p align=\"center\">Nume",
		community = "<V><p align=\"center\">Comunitate",
		completed = "<V><p align=\"center\">HƒÉr»õi completate",
		overall_lb = "√én general",
		weekly_lb = "SƒÉptƒÉm√¢nal",
		new_lang = "<v>[#] <d>LimbƒÉ a fost setatƒÉ √Æn Rom√¢nƒÉ",

		-- Power names
		balloon = "Balon",
		masterBalloon = "Balon Maestru",
		bubble = "Balona»ô",
		fly = "ZboarƒÉ",
		snowball = "BulgƒÉre",
		speed = "VitezƒÉ",
		teleport = "Teleportare",
		smallbox = "Cutie micƒÉ",
		cloud = "Nor",
		rip = "Sicriu",
		choco = "Ciocosc√¢ndurƒÉ",
		bigBox = "Cutie mare",
		trampoline = "TrambulinƒÉ",
		toilet = "ToaletƒÉ",
		pig = "Porc",
		sink = "ChiuvetƒÉ",
		bathtub = "CadƒÉ",
		campfire = "Foc de tabƒÉrƒÉ",
		chair = "Scaun",
	}
	--[[ End of file translations/parkour/ro.lua ]]--
	--[[ File translations/parkour/es.lua ]]--
	translations.es = {
		name = "es",
		fullname = "Espa√±ol",

		-- Error messages
		corrupt_map = "<r>Mapa corrupto. Cargando otro.",
		corrupt_map_vanilla = "<r>[ERROR] <n>No se pudo obtener informaci√≥n de este mapa.",
		corrupt_map_mouse_start = "<r>[ERROR] <n>El mapa tiene que tener un punto de inicio de los ratones.",
		corrupt_map_needing_chair = "<r>[ERROR] <n>El mapa tiene que tener el sill√≥n del final.",
		corrupt_map_missing_checkpoints = "<r>[ERROR] <n>El mapa tiene que tener al menos un checkpoint (anclaje amarillo).",
		corrupt_data = "<r>Tristemente, tus datos estaban corruptos. Se han reiniciado.",
		min_players = "<r>Para guardar datos, deben haber al menos 4 jugadores √∫nicos en la sala. <bl>[%s/%s]",
		tribe_house = "<r>Para guardar datos, debes jugar fuera de una casa de tribu.",
		invalid_syntax = "<r>Sintaxis inv√°lida.",
		code_error = "<r>Apareci√≥ un error: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Empezando apagado de emergencia, no se admiten m√°s jugadores. Por favor ve a otra sala #parkour.",
		leaderboard_not_loaded = "<r>La tabla de clasificaci√≥n aun no ha sido cargada. Espera un minuto.",
		max_power_keys = "<v>[#] <r>Solo puedes tener como m√°ximo %s poderes en la misma tecla.",

		-- Help window
		help = "Ayuda",
		staff = "Staff",
		rules = "Reglas",
		contribute = "Contribuir",
		changelog = "Novedades",
		help_help = "<p align = 'center'><font size = '14'>¬°Bienvenido a <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Tu objetivo es alcanzar todos los puntos de control hasta que completes el mapa.</J></p>\n\n<N>‚Ä¢ Presiona la tecla <O>O</O>, escribe <O>!op</O> o clickea el <O>bot√≥n de configuraci√≥n</O> para abrir el <T>men√∫ de opciones</T>.\n‚Ä¢ Presiona la tecla <O>P</O> o clickea el <O>√≠cono de la mano</O> arriba a la derecha para abrir el <T>men√∫ de poderes</T>.\n‚Ä¢ Presiona la tecla <O>L</O> o escribe <O>!lb</O> para abrir el <T>ranking</T>.\n‚Ä¢ Presiona la tecla <O>M</O> o <O>Delete</O> como atajo para <T>/mort</T>, podes alternarlas en el men√∫ de <J>Opciones</J>.\n‚Ä¢ Para conocer m√°s acerca de nuestro <O>staff</O> y las <O>reglas de parkour</O>, clickea en las pesta√±as de <T>Staff</T> y <T>Reglas</T>.\n‚Ä¢ Click <a href='event:discord'><o>here</o></a> to get the discord invite link and <a href='event:map_submission'><o>here</o></a> to get the map submission topic link.\n‚Ä¢ Use <o>up</o> and <o>down</o> arrow keys when you need to scroll.\n\n<p align = 'center'><font size = '13'><T>¬°Las contribuciones est√°n abiertas! Para m√°s detalles, ¬°clickea en la pesta√±a <O>Contribuir</O>!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>NOTA: El staff de Parkour NO ES staff de Transformice y NO TIENEN ning√∫n poder en el juego, s√≥lamente dentro del m√≥dulo.</r>\nEl staff de Parkour se asegura de que el m√≥dulo corra bien con la menor cantidad de problemas, y siempre est√°n disponibles para ayudar a los jugadores cuando sea necesario.</font></p>\nPuedes escribir <D>!staff</D> en el chat para ver la lista de staff.\n\n<font color = '#E7342A'>Administradores:</font> Son los responsables de mantener el m√≥dulo a√±adiendo nuevas actualizaciones y arreglando bugs.\n\n<font color = '#D0A9F0'>Lideres de Equipos:</font> Ellos supervisan los equipos de Moderadores y Mappers, asegur√°ndose de que hagan un buen trabajo. Tambi√©n son los responsables de reclutar nuevos miembros al staff.\n\n<font color = '#FFAAAA'>Moderadores:</font> Son los responsables de ejercer las reglas del m√≥dulo y sancionar a quienes no las sigan.\n\n<font color = '#25C059'>Mappers:</font> Son los responsables de revisar, a√±adir y quitar mapas en el m√≥dulo para asegurarse de que tengas un buen gameplay.",
		help_rules = "<font size = '13'><B><J>Todas las reglas en los Terminos y Condiciones de Transformice tambi√©n aplican a #parkour</J></B></font>\n\nSi encuentras alg√∫n jugador rompiendo estas reglas, susurra a los moderadores de parkour en el juego. Si no hay moderadores online, es recomendable reportarlo en discord.\nCuando reportes, por favor agrega el servidor, el nombre de la sala, y el nombre del jugador.\n‚Ä¢ Ej: en-#parkour10 Blank#3495 trollear\nEvidencia, como fotos, videos y gifs ayudan y son apreciados, pero no son necesarios.\n\n<font size = '11'>‚Ä¢ No se permite el uso de <font color = '#ef1111'>hacks, glitches o bugs</font>\n‚Ä¢ <font color = '#ef1111'>Farmear con VPN</font> ser√° considerado un <B>abuso</B> y no est√° permitido. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nCualquier persona rompiendo estas reglas ser√° autom√°ticamente baneado.</B></font></p>\n\n<font size = '12'>Transformice acepta el concepto de trollear. Pero <font color='#cc2222'><B>no est√° permitido en #parkour.</B></font></font>\n\n<p align = 'center'><J>Trollear es cuando un jugador intencionalmente usa sus poderes o consumibles para hacer que otros jugadores no completen el mapa.</j></p>\n‚Ä¢ Trollear como venganza <B>no es una raz√≥n v√°lida</B> para trollear a alguien y a√∫n as√≠ seras sancionado.\n‚Ä¢ Ayudar a jugadores que no quieren completar el mapa con ayuda y no parar cuando te lo piden tambi√©n es considerado trollear.\n‚Ä¢ <J>Si un jugador no quiere ayuda, por favor ayuda a otros jugadores</J>. Sin embargo, si otro jugador necesita ayuda en el mismo punto, puedes ayudarlos [a los dos].\n\nSi un jugador es atrapado trolleando, ser√° sancionado en base de tiempo. Trollear repetidas veces llevar√° a sanciones m√°s largas y severas.",
		help_contribute = "<font size='14'>\n<p align='center'>El equipo de administraci√≥n de parkour ama el codigo abierto porque <t>ayuda a la comunidad</t>. Pod√©s <o>ver</o> y <o>modificar</o> el c√≥digo de parkour en <o><u><a href='event:github'>GitHub</a></u></o>.\n\nMantener el m√≥dulo es <t>estrictamente voluntario</t>, por lo que cualquier ayuda con respecto al <t>c√≥digo</t>, <t>reportes de bugs</t>, <t>sugerencias</t> y <t>creaci√≥n de mapas</t> siempre ser√° <u>bienvenida y apreciada</u>.\nPod√©s <vp>reportar bugs</vp> y <vp>dar sugerencias</vp> en <o><u><a href='event:discord'>Discord</a></u></o> y/o <o><u><a href='event:github'>GitHub</a></u></o>.\nPod√©s <vp>enviar tus mapas</vp> en nuestro <o><u><a href='event:map_submission'>Hilo del Foro</a></u></o>.\n\nMantener parkour no es caro, pero tampoco es gratis. Realmente apreciar√≠amos si pudieras ayudarnos <t>donando cualquier cantidad</t> <o><u><a href='event:donate'>aqu√≠</a></u></o>.\n<u>Todas las donaciones ser√°n destinadas a mejorar el m√≥dulo.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Versi√≥n 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ ¬°Se implement√≥ un <cep>sistema de r√©cords</cep>! V√© a checkearlo en <vp><u>*#parkour0records TuNombre#Tag</u></vp>\n‚Ä¢ Se mejor√≥ la rotaci√≥n de mapas.\n‚Ä¢ Se mejor√≥ la verificaci√≥n de <o><u><a href='event:discord'>Discord</a></u></o>.",

		-- Congratulation messages
		reached_level = "<d>¬°Felicitaciones! Alcanzaste el nivel <vp>%s</vp>.",
		finished = "<d><o>%s</o> complet√≥ el parkour en <vp>%s</vp> segundos, <fc>¬°felicitaciones!",
		unlocked_power = "<ce><d>%s</d> desbloque√≥ el poder <vp>%s<ce>.",

		-- Information messages
		staff_power = "<r>El staff de Parkour <b>no tiene</b> ning√∫n poder afuera de las salas de #parkour.",
		donate = "<vp>¬°Escribe <b>!donate</b> si te gustar√≠a donar a este m√≥dulo!",
		paused_events = "<cep><b>[¬°Advertencia!]</b> <n>El m√≥dulo est√° entrando en estado cr√≠tico y est√° siendo pausado.",
		resumed_events = "<n2>El m√≥dulo ha sido reanudado.",
		welcome = "<n>¬°Bienvenido a <t>#parkour</t>!",
		module_update = "<r><b>[¬°Advertencia!]</b> <n>El m√≥dulo se actualizar√° en <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>La tabla de clasificaci√≥n ha sido cargada. Presiona L para abrirla.",
		kill_minutes = "<R>Tus poderes fueron desactivados por %s minutos.",
		permbanned = "<r>Has sido baneado permanentemente de #parkour.",
		tempbanned = "<r>Has sido baneado de #parkour por %s minutos.",

		-- Records
		records_enabled = "<v>[#] <d>El modo de r√©cords est√° activado en esta sala. ¬°Las estad√≠sticas no cuentan y los poderes est√°n desactivados!\nPuedes encontrar m√°s informaci√≥n sobre r√©cords en <b>%s</b>",
		records_admin = "<v>[#] <d>Eres un administrador de esta sala de r√©cords. Puedes usar los comandos <b>!map</b>, <b>!pw</b> y <b>!time</b>.",
		records_completed = "<v>[#] <d>¬°Completaste el mapa! Si te gustar√≠a rehacerlo, escribe <b>!redo</b>.",
		records_submit = "<v>[#] <d>¬°Wow! Parece que completaste el mapa con el tiempo m√°s r√°pido en la sala. Si te gustar√≠a enviar tu record, escribe <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>Parece que este mapa no est√° en la rotaci√≥n de parkour... ¬°No puedes enviar un r√©cord en el!",
		records_not_fastest = "<v>[#] <r>Parece que no eres el m√°s r√°pido en la sala...",
		records_already_submitted = "<v>[#] <r>¬°Ya enviaste un r√©cord para este mapa!",
		records_submitted = "<v>[#] <d>Tu r√©cord para el mapa <b>%s</b> ha sido enviado.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Opciones de Parkour</font></p>\n\nUsar part√≠culas para los checkpoints\n\nUsar teclado <b>QWERTY</b> (desactivar si usas <b>AZERTY</b>)\n\nUsar la tecla <b>M</b> como atajo para <b>/mort</b> (desactivar si usas <b>DEL</b>)\n\nMostrar tiempos de espera de tus poderes\n\nMostrar el bot√≥n de poderes\n\nMostrar el bot√≥n de ayuda\n\nMostrar mensajes al completar un mapa\n\nMostrar indicador para no recibir ayuda",
		cooldown = "<v>[#] <r>Espera unos segundos antes de hacer eso de nuevo.",
		power_options = ("<font size='13' face='Lucida Console'>Teclado <b>QWERTY</b>" ..
						 "\n\n<b>Esconder</b> cantidad de mapas"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Completa <v>%s</v> mapas" ..
						"<font size='5'>\n\n</font>para desbloquear" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Completa <v>%s</v> mapas" ..
						"<font size='5'>\n\n</font>para mejorar a" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Posici√≥n <v>%s</v>" ..
						"<font size='5'>\n\n</font>para desbloquear" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Posici√≥n <v>%s</v>" ..
						"<font size='5'>\n\n</font>para mejorar a" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Mapas Completados"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Posici√≥n General"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>Posici√≥n Semanal"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Insignias (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>La cantidad de mapas de este jugador es privada. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Posici√≥n general: <b><v>%s</v></b>\n\n" ..
					"Posici√≥n semanal: <b><v>%s</v></b>"),
		map_count = "Cantidad de mapas: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Las insignias son logros que un usuario puede obtener. Click√©alas para ver su descripci√≥n.",
		help_private_maps = "¬°A este jugador no le gusta compartir su cantidad de mapas! Pod√©s esconder la tuya en tu perfil.",
		help_badge_1 = "Este jugador fue un miembro del staff de parkour.",
		help_badge_2 = "Este jugador est√° o estuvo en la p√°gina 1 del ranking general.",
		help_badge_3 = "Este jugador est√° o estuvo en la p√°gina 2 del ranking general.",
		help_badge_4 = "Este jugador est√° o estuvo en la p√°gina 3 del ranking general.",
		help_badge_5 = "Este jugador est√° o estuvo en la p√°gina 4 del ranking general.",
		help_badge_6 = "Este jugador est√° o estuvo en la p√°gina 5 del ranking general.",
		help_badge_7 = "Este jugador estuvo en el podio cuando el ranking semanal se reinici√≥.",
		help_badge_8 = "Este jugador tiene un record de 30 mapas en una hora.",
		help_badge_9 = "Este jugador tiene un record de 35 mapas en una hora.",
		help_badge_10 = "Este jugador tiene un record de 40 mapas en una hora.",
		help_badge_11 = "Este jugador tiene un record de 45 mapas en una hora.",
		help_badge_12 = "Este jugador tiene un record de 50 mapas en una hora.",
		help_badge_13 = "Este jugador tiene un record de 55 mapas en una hora.",
		help_badge_14 = "Este jugador verific√≥ su cuenta de discord en el servidor oficial de parkour (escribe <b>!discord</b>).",
		help_badge_15 = "Este jugador tuvo el tiempo m√°s r√°pido en 1 mapa.",
		help_badge_16 = "Este jugador tuvo el tiempo m√°s r√°pido en 5 mapas.",
		help_badge_17 = "Este jugador tuvo el tiempo m√°s r√°pido en 10 mapas.",
		help_badge_18 = "Este jugador tuvo el tiempo m√°s r√°pido en 15 mapas.",
		help_badge_19 = "Este jugador tuvo el tiempo m√°s r√°pido en 20 mapas.",
		help_badge_20 = "Este jugador tuvo el tiempo m√°s r√°pido en 25 mapas.",
		help_badge_21 = "Este jugador tuvo el tiempo m√°s r√°pido en 30 mapas.",
		help_badge_22 = "Este jugador tuvo el tiempo m√°s r√°pido en 35 mapas.",
		help_badge_23 = "Este jugador tuvo el tiempo m√°s r√°pido en 40 mapas.",
		make_public = "hacer p√∫blico",
		make_private = "hacer privado",
		moderators = "Moderadores",
		mappers = "Mappers",
		managers = "L√≠deres",
		administrators = "Administradores",
		close = "Cerrar",
		cant_load_bot_profile = "<v>[#] <r>No puedes ver el perfil de este bot ya que #parkour lo usa internamente para funcionar.",
		cant_load_profile = "<v>[#] <r>El jugador <b>%s</b> parece estar desconectado o no existe.",
		like_map = "¬øTe gusta este mapa?",
		yes = "S√≠",
		no = "No",
		idk = "No lo s√©",
		unknown = "Desconocido",
		powers = "Poderes",
		press = "<vp>Presiona %s",
		click = "<vp>Haz clic",
		ranking_pos = "Rank #%s",
		completed_maps = "<p align='center'><BV><B>Mapas completados: %s</B></p></BV>",
		leaderboard = "Tabla de clasificaci√≥n",
		position = "<V><p align=\"center\">Posici√≥n",
		username = "<V><p align=\"center\">Jugador",
		community = "<V><p align=\"center\">Comunidad",
		completed = "<V><p align=\"center\">Mapas completados",
		overall_lb = "General",
		weekly_lb = "Semanal",
		new_lang = "<v>[#] <d>Lenguaje cambiado a Espa√±ol",

		-- Power names
		balloon = "Globo",
		masterBalloon = "Globo Maestro",
		bubble = "Burbuja",
		fly = "Volar",
		snowball = "Bola de nieve",
		speed = "Velocidad",
		teleport = "Teletransporte",
		smallbox = "Caja peque√±a",
		cloud = "Nube",
		rip = "Tumba",
		choco = "Chocolate",
		bigBox = "Caja grande",
		trampoline = "Trampol√≠n",
		toilet = "Inodoro",
		pig = "Cerdito",
		sink = "Lavamanos",
		bathtub = "Ba√±era",
		campfire = "Fogata",
		chair = "Silla",
	}
	--[[ End of file translations/parkour/es.lua ]]--
	--[[ File translations/parkour/he.lua ]]--
	translations.he = {
		name = "he",
		fullname = "◊¢◊ë◊®◊ô◊™",

		-- Error messages
		corrupt_map = "<r>◊û◊§◊î ◊û◊©◊ï◊ë◊©◊™, ◊ò◊ï◊¢◊ü ◊ê◊ó◊®◊™.",
		corrupt_map_vanilla = "<r>[◊©◊í◊ô◊ê◊î] <n>◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ß◊ë◊ú ◊û◊ô◊ì◊¢ ◊ê◊ï◊ì◊ï◊™ ◊û◊§◊î ◊ñ◊ï.",
		corrupt_map_mouse_start = "<r>[◊©◊í◊ô◊ê◊î] <n>◊ì◊®◊ï◊© ◊û◊ß◊ï◊ù ◊î◊™◊ó◊ú◊î ◊ë◊û◊§◊î ◊ñ◊ï (◊†◊ß◊ï◊ì◊™ ◊î◊™◊ó◊ú◊î ◊©◊ú ◊î◊¢◊õ◊ë◊®).",
		corrupt_map_needing_chair = "<r>[◊©◊í◊ô◊ê◊î] <n>◊û◊§◊î ◊ñ◊ï ◊¶◊®◊ô◊õ◊î ◊°◊§◊î ◊ë◊†◊ß◊ï◊ì◊î ◊î◊°◊ï◊§◊ô◊™.",
		corrupt_map_missing_checkpoints = "<r>[◊©◊í◊ô◊ê◊î] <n>◊†◊ì◊®◊©◊™ ◊ú◊§◊ó◊ï◊™ ◊†◊ß◊ï◊ì◊™ ◊©◊û◊ô◊®◊î ◊ê◊ó◊™ ◊ë◊û◊§◊î ◊ñ◊ï (◊†◊ß◊ï◊ì◊î ◊¶◊î◊ï◊ë◊î).",
		corrupt_data = "<r>◊ú◊û◊®◊ë◊î ◊î◊¶◊¢◊®, ◊†◊™◊ï◊†◊ô◊ö ◊†◊§◊í◊û◊ï ◊ï◊ê◊ï◊§◊°◊ï.",
		min_players = "<r>◊¢◊ú ◊û◊™ ◊©◊†◊™◊ï◊†◊ô◊ö ◊ô◊©◊û◊®◊ï, ◊ó◊ô◊ô◊ë◊ô◊ù ◊ú◊î◊ô◊ï◊™ ◊ú◊§◊ó◊ï◊™ ◊ê◊®◊ë◊¢◊î ◊©◊ó◊ß◊†◊ô◊ù ◊©◊ï◊†◊ô◊ù ◊ë◊ó◊ì◊® ◊ñ◊î. <bl>[%s/%s]",
		tribe_house = "<r>◊†◊™◊ï◊†◊ô◊ù ◊ú◊ê ◊ô◊©◊û◊®◊ï ◊ë◊ë◊™◊ô ◊©◊ë◊ò.",
		invalid_syntax = "<r>syntax ◊©◊í◊ï◊ô.",
		code_error = "<r>◊©◊í◊ô◊ê◊î ◊î◊™◊í◊ú◊™◊î: <bl>%s-%s-%s %s",
		emergency_mode = "<r>◊û◊™◊ó◊ô◊ú ◊õ◊ô◊ë◊ï◊ô ◊ó◊ô◊®◊ï◊ù, ◊ê◊ô◊ü ◊õ◊†◊ô◊°◊î ◊ú◊©◊ó◊ß◊†◊ô◊ù ◊ó◊ì◊©◊ô◊ù. ◊ê◊†◊ê ◊ú◊ö ◊ú◊ó◊ì◊® #parkour ◊ê◊ó◊®.",
		leaderboard_not_loaded = "<r>◊î◊ú◊ï◊ó ◊™◊ï◊¶◊ê◊ï◊™ ◊¢◊ì◊ô◊ô◊ü ◊ú◊ê ◊†◊ò◊¢◊ü, ◊î◊û◊™◊ü ◊ì◊ß◊î.",
		max_power_keys = "<v>[#] <r>◊ê◊™◊ù ◊ô◊õ◊ï◊ú◊ô◊ù ◊©◊ô◊î◊ô◊ï ◊ú◊õ◊ù ◊¢◊ì %s ◊õ◊ï◊ó◊ï◊™ ◊¢◊ú ◊ê◊ï◊™◊ï ◊û◊ß◊©.",

		-- Help window
		help = "◊¢◊ñ◊®◊î",
		staff = "◊¶◊ï◊ï◊™",
		rules = "◊ó◊ï◊ß◊ô◊ù",
		contribute = "◊™◊®◊ï◊û◊î",
		changelog = "◊ó◊ì◊©",
		help_help = "<p align = 'center'><font size = '14'>◊ë◊®◊ï◊ö ◊î◊ë◊ê ◊ú-<T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>◊û◊ò◊®◊™◊ö ◊ú◊î◊©◊ô◊í ◊ê◊™ ◊õ◊ú ◊†◊ß◊ï◊ì◊ï◊™ ◊î◊©◊û◊ô◊®◊î ◊¢◊ì ◊©◊ê◊™◊î ◊û◊°◊ô◊ô◊ù ◊ê◊™ ◊î◊û◊§◊î.</J></p>\n\n<N>‚Ä¢ ◊ú◊ó◊• <O>◊ù</O>, ◊õ◊™◊ï◊ë <O>!op</O> ◊ê◊ï ◊ú◊ó◊• ◊¢◊ú <O>◊í◊ú◊í◊ú ◊î◊©◊ô◊†◊ô◊ô◊ù</O> ◊ë◊õ◊ì◊ô ◊ú◊§◊™◊ï◊ó ◊ê◊™ <T>◊î◊î◊í◊ì◊®◊ï◊™</T>.\n‚Ä¢ ◊ú◊ó◊• <O>◊§</O> ◊ê◊ï ◊ú◊ó◊• ◊¢◊ú <O>◊õ◊§◊™◊ï◊® ◊î◊ê◊í◊®◊ï◊£</O> ◊ë◊¶◊ì ◊ô◊û◊ô◊ü ◊ú◊û◊¢◊ú◊î ◊¢◊ú ◊û◊†◊™ ◊ú◊§◊™◊ï◊ó ◊ê◊™ <T>◊™◊§◊®◊ô◊ò ◊î◊õ◊ï◊ó◊ï◊™</T>.\n‚Ä¢ ◊ú◊ó◊• <O>◊ö</O> ◊ê◊ï ◊õ◊™◊ï◊ë <O>!lb</O> ◊ë◊õ◊ì◊ô ◊ú◊§◊™◊ï◊ó ◊ê◊™ <T>◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™</T>.\n‚Ä¢ ◊ú◊ó◊• ◊¢◊ú <O>◊¶</O> ◊ê◊ï ◊õ◊§◊™◊ï◊® ◊î-<O>Delete</O> ◊õ◊™◊ó◊ú◊ô◊£ ◊ú-<T>/mort</T>, ◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊ó◊ú◊ô◊£ ◊ë◊ô◊ü ◊î◊û◊ß◊©◊ô◊ù <J>◊ë◊î◊í◊ì◊®◊ï◊™</J>.\n‚Ä¢ ◊¢◊ú ◊û◊†◊™ ◊ú◊ì◊¢◊™ ◊¢◊ï◊ì ◊¢◊ú <O>◊î◊¶◊ï◊ï◊™</O> ◊©◊ú◊†◊ï ◊ï◊¢◊ú <O>◊î◊ó◊ï◊ß◊ô◊ù ◊©◊ú ◊§◊ê◊®◊ß◊ï◊®</O>, ◊ú◊ó◊• ◊¢◊ú ◊î◊õ◊®◊ò◊ô◊°◊ô◊ï◊™ <T>◊¶◊ï◊ï◊™</T> ◊ï<T>◊ó◊ï◊ß◊ô◊ù</T> ◊ú◊§◊ô ◊î◊°◊ì◊®.\n‚Ä¢ ◊ú◊ó◊• <a href='event:discord'><o>◊õ◊ê◊ü</o></a> ◊ë◊õ◊ì◊ô ◊ú◊ß◊ë◊ú ◊î◊ñ◊û◊†◊î ◊ú◊©◊®◊™ ◊î◊ì◊ô◊°◊ß◊ï◊®◊ì ◊ï<a href='event:map_submission'><o>◊õ◊ê◊ü</o></a> ◊ë◊õ◊ì◊ô ◊ú◊ß◊ë◊ú ◊ß◊ô◊©◊ï◊® ◊ú◊†◊ï◊©◊ê ◊î◊í◊©◊™ ◊î◊û◊§◊ï◊™.\n‚Ä¢ ◊ú◊ó◊• ◊¢◊ú ◊ó◊ô◊¶◊ô ◊î<o>◊ú◊û◊¢◊ú◊î</o> ◊ï◊î<o>◊ú◊û◊ò◊î</o> ◊õ◊ê◊©◊® ◊ê◊™◊î ◊¶◊®◊ô◊ö ◊ú◊í◊ú◊ï◊ú.\n\n<p align = 'center'><font size = '13'><T>◊†◊ô◊™◊ü ◊õ◊¢◊™ ◊ú◊™◊®◊ï◊ù! ◊ú◊§◊®◊ò◊ô◊ù ◊†◊ï◊°◊§◊ô◊ù ◊ú◊ó◊¶◊ï ◊¢◊ú ◊î◊õ◊®◊ò◊ô◊°◊ô◊ô◊î <O>◊™◊®◊ï◊û◊î</O> tab!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>◊î◊¢◊®◊î: ◊¶◊ï◊ï◊™ ◊î◊§◊ê◊®◊ß◊ï◊® ◊ê◊ô◊†◊ï ◊¶◊ï◊ï◊™ ◊î◊û◊©◊ó◊ß ◊ï◊ê◊ô◊ü ◊ú◊ï ◊©◊ï◊ù ◊õ◊ï◊ó ◊ë◊û◊©◊ó◊ß ◊¢◊¶◊û◊ï, ◊ê◊ú◊ê ◊®◊ß ◊ë◊û◊ï◊ì◊ï◊ú</r>\n◊¶◊ï◊ï◊™ ◊î◊§◊ê◊®◊ß◊ï◊® ◊û◊ï◊ï◊ì◊ê ◊õ◊ô ◊î◊û◊ï◊ì◊ï◊ú ◊®◊• ◊ë◊¶◊ï◊®◊î ◊ó◊ú◊ß◊î ◊¢◊ù ◊¢◊†◊ô◊ô◊†◊ô◊ù ◊û◊ô◊†◊ô◊û◊ú◊ô◊ô◊ù ◊ï◊î◊ù ◊™◊û◊ô◊ì ◊ñ◊û◊ô◊†◊ô◊ù ◊ú◊¢◊ñ◊ï◊® ◊ú◊©◊ó◊ß◊†◊ô◊ù ◊û◊™◊ô ◊©◊¶◊®◊ô◊ö.</font></p>\n◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊õ◊™◊ï◊ë <D>!staff</D> ◊ë◊¶'◊ê◊ò ◊õ◊ì◊ô ◊ú◊®◊ê◊ï◊™ ◊ê◊™ ◊®◊©◊ô◊û◊™ ◊î◊¶◊ï◊ï◊™.\n\n<font color = '#E7342A'>◊ê◊ì◊û◊ô◊†◊ô◊ù:</font> ◊î◊ù ◊ê◊ó◊®◊ê◊ô◊ù ◊ú◊©◊û◊ï◊® ◊¢◊ú ◊î◊û◊ï◊ì◊ï◊ú ◊¢◊ô ◊î◊ï◊°◊§◊™ ◊¢◊ì◊õ◊ï◊†◊ô◊ù ◊ï◊™◊ô◊ß◊ï◊†◊ô ◊ë◊ê◊í◊ô◊ù.\n\n<font color = '#D0A9F0'>◊û◊†◊î◊ú◊ô ◊¶◊ï◊ï◊™:</font> ◊î◊ù ◊û◊§◊ß◊ó◊ô◊ù ◊¢◊ú ◊¶◊ï◊ï◊™◊ô ◊î◊†◊ô◊î◊ï◊ú ◊ï◊î◊û◊§◊ï◊™, ◊û◊ï◊ï◊ì◊ê◊ô◊ù ◊õ◊ô ◊î◊ù ◊û◊ë◊¶◊¢◊ô◊ù ◊ê◊™ ◊¢◊ë◊ï◊ì◊™◊ù ◊õ◊©◊ï◊®◊î. ◊ë◊†◊ï◊°◊£, ◊î◊ù ◊î◊ê◊ó◊®◊ê◊ô◊ù ◊¢◊ú ◊í◊ô◊ï◊° ◊ó◊ë◊®◊ô◊ù ◊ó◊ì◊©◊ô◊ù ◊ú◊¶◊ï◊ï◊™.\n\n<font color = '#FFAAAA'>◊û◊†◊î◊ú◊ô◊ù:</font> ◊î◊ù ◊î◊ê◊ó◊®◊ê◊ô◊ù ◊ú◊ê◊õ◊ï◊£ ◊ê◊™ ◊ó◊ï◊ß◊ô ◊î◊û◊ï◊ì◊ï◊ú ◊ï◊î◊¢◊†◊©◊™ ◊û◊©◊™◊û◊©◊ô◊ù ◊ê◊©◊® ◊ú◊ê ◊©◊ï◊û◊®◊ô◊ù ◊¢◊ú◊ô◊î◊ù.\n\n<font color = '#25C059'>◊¶◊ï◊ï◊™ ◊û◊§◊ï◊™:</font> ◊î◊ù ◊î◊ê◊ó◊®◊ê◊ô◊ù ◊¢◊ú ◊°◊ß◊ô◊®◊î, ◊î◊ï◊°◊§◊î ◊ï◊î◊°◊®◊î ◊©◊ú ◊û◊§◊ï◊™ ◊ë◊û◊ï◊ì◊ï◊ú ◊î◊§◊ê◊®◊ß◊ï◊® ◊ë◊õ◊ì◊ô ◊ú◊î◊ë◊ò◊ô◊ó ◊©◊ô◊î◊ô◊î ◊ú◊õ◊ù ◊û◊©◊ó◊ß ◊û◊î◊†◊î.",
		help_rules = "<font size = '13'><B><J>◊õ◊ú ◊î◊ó◊ï◊ß◊ô◊ù, ◊î◊™◊†◊ê◊ô◊ù ◊ï◊î◊î◊í◊ë◊ú◊ï◊™ ◊©◊ú ◊î◊ò◊®◊ê◊†◊°◊§◊ï◊®◊û◊ô◊ô◊° ◊ó◊ú◊ô◊ù ◊í◊ù ◊¢◊ú #parkour</J></B></font>\n\n◊ê◊ù ◊ê◊™◊ù ◊û◊ï◊¶◊ê◊ô◊ù ◊©◊ó◊ß◊ü ◊ê◊©◊® ◊¢◊ï◊ë◊® ◊¢◊ú ◊ó◊ï◊ß◊ô◊ù ◊ê◊ú◊î, ◊©◊ú◊ó◊ï ◊ú◊ó◊ô◊©◊î ◊ú◊û◊†◊î◊ú◊ô ◊§◊ê◊®◊ß◊ï◊® ◊ë◊û◊©◊ó◊ß. ◊ê◊ù ◊ê◊ô◊ü ◊û◊†◊î◊ú◊ô◊ù ◊û◊ó◊ï◊ë◊®◊ô◊ù, ◊û◊ï◊û◊ú◊• ◊ú◊ì◊ï◊ï◊ó ◊¢◊ú ◊õ◊ö ◊ë◊©◊®◊™ ◊î◊ì◊ô◊°◊ß◊ï◊®◊ì.\n◊õ◊ê◊©◊® ◊û◊ì◊ï◊ï◊ó◊ô◊ù, ◊ë◊ë◊ß◊©◊î ◊õ◊ú◊ú◊ï ◊ê◊™ ◊î◊©◊®◊™, ◊©◊ù ◊î◊ó◊ì◊®, ◊ï◊©◊ù ◊î◊û◊©◊™◊û◊© ◊©◊ú ◊î◊©◊ó◊ß◊ü.\n‚Ä¢ ◊ì◊ï◊í◊û◊ê: en-#parkour10 Blank#3495 trolling\n◊î◊ï◊õ◊ó◊ï◊™ ◊õ◊í◊ï◊ü ◊¶◊ô◊ú◊ï◊û◊ô ◊û◊°◊ö, ◊ï◊ô◊ì◊ê◊ï ◊ê◊ï ◊í◊ô◊§◊° ◊î◊ù ◊ô◊¢◊ô◊ú◊ô◊ù ◊ï◊û◊ï◊¢◊®◊õ◊ô◊ù, ◊ê◊ö ◊ú◊ê ◊ó◊ô◊ô◊ë.\n\n<font size = '11'>‚Ä¢ ◊ê◊ô◊ü ◊ú◊î◊©◊™◊û◊© ◊ë<font color = '#ef1111'>◊î◊ê◊ß◊ô◊ù, ◊í◊ú◊ô◊¶'◊ô◊ù ◊ê◊ï ◊ë◊ê◊í◊ô◊ù</font> ◊ë◊ó◊ì◊®◊ô ◊§◊ê◊®◊ß◊ï◊®\n‚Ä¢ <font color = '#ef1111'>◊§◊ê◊®◊ù VPN </font> ◊ô◊ô◊ó◊©◊ë ◊õ<B>◊†◊ô◊¶◊ï◊ú</B> ◊ï◊î◊ì◊ë◊® ◊ê◊°◊ï◊®. <p align = 'center'><font color = '#cc2222' size = '12'><B>\n◊õ◊ú ◊ê◊ó◊ì ◊©◊ô◊™◊§◊° ◊¢◊ï◊ë◊® ◊¢◊ú ◊ó◊ï◊ß◊ô◊ù ◊ê◊ú◊î ◊ô◊ï◊®◊ó◊ß ◊ë◊ê◊ï◊§◊ü ◊û◊ô◊ô◊ì◊ô.</B></font></p>\n\n<font size = '12'>◊ò◊®◊ê◊†◊°◊§◊ï◊®◊û◊ô◊ô◊° ◊û◊®◊©◊î ◊ú◊¢◊©◊ï◊™ ◊ò◊®◊ï◊ú◊ô◊ù. ◊¢◊ù ◊ñ◊ê◊™, <font color='#cc2222'><B>◊ê◊†◊ï ◊ú◊ê ◊†◊ê◊§◊©◊® ◊ñ◊ê◊™ ◊ë◊§◊ê◊®◊ß◊ï◊®.</B></font></font>\n\n<p align = 'center'><J>◊ò◊®◊ï◊ú ◊ñ◊î ◊õ◊ê◊©◊® ◊©◊ó◊ß◊ü ◊û◊©◊™◊û◊© ◊ë◊õ◊ï◊ó◊ï◊™◊ô◊ï ◊ê◊ï ◊ë◊û◊ï◊¶◊®◊ô ◊ñ◊®◊ô◊ß◊î ◊ë◊õ◊ï◊ï◊†◊î ◊™◊ó◊ô◊ú◊î ◊õ◊ì◊ô ◊ú◊û◊†◊ï◊¢ ◊û◊©◊ó◊ß◊†◊ô◊ù ◊ê◊ó◊®◊ô◊ù ◊ú◊°◊ô◊ô◊ù ◊ê◊™ ◊î◊û◊§◊î.</j></p>\n‚Ä¢ ◊ò◊®◊ï◊ú ◊õ◊†◊ß◊û◊î ◊î◊ï◊ê <B>◊ê◊ô◊†◊ï ◊°◊ô◊ë◊î ◊û◊ï◊¶◊ì◊ß◊™</B> ◊ú◊î◊ò◊®◊ô◊ú ◊û◊ô◊©◊î◊ï ◊ï◊ê◊™◊ù ◊¢◊ì◊ô◊ô◊ü ◊™◊¢◊†◊©◊ï.\n‚Ä¢ ◊õ◊§◊ô◊ô◊™ ◊¢◊ñ◊®◊î ◊¢◊ú ◊©◊ó◊ß◊†◊ô◊ù ◊©◊û◊†◊°◊ô◊ù ◊ú◊î◊©◊ú◊ô◊ù ◊ú◊ë◊ì◊ù ◊ê◊™ ◊î◊û◊§◊î ◊ï◊°◊ô◊®◊ï◊ë ◊ú◊î◊§◊°◊ô◊ß ◊õ◊ê◊©◊® ◊î◊™◊ë◊ß◊©◊™ ◊ú◊õ◊ö ◊ô◊ô◊ó◊©◊ë ◊õ◊ò◊®◊ï◊ú.\n‚Ä¢ <J>◊ê◊ù ◊©◊ó◊ß◊ü ◊ê◊ô◊†◊ï ◊û◊¢◊ï◊†◊ô◊ô◊ü ◊ë◊¢◊ñ◊®◊î ◊ê◊ï ◊û◊¢◊ï◊†◊ô◊ô◊ü ◊ú◊î◊©◊ú◊ô◊ù ◊ú◊ë◊ì◊ï ◊ê◊™ ◊î◊û◊§◊î, ◊ê◊†◊ê ◊†◊°◊ï ◊õ◊õ◊ú ◊ô◊õ◊ï◊ú◊™◊õ◊ù ◊ú◊¢◊ñ◊ï◊® ◊ú◊©◊ó◊ß◊†◊ô◊ù ◊ê◊ó◊®◊ô◊ù</J>. ◊¢◊ù ◊ñ◊ê◊™, ◊ê◊ù ◊©◊ó◊ß◊ü ◊ê◊ó◊® ◊¶◊®◊ô◊ö ◊¢◊ñ◊®◊î ◊ë◊ê◊ï◊™◊î ◊†◊ß◊ï◊ì◊î ◊õ◊û◊ï ◊î◊©◊ó◊ß◊ü ◊î◊©◊†◊ô ◊©◊®◊ï◊¶◊î ◊ú◊î◊©◊ú◊ô◊ù ◊ú◊ë◊ì, ◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊¢◊ñ◊ï◊® ◊ú◊©◊†◊ô◊î◊ù.\n\n◊ê◊ù ◊©◊ó◊ß◊ü ◊ô◊™◊§◊° ◊û◊ò◊®◊ô◊ú, ◊î◊ï◊ê ◊ô◊¢◊†◊© ◊¢◊ú ◊ë◊°◊ô◊° ◊ñ◊û◊ü. ◊ó◊©◊ï◊ë ◊ú◊¶◊ô◊ô◊ü ◊õ◊ô ◊ë◊ô◊¶◊ï◊¢ ◊ò◊®◊ï◊ú ◊©◊ï◊ë ◊ï◊©◊ï◊ë ◊ô◊ï◊ë◊ô◊ú ◊ú◊¢◊ï◊†◊©◊ô◊ù ◊ê◊®◊ï◊õ◊ô◊ù ◊ô◊ï◊™◊® ◊ï◊ó◊û◊ï◊®◊ô◊ù ◊ô◊ï◊™◊®.",
		help_contribute = "<font size='14'>\n<p align='center'>◊¶◊ï◊ï◊™ ◊î◊†◊ô◊î◊ï◊ú ◊©◊ú ◊§◊ê◊®◊ß◊ï◊® ◊ê◊ï◊î◊ë ◊ú◊§◊™◊ï◊ó ◊ê◊™ ◊ß◊ï◊ì ◊î◊û◊ß◊ï◊® ◊û◊õ◊ô◊ï◊ï◊ü ◊©◊ñ◊î <t>◊¢◊ï◊ñ◊® ◊ú◊ß◊î◊ô◊ú◊î</t>. ◊ê◊™◊î ◊ô◊õ◊ï◊ú <o>◊ú◊®◊ê◊ï◊™</o> ◊ï<o>◊ú◊¢◊®◊ï◊ö</o> ◊ê◊™ ◊ß◊ï◊ì ◊î◊û◊ß◊ï◊® ◊ë-<o><u><a href='event:github'>GitHub</a></u></o>.\n\n◊©◊û◊ô◊®◊î ◊¢◊ú ◊î◊û◊ï◊ì◊ï◊ú ◊î◊ô◊ê <t>◊î◊™◊†◊ì◊ë◊ï◊™◊ô◊™ ◊ú◊ó◊ú◊ï◊ò◊ô◊ü</t>. ◊ú◊õ◊ü, ◊õ◊ú ◊¢◊ñ◊®◊î ◊ë<t>◊ß◊ï◊ì◊ô◊ù</t>, <t>◊ì◊ô◊ï◊ï◊ó ◊¢◊ú ◊ë◊ê◊í◊ô◊ù</t>, <t>◊î◊¶◊¢◊ï◊™</t> ◊ï<t>◊ô◊¶◊ô◊®◊™ ◊û◊§◊ï◊™</t> ◊™◊û◊ô◊ì <u>◊û◊™◊ß◊ë◊ú◊™ ◊ë◊ë◊®◊õ◊î ◊ï◊û◊ï◊¢◊®◊õ◊™</u>.\n◊ê◊™◊î ◊ô◊õ◊ï◊ú <vp>◊ú◊ì◊ï◊ï◊ó ◊ê◊ï◊ì◊ï◊™ ◊ë◊ê◊í◊ô◊ù</vp> ◊ï<vp>◊ú◊î◊¶◊ô◊¢ ◊î◊¶◊¢◊ï◊™</vp> ◊ë<o><u><a href='event:discord'>◊ì◊ô◊°◊ß◊ï◊®◊ì</a></u></o> ◊ï/◊ê◊ï ◊ë-<o><u><a href='event:github'>GitHub</a></u></o>.\n◊ê◊™◊î ◊ô◊õ◊ï◊ú <vp>◊ú◊î◊í◊ô◊© ◊ê◊™ ◊û◊§◊ï◊™◊ô◊ö</vp> ◊ë<o><u><a href='event:map_submission'>◊†◊ï◊©◊ê ◊î◊§◊ï◊®◊ï◊ù</a></u></o> ◊©◊ú◊†◊ï.\n\n◊ê◊ó◊ñ◊ß◊™ ◊§◊ê◊®◊ß◊ï◊® ◊ê◊ô◊†◊†◊î ◊ô◊ß◊®◊î, ◊ê◊ö ◊í◊ù ◊ê◊ô◊†◊†◊î ◊ó◊ô◊†◊û◊ô◊™. ◊ê◊†◊ï ◊†◊©◊û◊ó ◊ê◊ù ◊™◊ï◊õ◊ú◊ï ◊ú◊¢◊ñ◊ï◊® ◊ú◊†◊ï ◊¢◊ô <t>◊™◊®◊ï◊û◊î ◊ë◊õ◊ú ◊°◊õ◊ï◊ù</t> <o><u><a href='event:donate'>◊õ◊ê◊ü</a></u></o>.\n<u>◊õ◊ú ◊î◊™◊®◊ï◊û◊ï◊™ ◊î◊ï◊ú◊õ◊ï◊™ ◊î◊ô◊ô◊©◊® ◊ú◊©◊ô◊§◊ï◊® ◊î◊û◊ï◊ì◊ï◊ú.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>◊í◊ô◊®◊°◊î 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ ◊î◊ï◊°◊§◊†◊ï <cep>◊û◊¢◊®◊õ◊™ ◊©◊ô◊ê◊ô◊ù</cep>! ◊ú◊õ◊ï ◊ï◊™◊ë◊ó◊†◊ï ◊ê◊™ ◊ñ◊î ◊ë-<vp><u>*#parkour0records YourName#Tag</u></vp>\n‚Ä¢ ◊©◊ô◊§◊ï◊® ◊ê◊ï◊°◊£ ◊î◊û◊§◊ï◊™.\n‚Ä¢ ◊©◊ô◊§◊ï◊® <o><u><a href='event:discord'>Discord</a></u></o>◊î◊ê◊ô◊û◊ï◊™.",

		-- Congratulation messages
		reached_level = "<d>◊ë◊®◊õ◊ï◊™! ◊¢◊ú◊ô◊™ ◊ú◊®◊û◊î <vp>%s</vp>.",
		finished = "<d><o>%s</o> ◊°◊ô◊ô◊ù ◊ê◊™ ◊î◊§◊ê◊®◊ß◊ï◊® ◊™◊ï◊ö <vp>%s</vp> ◊©◊†◊ô◊ï◊™, <fc>◊ë◊®◊õ◊ï◊™!",
		unlocked_power = "<ce><d>%s</d> ◊î◊©◊ô◊í ◊ê◊™ ◊î◊õ◊ó <vp>%s</vp>.",

		-- Information messages
		staff_power = "<r>◊ú◊¶◊ï◊ï◊™ ◊§◊ê◊®◊ß◊ï◊® <b>◊ê◊ô◊ü</b> ◊©◊ï◊ù ◊õ◊ï◊ó◊ï◊™ ◊û◊ó◊ï◊• ◊ú◊ó◊ì◊®◊ô ◊§◊ê◊®◊ß◊ï◊®.",
		donate = "<vp>◊î◊ß◊ú◊ì <b>!donate</b> ◊ê◊ù ◊™◊®◊¶◊î ◊ú◊™◊®◊ï◊ù ◊¢◊ë◊ï◊® ◊û◊ï◊ì◊ï◊ú ◊ñ◊î!",
		paused_events = "<cep><b>[◊ê◊ñ◊î◊®◊î!]</b> <n>◊î◊û◊©◊ó◊ß ◊î◊í◊ô◊¢ ◊ú◊û◊í◊ë◊ú◊î ◊ß◊®◊ô◊ò◊ô◊™ ◊ï◊†◊¢◊¶◊® ◊õ◊¢◊™.",
		resumed_events = "<n2>◊î◊û◊©◊ó◊ß ◊†◊û◊©◊ö.",
		welcome = "<n>◊ë◊®◊ï◊õ◊ô◊ù ◊î◊ë◊ê◊ô◊ù ◊ú<t>#parkour</t>!",
		module_update = "<r><b>[◊ê◊ñ◊î◊®◊î!]</b> <n>◊î◊û◊©◊ó◊ß ◊ô◊¢◊ì◊ï◊õ◊ü ◊ë◊¢◊ï◊ì <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊†◊ò◊¢◊ü. ◊ú◊ó◊• L ◊õ◊ì◊ô ◊ú◊§◊™◊ï◊ó ◊ê◊ï◊™◊ï.",
		kill_minutes = "<R>◊õ◊ï◊ó◊ï◊™◊ô◊ö ◊î◊ï◊©◊ë◊™◊ï ◊ú-%s ◊ì◊ß◊ï◊™.",
		permbanned = "<r>◊î◊ï◊®◊ó◊ß◊™ ◊ú◊¶◊û◊ô◊™◊ï◊™ ◊û-#parkour.",
		tempbanned = "<r>◊î◊ï◊®◊ó◊ß◊™ ◊û-#parkour ◊ú◊û◊©◊ö %s ◊ì◊ß◊ï◊™.",

		-- Records
		records_enabled = "<v>[#] <d>◊û◊¶◊ë ◊©◊ô◊ê◊ô◊ù ◊î◊ï◊§◊¢◊ú ◊ë◊ó◊ì◊® ◊ñ◊î. ◊°◊ò◊ò◊ô◊°◊ò◊ô◊ß◊î ◊ú◊ê ◊™◊ô◊ó◊©◊ë ◊ï◊õ◊ï◊ó◊ï◊™ ◊ú◊ê ◊ô◊§◊¢◊ú◊ï. ◊™◊ï◊õ◊ú◊ï ◊ú◊û◊¶◊ï◊ê ◊û◊ô◊ì◊¢ ◊†◊ï◊°◊£ ◊¢◊ú ◊©◊ô◊ê◊ô◊ù ◊ë <b>%s</b>",
		records_admin = "<v>[#] <d>◊î◊†◊ö ◊û◊†◊î◊ú ◊©◊ú ◊ó◊ì◊® ◊î◊©◊ô◊ê◊ô◊ù ◊î◊ñ◊î. ◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊©◊™◊û◊© ◊ë◊§◊ß◊ï◊ì◊ï◊™ <b>!map</b>, <b>!pw</b> ◊ï-<b>!time</b>.",
		records_completed = "<v>[#] <d>◊î◊©◊ú◊û◊™◊ù ◊ê◊™ ◊î◊û◊§◊î! ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊©◊ú◊ô◊û◊î ◊©◊ï◊ë, ◊õ◊™◊ë◊ï <b>!redo</b>.",
		records_submit = "<v>[#] <d>◊ï◊ï◊ê◊ï! ◊†◊®◊ê◊î ◊©◊ô◊© ◊ú◊õ◊ù ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊õ◊ô ◊û◊î◊ô◊® ◊ë◊ó◊ì◊®. ◊ê◊ù ◊ë◊®◊¶◊ï◊†◊õ◊ù ◊ú◊î◊í◊ô◊© ◊ê◊™ ◊î◊©◊ô◊ê, ◊õ◊™◊ë◊ï <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>◊†◊®◊ê◊î ◊õ◊ô ◊û◊§◊î ◊ñ◊ï ◊ê◊ô◊†◊î ◊ó◊ú◊ß ◊û◊û◊§◊ï◊™ ◊§◊ê◊®◊ß◊ï◊®... ◊ê◊ô◊†◊õ◊ù ◊ô◊õ◊ï◊ú◊ô◊ù ◊ú◊î◊í◊ô◊© ◊©◊ô◊ê ◊ë◊©◊ë◊ô◊ú◊î!",
		records_not_fastest = "<v>[#] <r>◊†◊®◊ê◊î ◊õ◊ô ◊ê◊ô◊†◊ö ◊î◊©◊ó◊ß◊ü ◊î◊õ◊ô ◊û◊î◊ô◊® ◊ë◊ó◊ì◊®...",
		records_already_submitted = "<v>[#] <r>◊õ◊ë◊® ◊î◊í◊©◊™ ◊ê◊™ ◊î◊©◊ô◊ê ◊©◊ú◊ö ◊ë◊©◊ë◊ô◊ú ◊û◊§◊î ◊ñ◊ï!",
		records_submitted = "<v>[#] <d>◊î◊©◊ô◊ê ◊©◊ú◊ö ◊ú◊û◊§◊î <b>%s</b> ◊î◊ï◊í◊©.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>◊ê◊§◊©◊®◊ï◊ô◊ï◊™ ◊§◊ê◊®◊ß◊ï◊®</font></p>\n\n◊î◊©◊™◊û◊© ◊ë◊ó◊ú◊ß◊ô◊ù ◊õ◊†◊ß◊ï◊ì◊ï◊™ ◊©◊û◊ô◊®◊î\n\n◊î◊©◊™◊û◊© ◊ë◊û◊ß◊ú◊ì◊™ <b>QWERTY</b> (◊õ◊ë◊î ◊ê◊ù <b>AZERTY</b> ◊ë◊©◊ô◊û◊ï◊©)\n\n◊î◊©◊™◊û◊© ◊ë◊ê◊ï◊™ <b>◊¶</b> ◊ë◊û◊ß◊ï◊ù <b>/mort</b> (◊û◊©◊ë◊ô◊™ ◊ê◊™ <b>DEL</b>)\n\n◊î◊®◊ê◊î ◊ê◊™ ◊ñ◊û◊ü ◊ò◊¢◊ô◊†◊™ ◊î◊õ◊ï◊ó◊ï◊™\n\n◊î◊®◊ê◊î ◊õ◊§◊™◊ï◊® ◊õ◊ï◊ó◊ï◊™\n\n◊î◊®◊ê◊î ◊õ◊§◊™◊ï◊® ◊¢◊ñ◊®◊î\n\n◊î◊®◊ê◊î ◊î◊õ◊®◊ñ◊ï◊™ ◊î◊©◊ú◊û◊™ ◊û◊§◊ï◊™\n\n◊î◊¶◊í ◊°◊ô◊û◊ü '◊ú◊ú◊ê ◊¢◊ñ◊®◊î'",
		cooldown = "<v>[#] <r>◊î◊û◊™◊ü ◊û◊°◊§◊® ◊©◊†◊ô◊ï◊™ ◊ú◊§◊†◊ô ◊©◊ê◊™◊î ◊¢◊ï◊©◊î ◊ñ◊ê◊™.",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> ◊û◊ß◊ú◊ì◊™" ..
						 "\n\n<b>◊î◊°◊™◊®</b> ◊°◊§◊ô◊®◊™ ◊û◊§◊ï◊™"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>◊î◊©◊ú◊ù <v>%s</v> ◊û◊§◊ï◊™" ..
						"<font size='5'>\n\n</font>◊ë◊õ◊ì◊ô ◊ú◊î◊©◊ô◊í" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>◊î◊©◊ú◊ù <v>%s</v> ◊û◊§◊ï◊™" ..
						"<font size='5'>\n\n</font>◊õ◊ì◊ô ◊ú◊©◊ì◊®◊í ◊ú" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>◊ì◊®◊í◊î <v>%s</v>" ..
						"<font size='5'>\n\n</font>◊ë◊õ◊ì◊ô ◊ú◊î◊©◊ô◊í" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>◊ì◊®◊í◊î <v>%s</v>" ..
						"<font size='5'>\n\n</font>◊õ◊ì◊ô ◊ú◊©◊ì◊®◊í ◊ú" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>◊û◊§◊ï◊™ ◊©◊î◊ï◊©◊ú◊û◊ï"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>◊ú◊ï◊ó ◊™◊ï◊¶◊ê◊ï◊™ ◊õ◊ú◊ú◊ô"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>◊ú◊ï◊ó ◊™◊ï◊¶◊ê◊ï◊™ ◊©◊ë◊ï◊¢◊ô"),
		badges = "<font size='14' face='Lucida Console,Verdana'>◊™◊í◊ô◊ù (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>◊û◊°◊§◊® ◊î◊û◊§◊ï◊™ ◊©◊ú ◊©◊ó◊ß◊ü ◊ñ◊î ◊î◊ô◊†◊ï ◊§◊®◊ò◊ô. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"◊ì◊®◊í◊î ◊ë◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊õ◊ú◊ú◊ô: <b><v>%s</v></b>\n\n" ..
					"◊ì◊®◊í◊î ◊ë◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊©◊ë◊ï◊¢◊ô: <b><v>%s</v></b>"),
		map_count = "◊û◊°◊§◊® ◊û◊§◊ï◊™: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "◊™◊í◊ô◊ù ◊î◊ô◊†◊ù ◊î◊ô◊©◊í◊ô◊ù ◊©◊©◊ó◊ß◊ü ◊ô◊õ◊ï◊ú ◊ú◊ß◊ë◊ú. ◊ú◊ó◊• ◊¢◊ú◊ô◊î◊ù ◊¢◊ú ◊û◊†◊™ ◊ú◊ß◊ë◊ú ◊§◊ô◊®◊ï◊ò.",
		help_private_maps = "◊û◊©◊™◊û◊© ◊ñ◊î ◊ê◊ô◊†◊ï ◊û◊¢◊ï◊†◊ô◊ô◊ü ◊ú◊©◊™◊£ ◊ê◊™ ◊û◊°◊§◊® ◊î◊û◊§◊ï◊™ ◊©◊ú◊ï ◊ë◊§◊ï◊û◊ë◊ô! ◊ê◊™◊î ◊ô◊õ◊ï◊ú ◊ú◊î◊°◊™◊ô◊® ◊ê◊™ ◊ñ◊î ◊í◊ù ◊ë◊§◊®◊ï◊§◊ô◊ú ◊©◊ú◊ö.",
		help_badge_1 = "◊û◊©◊™◊û◊© ◊ñ◊î ◊î◊ô◊î ◊ó◊ú◊ß ◊û◊¶◊ï◊ï◊™ ◊î◊§◊ê◊®◊ß◊ï◊® ◊ë◊¢◊ë◊®.",
		help_badge_2 = "◊û◊©◊™◊û◊© ◊ñ◊î ◊†◊û◊¶◊ê ◊ê◊ï ◊î◊ô◊î ◊ë◊¢◊û◊ï◊ì ◊î◊®◊ê◊©◊ï◊ü ◊©◊ú ◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊õ◊ú◊ú◊ô.",
		help_badge_3 = "◊û◊©◊™◊û◊© ◊ñ◊î ◊†◊û◊¶◊ê ◊ê◊ï ◊î◊ô◊î ◊ë◊¢◊û◊ï◊ì ◊î◊©◊†◊ô ◊©◊ú ◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊õ◊ú◊ú◊ô.",
		help_badge_4 = "◊û◊©◊™◊û◊© ◊ñ◊î ◊†◊û◊¶◊ê ◊ê◊ï ◊î◊ô◊î ◊ë◊¢◊û◊ï◊ì ◊î◊©◊ú◊ô◊©◊ô ◊©◊ú ◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊õ◊ú◊ú◊ô.",
		help_badge_5 = "◊û◊©◊™◊û◊© ◊ñ◊î ◊†◊û◊¶◊ê ◊ê◊ï ◊î◊ô◊î ◊ë◊¢◊û◊ï◊ì ◊î◊®◊ë◊ô◊¢◊ô ◊©◊ú ◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊õ◊ú◊ú◊ô.",
		help_badge_6 = "◊û◊©◊™◊û◊© ◊ñ◊î ◊†◊û◊¶◊ê ◊ê◊ï ◊î◊ô◊î ◊ë◊¢◊û◊ï◊ì ◊î◊ó◊û◊ô◊©◊ô ◊©◊ú ◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊õ◊ú◊ú◊ô.",
		help_badge_7 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊î◊ô◊î ◊ë◊§◊ï◊ì◊ô◊ï◊ù ◊ë◊°◊ï◊£ ◊©◊ú ◊ú◊ï◊ó ◊î◊™◊ï◊¶◊ê◊ï◊™ ◊î◊©◊ë◊ï◊¢◊ô ◊ë◊°◊ï◊£ ◊©◊ë◊ï◊¢",
		help_badge_8 = "◊î◊©◊ó◊ß◊ü ◊î◊ñ◊î ◊î◊©◊ô◊í ◊©◊ô◊ê ◊©◊ú 30 ◊û◊§◊ï◊™ ◊™◊ï◊ö ◊©◊¢◊î.",
		help_badge_9 = "◊î◊©◊ó◊ß◊ü ◊î◊ñ◊î ◊î◊©◊ô◊í ◊©◊ô◊ê ◊©◊ú 35 ◊û◊§◊ï◊™ ◊™◊ï◊ö ◊©◊¢◊î.",
		help_badge_10 = "◊î◊©◊ó◊ß◊ü ◊î◊ñ◊î ◊î◊©◊ô◊í ◊©◊ô◊ê ◊©◊ú 40 ◊û◊§◊ï◊™ ◊™◊ï◊ö ◊©◊¢◊î.",
		help_badge_11 = "◊î◊©◊ó◊ß◊ü ◊î◊ñ◊î ◊î◊©◊ô◊í ◊©◊ô◊ê ◊©◊ú 45 ◊û◊§◊ï◊™ ◊™◊ï◊ö ◊©◊¢◊î.",
		help_badge_12 = "◊î◊©◊ó◊ß◊ü ◊î◊ñ◊î ◊î◊©◊ô◊í ◊©◊ô◊ê ◊©◊ú 50 ◊û◊§◊ï◊™ ◊™◊ï◊ö ◊©◊¢◊î.",
		help_badge_13 = "◊î◊©◊ó◊ß◊ü ◊î◊ñ◊î ◊î◊©◊ô◊í ◊©◊ô◊ê ◊©◊ú 55 ◊û◊§◊ï◊™ ◊™◊ï◊ö ◊©◊¢◊î.",
		help_badge_14 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊ê◊ô◊û◊™ ◊ê◊™ ◊û◊©◊™◊û◊© ◊î◊ì◊ô◊°◊ß◊ï◊®◊ì ◊©◊ú◊ï ◊ë◊©◊®◊™ ◊î◊ì◊ô◊°◊ß◊ï◊®◊ì ◊î◊®◊©◊û◊ô ◊©◊ú ◊§◊ê◊®◊ß◊ï◊® (◊õ◊™◊ë◊ï <b>!discord</b>).",
		help_badge_15 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë◊û◊§◊î ◊ê◊ó◊™.",
		help_badge_16 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-5 ◊û◊§◊ï◊™.",
		help_badge_17 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-10 ◊û◊§◊ï◊™.",
		help_badge_18 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-15 ◊û◊§◊ï◊™.",
		help_badge_19 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-20 ◊û◊§◊ï◊™.",
		help_badge_20 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-25 ◊û◊§◊ï◊™.",
		help_badge_21 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-30 ◊û◊§◊ï◊™.",
		help_badge_22 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-35 ◊û◊§◊ï◊™.",
		help_badge_23 = "◊©◊ó◊ß◊ü ◊ñ◊î ◊¢◊©◊î ◊ê◊™ ◊î◊ñ◊û◊ü ◊î◊û◊î◊ô◊® ◊ë◊ô◊ï◊™◊® ◊ë-40 ◊û◊§◊ï◊™.",
		make_public = "◊î◊§◊ï◊ö ◊ú◊¶◊ô◊ë◊ï◊®◊ô",
		make_private = "◊î◊§◊ï◊ö ◊ú◊§◊®◊ò◊ô",
		moderators = "◊û◊†◊î◊ú◊ô◊ù",
		mappers = "◊¶◊ï◊ï◊™ ◊û◊§◊ï◊™",
		managers = "◊û◊†◊î◊ú◊ô ◊¶◊ï◊ï◊™",
		administrators = "◊ê◊ì◊û◊ô◊†◊ô◊ù",
		close = "◊°◊í◊ï◊®",
		cant_load_bot_profile = "<v>[#] <r>◊ê◊ô◊†◊ö ◊ô◊õ◊ï◊ú ◊ú◊®◊ê◊ï◊™ ◊ê◊™ ◊î◊§◊®◊ï◊§◊ô◊ú ◊©◊ú ◊î◊ë◊ï◊ò ◊î◊ñ◊î ◊õ◊ô◊ï◊ï◊ü ◊©◊§◊ê◊®◊ß◊ï◊® ◊û◊©◊™◊û◊© ◊ë◊ï ◊ë◊ê◊ï◊§◊ü ◊§◊†◊ô◊û◊ô ◊õ◊ì◊ô ◊ú◊¢◊ë◊ï◊ì ◊ë◊¶◊ï◊®◊î ◊®◊ê◊ï◊ô◊î.",
		cant_load_profile = "<v>[#] <r>◊î◊©◊ó◊ß◊ü <b>%s</b> ◊õ◊õ◊ú ◊î◊†◊®◊ê◊î ◊û◊†◊ï◊™◊ß ◊ê◊ï ◊ê◊ô◊†◊†◊ï ◊ß◊ô◊ô◊ù.",
		like_map = "◊î◊ê◊ù ◊ê◊™◊î ◊ê◊ï◊î◊ë ◊ê◊™ ◊î◊û◊§◊î ◊î◊ñ◊ï?",
		yes = "◊õ◊ü",
		no = "◊ú◊ê",
		idk = "◊ú◊ê ◊ô◊ï◊ì◊¢",
		unknown = "◊ú◊ê ◊ô◊ì◊ï◊¢",
		powers = "◊õ◊ï◊ó◊ï◊™",
		press = "<vp>◊ú◊ó◊• %s",
		click = "<vp>◊ú◊ó◊ô◊¶◊î ◊©◊û◊ê◊ú◊ô◊™",
		ranking_pos = "◊ì◊®◊í◊î #%s",
		completed_maps = "<p align='center'><BV><B>◊û◊§◊ï◊™ ◊©◊î◊ï◊©◊ú◊û◊ï: %s</B></p></BV>",
		leaderboard = "◊ú◊ï◊ó ◊™◊ï◊¶◊ê◊ï◊™",
		position = "<V><p align=\"center\">◊ì◊®◊í◊î",
		username = "<V><p align=\"center\">◊©◊ù ◊û◊©◊™◊û◊©",
		community = "<V><p align=\"center\">◊ß◊î◊ô◊ú◊î",
		completed = "<V><p align=\"center\">◊û◊§◊ï◊™ ◊©◊î◊ï◊©◊ú◊û◊ï",
		overall_lb = "◊õ◊ú◊ú◊ô",
		weekly_lb = "◊©◊ë◊ï◊¢◊ô",
		new_lang = "<v>[#] <d>◊î◊©◊§◊î ◊î◊ï◊í◊ì◊®◊î ◊ú-◊¢◊ë◊®◊ô◊™",

		-- Power names
		balloon = "◊ë◊ú◊ï◊ü",
		masterBalloon = "◊û◊ê◊°◊ò◊® ◊ë◊ú◊ï◊ü",
		bubble = "◊ë◊ï◊¢◊î",
		fly = "◊™◊¢◊ï◊§◊î",
		snowball = "◊õ◊ì◊ï◊® ◊©◊ú◊í",
		speed = "◊û◊î◊ô◊®◊ï◊™",
		teleport = "◊©◊ô◊í◊ï◊®",
		smallbox = "◊ß◊ï◊§◊°◊ê ◊ß◊ò◊†◊î",
		cloud = "◊¢◊†◊ü",
		rip = "◊ß◊ë◊®",
		choco = "◊ß◊®◊© ◊©◊ï◊ß◊ï◊ú◊ì",
		bigBox = "◊ß◊ï◊§◊°◊ê ◊í◊ì◊ï◊ú◊î",
		trampoline = "◊ò◊®◊û◊§◊ï◊ú◊ô◊†◊î",
		toilet = "◊ê◊°◊ú◊î",
		pig = "◊ó◊ñ◊ô◊®",
		sink = "◊õ◊ô◊ï◊®",
		bathtub = "◊ê◊û◊ë◊ò◊ô◊î",
		campfire = "◊û◊ì◊ï◊®◊î",
		chair = "◊õ◊°◊ê",
	}
	--[[ End of file translations/parkour/he.lua ]]--
	--[[ File translations/parkour/br.lua ]]--
	translations.br = {
		name = "br",
		fullname = "Portugu√™s",

		-- Error messages
		corrupt_map = "<r>Mapa corrompido. Carregando outro.",
		corrupt_map_vanilla = "<r>[ERROR] <n>N√£o foi poss√≠vel obter informa√ß√µes deste mapa.",
		corrupt_map_mouse_start = "<r>[ERROR] <n>O mapa requer um ponto de partida (spawn).",
		corrupt_map_needing_chair = "<r>[ERROR] <n>O mapa requer a poltrona final.",
		corrupt_map_missing_checkpoints = "<r>[ERROR] <n>O mapa requer ao menos um checkpoint (prego amarelo).",
		corrupt_data = "<r>Infelizmente seus dados corromperam e foram reiniciados.",
		min_players = "<r>Para que dados sejam salvos, ao menos 4 jogadores √∫nicos devem estar na sala. <bl>[%s/%s]",
		tribe_house = "<r>Para que dados sejam salvos, voc√™ precisa jogar fora de um cafofo de tribo.",
		invalid_syntax = "<r>Sintaxe inv√°lida.",
		code_error = "<r>Um erro aconteceu: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Come√ßando desativa√ß√£o de emerg√™ncia, novos jogadores n√£o ser√£o mais permitidos. Por favor, v√° para outra sala #parkour.",
		leaderboard_not_loaded = "<r>O ranking ainda n√£o foi carregado. Aguarde um minuto.",
		max_power_keys = "<v>[#] <r>Voc√™ pode ter no m√°ximo %s poderes na mesma tecla.",

		-- Help window
		help = "Ajuda",
		staff = "Staff",
		rules = "Regras",
		contribute = "Contribuir",
		changelog = "Novidades",
		help_help = "<p align = 'center'><font size = '14'>Bem-vindo ao <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Seu objetivo √© chegar em todos os checkpoints at√© que voc√™ complete o mapa.</J></p>\n\n<N>‚Ä¢ Aperte <O>O</O>, digite <O>!op</O> ou clique no <O>bot√£o de configura√ß√£o</O> para abrir o <T>menu de op√ß√µes</T>.\n‚Ä¢ Aperte <O>P</O> ou clique no <O>√≠cone de m√£o</O> no parte superior direita para abrir o <T>menu de poderes</T>.\n‚Ä¢ Aperte <O>L</O> ou digite <O>!lb</O> parar abrir o <T>ranking</T>.\n‚Ä¢ Aperte <O>M</O> ou a tecla <O>Delete</O> para <T>/mort</T>, voc√™ pode alterar as teclas no moenu de <J>Op√ß√µes</J>.\n‚Ä¢ Para saber mais sobre nossa <O>staff</O> e as <O>regras do parkour</O>, clique nas abas <T>Staff</T> e <T>Regras</T>, respectivamente.\n‚Ä¢ Clique <a href='event:discord'><o>aqui</o></a> para obter um link de convide para o nosso servidor no Discord e <a href='event:map_submission'><o>aqui</o></a> para obter o link do t√≥pico de avalia√ß√£o de mapas.\n‚Ä¢ Use as setas <o>para cima</o> ou <o>para baixo</o> quando voc√™ precisar rolar a p√°gina.\n\n<p align = 'center'><font size = '13'><T>Contribui√ß√µes agora est√£o dispon√≠veis! Para mais detalhes, clique na aba <O>Contribuir</O>!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>AVISO: A staff do Parkour n√£o faz parte da staff do Transformice e n√£o tem nenhum poder no jogo em si, apenas no m√≥dulo.</r>\nStaff do Parkour assegura que o m√≥dulo rode com problemas m√≠nimos, e est√£o sempre dispon√≠veis para dar assist√™ncia aos jogadores quando necess√°rio.</font></p>\nVoc√™ pode digitar <D>!staff</D> no chat para ver a lista de staff.\n\n<font color = '#E7342A'>Administradores:</font> S√£o respons√°veis por manter o m√≥dulo propriamente dito, atualizando-o e corrigindo bugs.\n\n<font color = '#D0A9F0'>Gerenciadores das Equipes:</font> Observam as equipes de Modera√ß√£o e de Mapas, assegurando que todos est√£o fazendo um bom trabalho. Tamb√©m s√£o respons√°veis por recrutar novos membros para a staff.\n\n<font color = '#FFAAAA'>Moderadores:</font> S√£o respons√°veis por aplicar as regras no m√≥dulo e punir aqueles que n√£o as seguem.\n\n<font color = '#25C059'>Mappers:</font> S√£o respons√°veis por avaliar, adicionar e remover mapas do m√≥dulo para assegurar que voc√™ tenha uma jogatina divertida.",
		help_rules = "<font size = '13'><B><J>Todas as regras nos Termos e Condi√ß√µes de Uso do Transformice tamb√©m se aplicam no #parkour</J></B></font>\n\nSe voc√™ encontrar algum jogador quebrando-as, cochiche com um moderador do #parkour no jogo. Se os moderadores n√£o estiverem online, recomendamos que reporte em nosso servidor no Discord.\nAo reportar, por favor inclua a comunidade, o nome da sala e o nome do jogador.\n‚Ä¢ Ex: en-#parkour10 Blank#3495 trolling\nEvid√™ncias, como prints, v√≠deos e gifs s√£o √∫teis e apreciados, mas n√£o necess√°rios.\n\n<font size = '11'>‚Ä¢ Uso de <font color = '#ef1111'>hacks, glitches ou bugs</font> s√£o proibidos em salas #parkour\n‚Ä¢ <font color = '#ef1111'>Farm VPN</font> ser√° considerado um <B>abuso</B> e n√£o √© permitido. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nQualquer um pego quebrando as regras ser√° banido imediatamente.</B></font></p>\n\n<font size = '12'>Transformice permite trollar. No entanto, <font color='#cc2222'><B>n√£o permitiremos isso no parkour.</B></font></font>\n\n<p align = 'center'><J>Trollar √© quando um jogador intencionalmente usa seus poderes ou consum√≠veis para fazer com que outros jogadores n√£o consigam terminar o mapa.</j></p>\n‚Ä¢ Trollar por vingan√ßa <B>n√£o √© um motivo v√°lido</B> e voc√™ ainda ser√° punido.\n‚Ä¢ Insistir em ajudar jogadores que est√£o tentando terminar o mapa sozinhos e se recusando a parar quando pedido tamb√©m ser√° considerado trollar.\n‚Ä¢ <J>Se um jogador n√£o quer ajuda e prefere completar o mapa sozinho, d√™ seu melhor para ajudar os outros jogadores</J>. No entanto, se outro jogador que precisa de ajuda estiver no mesmo checkpoint daquele que quer completar sozinho, voc√™ pode ajudar ambos sem receber puni√ß√£o.\n\nSe um jogador √© pego trollando, ser√° punido em uma quest√£o de tempo. Note que trollar repetidamente ir√° fazer com que voc√™ receba puni√ß√µes gradativamente mais longas e/ou severas.",
		help_contribute = "<font size='14'>\n<p align='center'>A equipe do parkour adora ter um c√≥digo aberto, pois isso <t>ajuda a comunidade</t>. Voc√™ pode <o>ver</o> ou <o>contribuir</o> com o c√≥digo no <o><u><a href='event:github'>GitHub</a></u></o>.\n\nManter o m√≥dulo √© parte de um trabalho <t>volunt√°rio</t>, ent√£o qualquer contribui√ß√£o √© <u>bem vinda</u>, seja com a <t>programa√ß√£o</t>, <t>reporte de erros</t>, <t>sugest√µes</t> e <t>cria√ß√£o de mapas</t>.\nVoc√™ pode <vp>reportar erros</vp> ou <vp>dar sugest√µes</vp> no nosso <o><u><a href='event:discord'>Discord</a></u></o> e/ou no <o><u><a href='event:github'>GitHub</a></u></o>.\nVoc√™ pode <vp>enviar seus mapas</vp> no nosso <o><u><a href='event:map_submission'>T√≥pico no F√≥rum</a></u></o>.\n\nManter o jogo n√£o √© caro, mas tamb√©m n√£o √© gr√°tis. N√≥s adorar√≠amos se voc√™ pudesse incentivar o desenvolvimento do jogo <t>doando qualquer valor</t> <o><u><a href='event:donate'>aqui</a></u></o>.\n<u>Todos os fundos arrecadados ser√£o direcionados para o desenvolvimento do m√≥dulo.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Vers√£o 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ Implementado um <cep>sistema de recordes</cep>! Descubra-o j√° em <vp><u>*#parkour0records SeuNome#Tag</u></vp>\n‚Ä¢ Rota√ß√£o de mapas melhorada.\n‚Ä¢ Melhorada a verifica√ß√£o do <o><u><a href='event:discord'>Discord</a></u></o>.",

		-- Congratulation messages
		reached_level = "<d>Parab√©ns! Voc√™ atingiu o n√≠vel <vp>%s</vp>.",
		finished = "<d><o>%s</o> terminou o parkour em <vp>%s</vp> segundos, <fc>parab√©ns!",
		unlocked_power = "<ce><d>%s</d> desbloqueou o poder <vp>%s</vp>.",

		-- Information messages
		staff_power = "<r>A Staff do Parkour <b>n√£o</b> tem nenhum poder fora das salas #parkour.",
		donate = "<vp>Digite <b>!donate</b> se voc√™ gostaria de doar para este m√≥dulo!",
		paused_events = "<cep><b>[Aten√ß√£o!]</b> <n>O m√≥dulo est√° atingindo um estado cr√≠tico e est√° sendo pausado.",
		resumed_events = "<n2>O m√≥dulo est√° se normalizando.",
		welcome = "<n>Bem-vindo(a) ao <t>#parkour</t>!",
		module_update = "<r><b>[Aten√ß√£o!]</b> <n>O m√≥dulo ir√° atualizar em <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>O ranking foi carregado. Aperte L para abri-lo.",
		kill_minutes = "<R>Seus poderes foram desativados por %s minutos.",
		permbanned = "<r>Voc√™ foi banido permanentemente do #parkour.",
		tempbanned = "<r>Voc√™ foi banido do #parkour por %s minutos.",

		-- Records
		records_enabled = "<v>[#] <d>Modo Records est√° ativado nesta sala. Dados n√£o ser√£o contados e poderes n√£o est√£o ativados!\nVoc√™ poder√° encontrar mais informa√ß√µes sobre records em <b>%s</b>",
		records_admin = "<v>[#] <d>Voc√™ √© um administrador desta sala de records. Voc√™ pode usar os comandos <b>!map</b>, <b>!pw</b> e <b>!time</b>.",
		records_completed = "<v>[#] <d>Voc√™ completou o mapa! Se voc√™ quiser jogar nele novamente, digite <b>!redo</b>.",
		records_submit = "<v>[#] <d>Wow! Parece que voc√™ teve o melhor tempo nesta sala. Se voc√™ quiser enviar o record, digite <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>Parece que este mapa n√£o est√° na rota√ß√£o de mapas do parkour... Voc√™ n√£o pode enviar um recorde para ele",
		records_not_fastest = "<v>[#] <r>Parece que voc√™ n√£o √© o jogador mais r√°pido na sala...",
		records_already_submitted = "<v>[#] <r>Voc√™ j√° enviou seu recorde para este mapa!",
		records_submitted = "<v>[#] <d>Seu recorde para o mapa <b>%s</b> foi enviado.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Op√ß√µes do Parkour</font></p>\n\nUsar part√≠culas para os checkpoints\n\nUsar o teclado <b>QWERTY</b> (desativar caso seja <b>AZERTY</b>)\n\nUsar a tecla <b>M</b> como <b>/mort</b> (desativar caso seja <b>DEL</b>)\n\nMostrar o delay do seu poder\n\nMostrar o bot√£o de poderes\n\nMostrar o bot√£o de ajuda\n\nMostrar mensagens de mapa completado\n\nMostrar s√≠mbolo de n√£o ajudar",
		cooldown = "<v>[#] <r>Aguarde alguns segundos antes de fazer isso novamente.",
		power_options = ("<font size='13' face='Lucida Console'>Teclado <b>QWERTY</b>" ..
						 "\n\n<b>Esconder</b> contagem de mapas"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Complete <v>%s</v> mapas" ..
						"<font size='5'>\n\n</font>para desbloquear" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Complete <v>%s</v> mapas" ..
						"<font size='5'>\n\n</font>para evoluir para" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Seja top <v>%s</v>" ..
						"<font size='5'>\n\n</font>para desbloquear" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Seja top <v>%s</v>" ..
						"<font size='5'>\n\n</font>para evoluir para" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Mapas completados"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Ranking Geral"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>Ranking Semanal"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Medalhas (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>A contagem de mapas deste jogador √© privado. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Posi√ß√£o no Ranking geral: <b><v>%s</v></b>\n\n" ..
					"Posi√ß√£o no Ranking semanal: <b><v>%s</v></b>"),
		map_count = "Contagem de mapas: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Medalhas s√£o objetivos que um jogador pode conseguir. Clique nelas para ler suas descri√ß√µes.",
		help_private_maps = "Este jogador n√£o gosta de divulgar sua contagem de mapas publicamente! Voc√™ tamb√©m pode escond√™-la em seu perfil.",
		help_badge_1 = "Este jogador j√° foi um membro da staff do #parkour no passado.",
		help_badge_2 = "Este jogador est√° ou j√° esteve na p√°gina 1 do ranking global.",
		help_badge_3 = "Este jogador est√° ou j√° esteve na p√°gina 2 do ranking global.",
		help_badge_4 = "Este jogador est√° ou j√° esteve na p√°gina 3 do ranking global.",
		help_badge_5 = "Este jogador est√° ou j√° esteve na p√°gina 4 do ranking global.",
		help_badge_6 = "Este jogador est√° ou j√° esteve na p√°gina 5 do ranking global.",
		help_badge_7 = "Este jogador esteve no p√≥dio no fim de um ranking semanal.",
		help_badge_8 = "Este jogador bateu um recorde de 30 mapas por hora.",
		help_badge_9 = "Este jogador bateu um recorde de 35 mapas por hora.",
		help_badge_10 = "Este jogador bateu um recorde de 40 mapas por hora.",
		help_badge_11 = "Este jogador bateu um recorde de 45 mapas por hora.",
		help_badge_12 = "Este jogador bateu um recorde de 50 mapas por hora.",
		help_badge_13 = "Este jogador bateu um recorde de 55 mapas por hora.",
		help_badge_14 = "Este jogador verificou sua conta no servidor oficial do Parkour no Discord (digite <b>!discord</b>).",
		help_badge_15 = "Este jogador teve o tempo mais r√°pido em 1 mapa.",
		help_badge_16 = "Este jogador teve o tempo mais r√°pido em 5 mapas.",
		help_badge_17 = "Este jogador teve o tempo mais r√°pido em 10 mapas.",
		help_badge_18 = "Este jogador teve o tempo mais r√°pido em 15 mapas.",
		help_badge_19 = "Este jogador teve o tempo mais r√°pido em 20 mapas.",
		help_badge_20 = "Este jogador teve o tempo mais r√°pido em 25 mapas.",
		help_badge_21 = "Este jogador teve o tempo mais r√°pido em 30 mapas.",
		help_badge_22 = "Este jogador teve o tempo mais r√°pido em 35 mapas.",
		help_badge_23 = "Este jogador teve o tempo mais r√°pido em 40 mapas.",
		make_public = "tornar p√∫blico",
		make_private = "tornar privado",
		moderators = "Moderadores",
		mappers = "Mappers",
		managers = "Gerentes",
		administrators = "Administradores",
		close = "Fechar",
		cant_load_bot_profile = "<v>[#] <r>Voc√™ n√£o pode ver o perfil deste bot j√° que o #parkour utiliza-o internamente para funcionar devidamente.",
		cant_load_profile = "<v>[#] <r>O jogador <b>%s</b> parece estar offline ou n√£o existe.",
		like_map = "Voc√™ gosta deste mapa?",
		yes = "Sim",
		no = "N√£o",
		idk = "N√£o sei",
		unknown = "Desconhecido",
		powers = "Poderes",
		press = "<vp>Aperte %s",
		click = "<vp>Use click",
		ranking_pos = "Rank #%s",
		completed_maps = "<p align='center'><BV><B>Mapas completados: %s</B></p></BV>",
		leaderboard = "Ranking",
		position = "<V><p align=\"center\">Posi√ß√£o",
		username = "<V><p align=\"center\">Nome",
		community = "<V><p align=\"center\">Comunidade",
		completed = "<V><p align=\"center\">Mapas completados",
		overall_lb = "Geral",
		weekly_lb = "Semanal",
		new_lang = "<v>[#] <d>Idioma definido para Portugu√™s",

		-- Power names
		balloon = "Bal√£o",
		masterBalloon = "Bal√£o Mestre",
		bubble = "Bolha",
		fly = "Voar",
		snowball = "Bola de Neve",
		speed = "Velocidade",
		teleport = "Teleporte",
		smallbox = "Caixa Pequena",
		cloud = "Nuvem",
		rip = "L√°pide",
		choco = "Choco-t√°bua",
		bigBox = "Caixa grande",
		trampoline = "Trampolim",
		toilet = "Vaso Sanit√°rio",
		pig = "Porco",
		sink = "Pia",
		bathtub = "Banheira",
		campfire = "Fogueira",
		chair = "Cadeira",
	}
	translations.pt = translations.br
	--[[ End of file translations/parkour/br.lua ]]--
	--[[ File translations/parkour/en.lua ]]--
	translations.en = {
		name = "en",
		fullname = "English",

		-- Error messages
		corrupt_map = "<r>Corrupt map. Loading another.",
		corrupt_map_vanilla = "<r>[ERROR] <n>Can not get information of this map.",
		corrupt_map_mouse_start = "<r>[ERROR] <n>This map needs to have a start position (mouse spawn point).",
		corrupt_map_needing_chair = "<r>[ERROR] <n>The map needs to have the end chair.",
		corrupt_map_missing_checkpoints = "<r>[ERROR] <n>The map needs to have at least one checkpoint (yellow nail).",
		corrupt_data = "<r>Unfortunately, your data was corrupt and has been reset.",
		min_players = "<r>To save your data, there must be at least 4 unique players in the room. <bl>[%s/%s]",
		tribe_house = "<r>Data will not be saved in tribehouses.",
		invalid_syntax = "<r>Invalid syntax.",
		code_error = "<r>An error appeared: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Initiating emergency shutdown, no new players allowed. Please go to another #parkour room.",
		leaderboard_not_loaded = "<r>The leaderboard has not been loaded yet. Wait a minute.",
		max_power_keys = "<v>[#] <r>You can only have at most %s powers in the same key.",

		-- Help window
		help = "Help",
		staff = "Staff",
		rules = "Rules",
		contribute = "Contribute",
		changelog = "News",
		help_help = "<p align = 'center'><font size = '14'>Welcome to <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Your goal is to reach all the checkpoints until you complete the map.</J></p>\n\n<N>‚Ä¢ Press <O>O</O>, type <O>!op</O> or click the <O>configuration button</O> to open the <T>options menu</T>.\n‚Ä¢ Press <O>P</O> or click the <O>hand icon</O> at the top-right to open the <T>powers menu</T>.\n‚Ä¢ Press <O>L</O> or type <O>!lb</O> to open the <T>leaderboard</T>.\n‚Ä¢ Press the <O>M</O> or <O>Delete</O> key to <T>/mort</T>, you can toggle the keys in the <J>Options</J> menu.\n‚Ä¢ To know more about our <O>staff</O> and the <O>rules of parkour</O>, click on the <T>Staff</T> and <T>Rules</T> tab respectively.\n‚Ä¢ Click <a href='event:discord'><o>here</o></a> to get the discord invite link and <a href='event:map_submission'><o>here</o></a> to get the map submission topic link.\n‚Ä¢ Use <o>up</o> and <o>down</o> arrow keys when you need to scroll.\n\n<p align = 'center'><font size = '13'><T>Contributions are now open! For further details, click on the <O>Contribute</O> tab!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>DISCLAIMER: Parkour staff ARE NOT Transformice staff and DO NOT have any power in the game itself, only within the module.</r>\nParkour staff ensure that the module runs smoothly with minimal issues, and are always available to assist players whenever necessary.</font></p>\nYou can type <D>!staff</D> in the chat to see the staff list.\n\n<font color = '#E7342A'>Administrators:</font> They are responsible for maintaining the module itself by adding new updates and fixing bugs.\n\n<font color = '#D0A9F0'>Team Managers:</font> They oversee the Moderator and Mapper teams, making sure they are performing their jobs well. They are also responsible for recruiting new members to the staff team.\n\n<font color = '#FFAAAA'>Moderators:</font> They are responsible for enforcing the rules of the module and punishing individuals who do not follow them.\n\n<font color = '#25C059'>Mappers:</font> They are responsible for reviewing, adding, and removing maps within the module to ensure that you have an enjoyable gameplay.",
		help_rules = "<font size = '13'><B><J>All rules in the Transformice Terms and Conditions also apply to #parkour</J></B></font>\n\nIf you find any player breaking these rules, whisper the parkour mods in-game. If no mods are online, then it is recommended to report it in the discord server.\nWhen reporting, please include the server, room name, and player name.\n‚Ä¢ Ex: en-#parkour10 Blank#3495 trolling\nEvidence, such as screenshots, videos and gifs are helpful and appreciated, but not necessary.\n\n<font size = '11'>‚Ä¢ No <font color = '#ef1111'>hacks, glitches or bugs</font> are to be used in #parkour rooms\n‚Ä¢ <font color = '#ef1111'>VPN farming</font> will be considered an <B>exploit</B> and is not allowed. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nAnyone caught breaking these rules will be immediately banned.</B></font></p>\n\n<font size = '12'>Transformice allows the concept of trolling. However, <font color='#cc2222'><B>we will not allow it in parkour.</B></font></font>\n\n<p align = 'center'><J>Trolling is when a player intentionally uses their powers or consumables to prevent other players from finishing the map.</j></p>\n‚Ä¢ Revenge trolling is <B>not a valid reason</B> to troll someone and you will still be punished.\n‚Ä¢ Forcing help onto players trying to solo the map and refusing to stop when asked is also considered trolling.\n‚Ä¢ <J>If a player does not want help or prefers to solo a map, please try your best to help other players</J>. However if another player needs help in the same checkpoint as the solo player, you can help them [both].\n\nIf a player is caught trolling, they will be punished on a time basis. Note that repeated trolling will lead to longer and more severe punishments.",
		help_contribute = "<font size='14'>\n<p align='center'>The parkour management team loves open source code because it <t>helps the community</t>. You can <o>view</o> and <o>modify</o> the source code on <o><u><a href='event:github'>GitHub</a></u></o>.\n\nMaintaining the module is <t>strictly voluntary</t>, so any help regarding <t>code</t>, <t>bug reports</t>, <t>suggestions</t> and <t>creating maps</t> is always <u>welcome and appreciated</u>.\nYou can <vp>report bugs</vp> and <vp>give suggestions</vp> on <o><u><a href='event:discord'>Discord</a></u></o> and/or <o><u><a href='event:github'>GitHub</a></u></o>.\nYou can <vp>submit your maps</vp> in our <o><u><a href='event:map_submission'>Forum Thread</a></u></o>.\n\nMaintaining parkour is not expensive, but it is not free either. We'd love if you could help us by <t>donating any amount</t> <o><u><a href='event:donate'>here</a></u></o>.\n<u>All donations will go towards improving the module.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Version 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ Implemented a <cep>records system</cep>! Go check it out at <vp><u>*#parkour0records YourName#Tag</u></vp>\n‚Ä¢ Improved map rotation.\n‚Ä¢ Improved <o><u><a href='event:discord'>Discord</a></u></o> verification.",

		-- Congratulation messages
		reached_level = "<d>Congratulations! You've reached level <vp>%s</vp>.",
		finished = "<d><o>%s</o> finished the parkour in <vp>%s</vp> seconds, <fc>congratulations!",
		unlocked_power = "<ce><d>%s</d> unlocked the <vp>%s</vp> power.",

		-- Information messages
		staff_power = "<p align='center'><font size='12'><r>Parkour staff <b>do not</b> have any power outside of #parkour rooms.",
		donate = "<vp>Type <b>!donate</b> if you would like to donate for this module!",
		paused_events = "<cep><b>[Warning!]</b> <n>The module has reached it's critical limit and is being paused.",
		resumed_events = "<n2>The module has been resumed.",
		welcome = "<n>Welcome to <t>#parkour</t>!",
		module_update = "<r><b>[Warning!]</b> <n>The module will update in <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>The leaderboard has been loaded. Press L to open it.",
		kill_minutes = "<R>Your powers have been disabled for %s minutes.",
		permbanned = "<r>You have been permanently banned from #parkour.",
		tempbanned = "<r>You have been banned from #parkour for %s minutes.",

		-- Records
		records_enabled = "<v>[#] <d>Records mode is enabled in this room. Stats won't count and powers aren't enabled!\nYou can find more information about records in <b>%s</b>",
		records_admin = "<v>[#] <d>You're an administrator of this records room. You can use the commands <b>!map</b>, <b>!pw</b> and <b>!time</b>.",
		records_completed = "<v>[#] <d>You've completed the map! If you would like to re-do it, type <b>!redo</b>.",
		records_submit = "<v>[#] <d>Wow! Looks like you had the fastest time in the room. If you would like to submit your record, type <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>Looks like this map is not in parkour rotation... You can't submit a record for it!",
		records_not_fastest = "<v>[#] <r>Looks like you're not the fastest player in the room...",
		records_already_submitted = "<v>[#] <r>You already submitted your record for this map!",
		records_submitted = "<v>[#] <d>Your record for the map <b>%s</b> has been submitted.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Parkour Options</font></p>\n\nUse particles for checkpoints\n\nUse <b>QWERTY</b> keyboard (disable if <b>AZERTY</b>)\n\nUse <b>M</b> hotkey for <b>/mort</b> (disable for <b>DEL</b>)\n\nShow your power cooldowns\n\nShow powers button\n\nShow help button\n\nShow map completion announcements\n\nShow no help symbol",
		cooldown = "<v>[#] <r>Wait a few seconds before doing that again.",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> keyboard" ..
						 "\n\n<b>Hide</b> map count"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Complete <v>%s</v> maps" ..
						"<font size='5'>\n\n</font>to unlock" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Complete <v>%s</v> maps" ..
						"<font size='5'>\n\n</font>to upgrade to" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Rank <v>%s</v>" ..
						"<font size='5'>\n\n</font>to unlock" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Rank <v>%s</v>" ..
						"<font size='5'>\n\n</font>to upgrade to" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Completed Maps"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Overall Leaderboard"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>Weekly Leaderboard"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Badges (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>This player's map count is private. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Overall leaderboard position: <b><v>%s</v></b>\n\n" ..
					"Weekly leaderboard position: <b><v>%s</v></b>"),
		map_count = "Map count: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Badges are accomplishments a player can get. Click over them to see their description.",
		help_private_maps = "This player doesn't like to share their map count publicly! You can hide them too in your profile.",
		help_yellow_maps = "Maps in yellow are the maps completed this week.",
		help_red_maps = "Maps in red are the maps completed in the past hour.",
		help_badge_1 = "This player has been a parkour staff member in the past.",
		help_badge_2 = "This player is or was in the page 1 of the overall leaderboard.",
		help_badge_3 = "This player is or was in the page 2 of the overall leaderboard.",
		help_badge_4 = "This player is or was in the page 3 of the overall leaderboard.",
		help_badge_5 = "This player is or was in the page 4 of the overall leaderboard.",
		help_badge_6 = "This player is or was in the page 5 of the overall leaderboard.",
		help_badge_7 = "This player has been in the podium of the weekly leaderboard when it has reset.",
		help_badge_8 = "This player has got a record of 30 maps per hour.",
		help_badge_9 = "This player has got a record of 35 maps per hour.",
		help_badge_10 = "This player has got a record of 40 maps per hour.",
		help_badge_11 = "This player has got a record of 45 maps per hour.",
		help_badge_12 = "This player has got a record of 50 maps per hour.",
		help_badge_13 = "This player has got a record of 55 maps per hour.",
		help_badge_14 = "This player has verified their discord account in the official parkour server (type <b>!discord</b>).",
		help_badge_15 = "This player has got the fastest time in 1 map.",
		help_badge_16 = "This player has got the fastest time in 5 maps.",
		help_badge_17 = "This player has got the fastest time in 10 maps.",
		help_badge_18 = "This player has got the fastest time in 15 maps.",
		help_badge_19 = "This player has got the fastest time in 20 maps.",
		help_badge_20 = "This player has got the fastest time in 25 maps.",
		help_badge_21 = "This player has got the fastest time in 30 maps.",
		help_badge_22 = "This player has got the fastest time in 35 maps.",
		help_badge_23 = "This player has got the fastest time in 40 maps.",
		make_public = "make public",
		make_private = "make private",
		moderators = "Moderators",
		mappers = "Mappers",
		managers = "Managers",
		administrators = "Administrators",
		close = "Close",
		cant_load_bot_profile = "<v>[#] <r>You can't see this bot's profile since #parkour uses it internally to work properly.",
		cant_load_profile = "<v>[#] <r>The player <b>%s</b> seems to be offline or does not exist.",
		like_map = "Do you like this map?",
		yes = "Yes",
		no = "No",
		idk = "I don't know",
		unknown = "Unknown",
		powers = "Powers",
		press = "<vp>Press %s",
		click = "<vp>Left click",
		ranking_pos = "Rank #%s",
		completed_maps = "<p align='center'><BV><B>Completed maps: %s</B></p></BV>",
		leaderboard = "Leaderboard",
		position = "<V><p align=\"center\">Position",
		username = "<V><p align=\"center\">Username",
		community = "<V><p align=\"center\">Community",
		completed = "<V><p align=\"center\">Completed maps",
		overall_lb = "Overall",
		weekly_lb = "Weekly",
		new_lang = "<v>[#] <d>Language set to English",

		-- Power names
		balloon = "Balloon",
		masterBalloon = "Master Ballon",
		bubble = "Bubble",
		fly = "Fly",
		snowball = "Snowball",
		speed = "Speed",
		teleport = "Teleport",
		smallbox = "Small box",
		cloud = "Cloud",
		rip = "Tombstone",
		choco = "Chocoplank",
		bigBox = "Big box",
		trampoline = "Trampoline",
		toilet = "Toilet",
		pig = "Pig",
		sink = "Sink",
		bathtub = "Bathtub",
		campfire = "Campfire",
		chair = "Chair",
	}
	--[[ End of file translations/parkour/en.lua ]]--
	--[[ File translations/parkour/pl.lua ]]--
	translations.pl = {
		name = "pl",
		fullname = "Polski",

		-- Error messages
		corrupt_map = "<r>Zepsuta mapa. ≈Åadowanie innƒÖ.",
		corrupt_map_vanilla = "<r>[B≈ÅƒÑD] <n>Nie mo≈ºna uzyskaƒá informacji o tej mapie.",
		corrupt_map_mouse_start = "<r>[B≈ÅƒÑD] <n>Ta mapa musi mieƒá pozycjƒô poczƒÖtkowƒÖ (punkt odradzania myszy).",
		corrupt_map_needing_chair = "<r>[B≈ÅƒÑD] <n>Mapa musi mieƒá ko≈Ñcowy fotel.",
		corrupt_map_missing_checkpoints = "<r>[B≈ÅƒÑD] <n>Mapa musi mieƒá co najmniej jeden punkt kontrolny (≈º√≥≈Çty gw√≥≈∫d≈∫).",
		corrupt_data = "<r>Niestety Twoje dane zosta≈Çy uszkodzone i zosta≈Çy zresetowane.",
		min_players = "<r>Aby zapisaƒá dane, w pokoju musi byƒá co najmniej 4 graczy. <bl>[%s/%s]",
		tribe_house = "<r>Dane nie bƒôdƒÖ zapisywane w plemionach.",
		invalid_syntax = "<r>Niepoprawna sk≈Çadnia.",
		code_error = "<r>WystƒÖpi≈Ç b≈ÇƒÖd: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Inicjowanie wy≈ÇƒÖczenia awaryjnego, nowi gracze nie sƒÖ dozwoleni. Przejd≈∫ do innego pokoju #parkour.",
		leaderboard_not_loaded = "<r>Tabela lider√≥w nie zosta≈Ça jeszcze za≈Çadowana. Poczekaj minutƒô.",
		max_power_keys = "<v>[#] <r>Mo≈ºesz mieƒá co najwy≈ºej %s moce w tym samym kluczu. ",

		-- Help window
		help = "Pomoc",
		staff = "Obs≈Çuga",
		rules = "Zasady",
		contribute = "Udzia≈Ç",
		changelog = "Aktualno≈õci",
		help_help = "<p align = 'center'><font size = '14'>Witamy w <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Twoim celem jest dotarcie do wszystkich punkt√≥w kontrolnych, dop√≥ki nie uko≈Ñczysz mapy.</J></p>\n\n<N>‚Ä¢ Naci≈õnij <O>O</O>, napisz <O>!op</O> Lub kliknij <O>przycisk konfiguracji</O> aby otworzyƒá <T>menu opcji</T>.\n‚Ä¢ Naci≈õnij <O>P</O> lub kliknij <O>ikonƒô d≈Çoni</O> w prawym g√≥rnym rogu, aby otworzyƒá <T>menu mocy</T>.\n‚Ä¢ Naci≈õnij <O>L</O> lub napisz <O>!lb</O> aby otworzyƒá <T>tabelƒô wynik√≥w</T>.\n‚Ä¢ Naci≈õnij <O>M</O> lub <O>Delete</O> klawisz do <T>/mort</T>, mo≈ºesz prze≈ÇƒÖczaƒá klawisze w <J>Options</J> menu.\n‚Ä¢ Aby dowiedzieƒá siƒô wiƒôcej o naszym <O>personelu</O> oraz <O>zasadach na parkourze</O>, kliknij na <T>obs≈Çugƒô</T> i <T>zasady</T> .\n‚Ä¢ Kliknij <a href='event:discord'><o>tutaj</o></a> aby uzyskaƒá link zapraszajƒÖcy zgodny i <a href='event:map_submission'><o>tutaj</o></a> aby uzyskaƒá link do tematu przesy≈Çania mapy.\n‚Ä¢ U≈ºyj strza≈Çki w <o>g√≥re</o> i w <o>d√≥≈Ç</o>, kiedy musisz przewijaƒá.\n\n<p align = 'center'><font size = '13'><T>Udzia≈Çy sƒÖ teraz otwarte! Aby uzyskaƒá wiƒôcej informacji, kliknij <O>Udzia≈Ç</O>!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>WYJA≈öNIAMY: Personel Parkour NIE JEST personelem Transformice i NIE MA ≈ºadnej mocy w samej grze, tylko w module.</r>\nPersonel w Parkour zapewnnia, ≈ºe modu≈Ç dzia≈Ça p≈Çynnie przy minimalnych problemach i sƒÖ zawsze dostƒôpni, aby pom√≥c graczom w razie potrzeby.</font></p>\nAby zobaczyƒá listƒô aktywnych os√≥b z personelu napisz <D>!staff</D> na czacie.\n\n<font color = '#E7342A'>Administratorzy:</font> SƒÖ odpowiedzialni za utrzymanie samego modu≈Çu poprzez dodawanie nowych aktualizacji i naprawianie b≈Çƒôd√≥w.\n\n<font color = '#D0A9F0'>Kierownicy zespo≈Ç√≥w:</font> NadzorujƒÖ zespo≈Çy moderator√≥w i tw√≥rc√≥w map, upewniajƒÖc siƒô, ≈ºe dobrze wykonujƒÖ swoje zadania. OdpowiadajƒÖ r√≥wnie≈º za rekrutacjƒô nowych cz≈Çonk√≥w do zespo≈Çu pracownik√≥w.\n\n<font color = '#FFAAAA'>Moderatoratorzy:</font> SƒÖ odpowiedzialni za egzekwowanie zasad modu≈Çu i karanie os√≥b, kt√≥re ich nie przestrzegajƒÖ.\n\n<font color = '#25C059'>Mapperzy:</font> SƒÖ odpowiedzialni za przeglƒÖdanie, dodawanie i usuwanie map w modu≈Çach, aby zapewniƒá przyjemnƒÖ rozgrywkƒô.",
		help_rules = "<font size = '13'><B><J>Wszystkie zasady zawarte w Regulaminie Transformice dotyczƒÖ r√≥wnie≈º #parkour</J></B></font>\n\nJe≈õli zauwa≈ºysz, ≈ºe jaki≈õ gracz ≈Çamie te zasady, napisz do moderator√≥w parkour w grze. Je≈ºeli nie ma moderator√≥w w grze to zaleca siƒô zg≈Çosiƒá na serwerze w discordzie.\nPodczas zg≈Çaszania prosimy o podanie serwera, nazwy pokoju i nazwy gracza.\n‚Ä¢ Na przyk≈Çad: en-#parkour10 Blank#3495 trolling\nDowody, takie jak zrzuty ekranu, filmy i gify, sƒÖ pomocne i doceniane, ale nie sƒÖ konieczne.\n\n<font size = '11'>‚Ä¢ Zakazane jest u≈ºywanie: <font color = '#ef1111'>hack, usterek oraz b≈Çƒôd√≥w.</font>\n‚Ä¢ <font color = '#ef1111'>VPN farmowanie</font> bƒôdzie uwa≈ºany za <B>wykorzystywanie</B> i nie jest dozwolone. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nKa≈ºdy przy≈Çapany na ≈Çamaniu tych zasad zostanie natychmiast zbanowany.</B></font></p>\n\n<font size = '12'>Transformice zezwala na trollowanie. Jednak, <font color='#cc2222'><B> zabronione jest to na  w parkourze.</B></font></font>\n\n<p align = 'center'><J>Trolling ma miejsce, gdy gracz celowo u≈ºy≈Ç swoich mocy lub materia≈Ç√≥w eksploatacyjnych, aby uniemo≈ºliwiƒá innym graczom uko≈Ñczenie mapy.</j></p>\n‚Ä¢Trolling w ka≈ºdej formie jest zabroniony nie wa≈ºne czy w formie <B>zemsty czy zabawy</B>.\n‚Ä¢ Za trollowanie uwa≈ºa siƒô r√≥wnie≈º wymuszanie pomocy gdy gracz sam pr√≥buje przej≈õƒá mapƒô i prosi aby≈õ przesta≈Ç mu pomagaƒá a ty odmawiasz.\n‚Ä¢ <J>Je≈õli gracz nie chce pomocy lub woli uko≈Ñczyƒá sam mape, postaraj siƒô pom√≥c innym graczom</J>. Je≈õli jednak inny gracz potrzebuje pomocy w tym samym punkcie kontrolnym, co gracz solo, mo≈ºesz im pom√≥c [obu].\n\nJe≈õli gracz zostanie przy≈Çapany na trollowaniu, zostanie ukarany na czas. Pamiƒôtaj, ≈ºe wielokrotne trollowanie doprowadzi do d≈Çu≈ºszych i surowszych kar.",
		help_contribute = "<font size='14'>\n<p align='center'>Zesp√≥≈Ç zarzƒÖdzajƒÖcy w parkour uwielbia otwarte kody, poniewa≈º <t>pomagajƒÖ spo≈Çeczno≈õci</t>. Mo≈ºesz <o>zobaczyƒá</o> i <o>modyfikowaƒá</o> kod ≈∫r√≥d≈Çowy na <o><u><a href='event:github'>GitHub</a></u></o>.\n\nUtrzymanie modu≈Çu jest <t>dobrowolne</t>, wiƒôc wszelka pomoc dotyczƒÖca <t>kod√≥w</t>, <t>zg≈Çaszania b≈Çƒôd√≥w</t>, <t>propozycje</t> oraz <t>tworzenie map</t> jest zawsze <u>mile widziane i doceniane</u>.\nMo≈ºesz <vp>zg≈Çaszaƒá b≈Çƒôdy</vp> oraz <vp>daƒá propozycje</vp> na <o><u><a href='event:discord'>Discord</a></u></o> lub <o><u><a href='event:github'>GitHub</a></u></o>.\n<vp>Swoje mapy mo≈ºesz przesy≈Çaƒá</vp> w naszym <o><u><a href='event:map_submission'>wƒÖtku na forum</a></u></o>.\n\nUtrzymanie parkour nie jest drogie, ale te≈º nie darmowe. Mo≈ºesz nam pom√≥c <t>przekazujƒÖc dowolnƒÖ kwotƒô</t> <o><u><a href='event:donate'>tutaj</a></u></o>.\n<u>Wszystkie darowizny zostanƒÖ przeznaczone na ulepszenie modu≈Çu.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Verzi√≥ 2.6.0 - 2020/10/01</o></p>\n\n<font size='11'>‚Ä¢ Megval√≥sult egy <cep>rekord rendszer</cep>! N√©zd meg itt: <vp><u>*#parkour0records J√°t√©kosNeved#Tag</u></vp>\n‚Ä¢ Jav√≠tott p√°lya k√∂rforg√°s.\n‚Ä¢ Jav√≠tott <o><u><a href='event:discord'>Discord</a></u></o> ellen≈ërz√©s.",

		-- Congratulation messages
		reached_level = "<d>Gratulacje! OsiƒÖgnƒÖ≈Çe≈õ poziom <vp>%s</vp>.",
		finished = "<d><o>%s</o> sko≈Ñczy≈Çe≈õ parkour w <vp>%s</vp> sekundach, <fc>Gratulacje!",
		unlocked_power = "<ce><d>%s</d> odblokowa≈Ç <vp>%s</vp> moc.",

		-- Information messages
		staff_power = "<r>Parkour staff <b>nie</b> majƒÖ jakƒÖkolwiek moc poza #parkour pokoj√≥w.",
		donate = "<vp>Wpisz <b>!donate</b>, je≈õli chcesz przekazaƒá darowiznƒô na ten modu≈Ç!",
		paused_events = "<cep><b>[Uwaga!]</b> <n>Modu≈Ç osiƒÖgnƒÖ≈Ç limit krytyczny i jest wstrzymywany.",
		resumed_events = "<n2>Modu≈Ç zosta≈Ç wznowiony.",
		welcome = "<n>Witamy w <t>#parkour</t>!",
		module_update = "<r><b>[Uwaga!]</b> <n>Modu≈Ç zaktualizuje siƒô za <d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>Tablica wynik√≥w zosta≈Ça za≈Çadowana. Naci≈õnij L, aby go otworzyƒá.",
		kill_minutes = "<R>Twoje moce zosta≈Çy wy≈ÇƒÖczone w %s minut.",
		permbanned = "<r>Zosta≈Çe≈õ trwale zbanowany #parkour.",
		tempbanned = "<r>Zosta≈Çe≈õ zbanowany z #parkour na %s minut.",

		-- Records
		records_enabled = "<v>[#] <d> W tym pokoju w≈ÇƒÖczony jest tryb nagrywania.  Statystyki siƒô nie liczƒÖ, a uprawnienia nie sƒÖ w≈ÇƒÖczone!\nWiƒôcej informacji na temat rekord√≥w mo≈ºna znale≈∫ƒá w <b>%s</b>",
		records_admin = "<v>[#] <d>Jeste≈õ administratorem tego pokoju z aktami.  Mo≈ºesz u≈ºyƒá polece≈Ñ <b>!map</b>, <b>!pw</b> and <b>!time</b>.",
		records_completed = "<v>[#] <d>Uko≈Ñczy≈Çe≈õ mapƒô!  Je≈õli chcesz to zrobiƒá ponownie, wpisz <b>!redo</b>.",
		records_submit = "<v>[#] <d>≈Åa≈Ç! WyglƒÖda na to, ≈ºe mia≈Çe≈õ najszybszy czas w pokoju. Je≈õli chcesz przes≈Çaƒá sw√≥j rekord, wpisz <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>WyglƒÖda na to, ≈ºe na tej mapie nie ma rotacji parkour... Nie mo≈ºesz przes≈Çaƒá jej rekordu!",
		records_not_fastest = "<v>[#] <r>WyglƒÖda na to, ≈ºe nie jeste≈õ najszybszym graczem w pokoju...",
		records_already_submitted = "<v>[#] <r>Ju≈º przes≈Ça≈Çe≈õ sw√≥j rekord dla tej mapy!",
		records_submitted = "<v>[#] <d>Tw√≥j rekord na mapie <b>%s</b> zosta≈Çy przes≈Çane.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Parkour Opcje</font></p>\n\nU≈ºyj czƒÖstek jako punkt√≥w kontrolnych\n\nU≈ºyj <b>QWERTY</b> klawiatura (wy≈ÇƒÖcz je≈õli <b>AZERTY</b>)\n\nU≈ºyj klawisza<b>M</b> zamiast <b>/mort</b> (wy≈ÇƒÖcz <b>DEL</b>)\n\nPoka≈º swoje czasy odnowienia mocy\n\nPoka≈º przycisk mocy\n\nPoka≈º przycisk pomocy\n\nPoka≈º og≈Çoszenia o uko≈Ñczeniu mapy\n\nPoka≈º symbol bez pomocy",
		cooldown = "<v>[#] <r>Poczekaj kilka sekund, zanim zrobisz to ponownie.",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> klawiatura" ..
						 "\n\n<b>Ukryƒá</b> map liczb"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Uko≈Ñczyƒá <v>%s</v> mapƒô" ..
						"<font size='5'>\n\n</font>odblokowaƒá" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Uko≈Ñczyƒá<v>%s</v> mapƒô" ..
						 "<font size='5'>\n\n</font>uaktualniƒá do" ..
						 "<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Ranga<v>%s</v>" ..
							 "<font size='5'>\n\n</font>odblokowaƒá" ..
							 "<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Ranga <v>%s</v>" ..
							 "<font size='5'>\n\n</font>uaktualniƒá do" ..
							 "<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Uko≈Ñczone mapy"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Og√≥lny ranking"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>Tygodniowa tablica wynik√≥w"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Odznaki (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>Liczba map tego gracza jest prywatna. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Og√≥lna pozycja w tabeli lider√≥w: <b><v>%s</v></b>\n\n" ..
					"Tygodniowa pozycja w tabeli lider√≥w: <b><v>%s</v></b>"),
		map_count = "Map count: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Odznaki to osiƒÖgniƒôcie, kt√≥re gracz mo≈ºe zdobyƒá. Kliknij je, aby zobaczyƒá ich opis.",
		help_private_maps = "Ten gracz nie lubi publicznie udostƒôpniaƒá liczby swoich map! Mo≈ºesz je r√≥wnie≈º ukryƒá w swoim profilu.",
		help_badge_1 = "Ten gracz by≈Ç w przesz≈Ço≈õci cz≈Çonkiem zespo≈Çu parkour. ",
		help_badge_2 = "Ten gracz jest lub by≈Ç na pierwszej stronie og√≥lnej tabeli wynik√≥w.",
		help_badge_3 = "Ten gracz jest lub by≈Ç na stronie 2 og√≥lnej tabeli wynik√≥w.",
		help_badge_4 = "Ten gracz jest lub by≈Ç na stronie 3 og√≥lnej tabeli wynik√≥w.",
		help_badge_5 = "Ten gracz jest lub by≈Ç na stronie 4 og√≥lnej tabeli wynik√≥w.",
		help_badge_6 = "Ten gracz jest lub by≈Ç na stronie 5 og√≥lnej tabeli wynik√≥w.",
		help_badge_7 = "Ten gracz by≈Ç na podium na koniec tygodniowej tabeli lider√≥w.",
		help_badge_8 = "Ten gracz ma rekord 30 map na godzinƒô.",
		help_badge_9 = "Ten gracz ma rekord 35 map na godzinƒô.",
		help_badge_10 = "Ten gracz ma rekord 40 map na godzinƒô.",
		help_badge_11 = "Ten gracz ma rekord 45 map na godzinƒô.",
		help_badge_12 = "Ten gracz ma rekord 50 map na godzinƒô.",
		help_badge_13 = "Ten gracz ma rekord 55 map na godzinƒô.",
		help_badge_14 = "Ten gracz zweryfikowa≈Ç swoje konto na Discordzie w oficjalnym serwisie Discorda (napisz <b>!discord</b>).",
		help_badge_15 = "Ten gracz uzyska≈Ç najszybszy czas na 1 mapie.",
		help_badge_16 = "Ten gracz uzyska≈Ç najszybszy czas na 5 map.",
		help_badge_17 = "Ten gracz uzyska≈Ç najszybszy czas na 10 map.",
		help_badge_18 = "Ten gracz uzyska≈Ç najszybszy czas na 15 map.",
		help_badge_19 = "Ten gracz uzyska≈Ç najszybszy czas na 20 map.",
		help_badge_20 = "Ten gracz uzyska≈Ç najszybszy czas na 25 map.",
		help_badge_21 = "Ten gracz uzyska≈Ç najszybszy czas na 30 map.",
		help_badge_22 = "Ten gracz uzyska≈Ç najszybszy czas na 35 map.",
		help_badge_23 = "Ten gracz uzyska≈Ç najszybszy czas na 40 map.",
		make_public = "robiƒá publicznie",
		make_private = "robiƒá prywatnie",
		moderators = "Moderatorzy",
		mappers = "Maperzy",
		managers = "Mened≈ºerowie",
		administrators = "Administratorzy",
		close = "Zamknij",
		cant_load_bot_profile = "<v>[#] <r>Nie mo≈ºesz zobaczyƒá profilu tego bota, poniewa≈º #parkour u≈ºywa go wewnƒôtrznie do prawid≈Çowego dzia≈Çania.",
		cant_load_profile = "<v>[#] <r>Gracz <b>%s</b> wydaje siƒô byƒá offline lub nie istnieje.",
		like_map = "Podoba ci siƒô ta mapa?",
		yes = "Tak",
		no = "Nie",
		idk = "Nie wiem",
		unknown = "Nieznany",
		powers = "Moce",
		press = "<vp>Naci≈õnij %s",
		click = "<vp>Lewy przycisk",
		ranking_pos = "Rang #%s",
		completed_maps = "<p align='center'><BV><B>Uko≈Ñczone mapy: %s</B></p></BV>",
		leaderboard = "Tabela lider√≥w",
		position = "<V><p align=\"center\">Pozycja",
		username = "<V><p align=\"center\">Nazwa",
		community = "<V><p align=\"center\">Spo≈Çeczno≈õƒá",
		completed = "<V><p align=\"center\">Uko≈Ñczone mapy",
		overall_lb = "Og√≥lnie",
		weekly_lb = "Co tydzie≈Ñ",
		new_lang = "<v>[#] <d>Zestaw jƒôzykowy do Polski",

		-- Power names
		balloon = "Balon",
		masterBalloon = "Master Balon",
		bubble = "Ba≈Ñka",
		fly = "Latanie",
		snowball = "≈önie≈ºka",
		speed = "Prƒôdko≈õƒá",
		teleport = "Teleport",
		smallbox = "Ma≈Çe pude≈Çko",
		cloud = "Chmurka",
		rip = "Gr√≥b",
		choco = "Deska czekoladowa",
		bigBox = "Du≈ºe pud≈Ço",
		trampoline = "Trampolina",
		toilet = "Toaleta",
		pig = "≈öwinka",
		sink = "Umywalka",
		bathtub = "Wanna",
		campfire = "Ognisko",
		chair = "Krzes≈Ço",
	}
	--[[ End of file translations/parkour/pl.lua ]]--
	--[[ File translations/parkour/fr.lua ]]--
	translations.fr = {
		name = "fr",
		fullname = "Fran√ßais",

		-- Error messages
		corrupt_map = "<r>Carte non op√©rationnelle. Chargement d'une autre.",
		corrupt_map_vanilla = "<r>[ERROR] <n>Impossible de r√©colter les informations de cette carte.",
		corrupt_map_mouse_start = "<r>[ERROR] <n>Cette carte a besoin d'un point d'apparition (pour les souris).",
		corrupt_map_needing_chair = "<r>[ERROR] <n>La carte a besoin d'une chaise d'arriv√©e (point final).",
		corrupt_map_missing_checkpoints = "<r>[ERROR] <n>La carte √† besoin d'au moins un point de sauvegarde (√©toiles jaunes).",
		corrupt_data = "<r>Malheureusement, vos donn√©es ont √©t√© corrompues et ont √©t√© effac√©es.",
		min_players = "<r>Pour sauvegarder vos donn√©es, il doit y avoir au moins 4 souris dans le salon. <bl>[%s/%s]",
		tribe_house = "<r>Les donn√©es ne sont pas sauvegard√©es dans les maisons de tribus.",
		invalid_syntax = "<r>Syntaxe invalide.",
		code_error = "<r>Une erreur est survenue: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Mise en place du blocage d'urgence, aucun nouveau joueur ne peut rejoindre. Merci d'aller dans un autre salon #parkour.",
		leaderboard_not_loaded = "<r>Le tableau des scores n'a pas √©t√© encore charg√©. Attendez une minute.",
		max_power_keys = "<v>[#] <r>Vous pouvez avoir maximum %s pouvoirs sur la m√™me touche.",

		-- Help window
		help = "Aide",
		staff = "Staff",
		rules = "R√®gles",
		contribute = "Contribuer",
		changelog = "Changements",
		help_help = "<p align = 'center'><font size = '14'>Bienvenue √† <T>#parkour!</T></font>\n\n<font size = '12'><J>Votre but est d'atteindre tous les points de sauvegarde pour finir la carte.</J></font></p>\n\n<font size = '11'><N>‚Ä¢ Appuyez sur <O>O</O>, √©crivez <O>!op</O> ou cliquez le <O>bouton de configuration</O> pour ouvrir le <T>menu des options</T>.\n‚Ä¢ Appuyez sur <O>P</O> ou cliquez l'<O>ic√¥ne de main</O> en haut √† droite pour ouvrir le <T>menu des pouvoirs</T>.\n‚Ä¢ Appuyez sur <O>L</O> ou √©crivez <O>!lb</O> pour ouvrir le <T>tableau des scores</T>.\n‚Ä¢ Utilisez la touche <O>M</O> ou la touche <O>Suppr.</O> comme un raccourci de <T>/mort</T>, vous pouvez personnaliser les touches dans le menu des <J>Options</J>.\n‚Ä¢ Pour en savoir plus √† propos de notre <O>staff</O> et des <O>r√®gles de parkour</O>, cliquez sur les pages respectives du <T>Staff</T> et des <T>R√®gles</T>.\n‚Ä¢ Cliquez <a href='event:discord'><o>ici</o></a> pour avoir le lien d'invitation pour le discord et <a href='event:map_submission'><o>ici</o></a> pour avoir le lien de soumission de cartes.\n‚Ä¢ Utilisez les fl√®ches d'<o>en haut</o> et d'<o>en bas</o> quand vous avez besoin de scroller.\n\n<p align = 'center'><font size = '13'><T>Les contributions sont maintenant ouvertes ! pour plus d'informations, cliquez sur la page <O>Contribuer</O> </T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>INFORMATION: Le Staff de Parkour n'est pas le Staff de Transformice, ils n'ont aucun pouvoir sur le jeu en lui-m√™me, seulement dans ce module.</r>\nLe Staff de Parkour s'assure que le module marche bien, avec le moins de probl√®mes possible et sont toujours disponibles pour aider les joueurs.</font></p>\nVous pouvez √©crire <D>!staff</D> dans le chat pour voir la liste du Staff en ligne.\n\n<font color = '#E7342A'>Administrateurs:</font> Ils sont responsables de maintenir le module lui-m√™me en ajoutant des mises √† jour et en r√©parant les bugs.\n\n<font color = '#D0A9F0'>Managers des √©quipes:</font> Ils surveillent les mod√©rateurs et les cr√©ateurs de cartes, surveillant s'ils font bien leur travail. Ils sont aussi responsable du recrutement des nouveaux membres du Staff.\n\n<font color = '#FFAAAA'>Mod√©rateurs:</font> Ils font respecter les r√®gles du module et punissent ceux qui les enfreignent.\n\n<font color = '#25C059'>Mappers:</font> Ils sont aussi responsable de v√©rifier, ajouter et de supprimer des cartes dans le module pour rendre vos parties plus agr√©ables.",
		help_rules = "<font size = '13'><B><J>Toutes Les R√®gles des Termes et des Conditions de Transformice s'appliquent aussi dans #parkour.</J></B></font>\n\nSi vous surprenez un joueur en train d'enfreindre les r√®gles, chuchotez √† un mod√©rateur du module #parkour connect√©. Si aucun mod√©rateur n'est en ligne, rapportez-le dans le serveur Discord.\nPour tous reports, veuillez inclure : le serveur, le nom du salon, et le nom du joueur.\n‚Ä¢ Ex: fr-#parkour10 Blank#3495 troll\nDes preuves, comme des captures d'√©cran, des vid√©os et des GIFs aident et sont appr√©ci√©s, mais pas n√©cessaires.\n\n<font size = '11'>‚Ä¢ Aucun <font color = '#ef1111'> hack, aucune glitch ou bugs</font> utilis√©s/abus√©s ne sont autoris√©s dans les salons #parkour\n‚Ä¢ <font color = '#ef1111'>Le farm VPN</font> est consid√©r√© comme <B>une violation</B> et n'est pas autoris√©. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nN'importe qui surprit en train d'enfreindre ces r√®gles sera banni.</B></font></p>\n\n<font size = '12'>Transformice autorise le concept du troll. Mais, <font color='#cc2222'><B>nous ne l'autorisons pas dans #parkour.</B></font></font>\n\n<p align = 'center'><J>Le troll est quand un joueur utilise ses pouvoirs ou ses objets d‚Äôinventaire pour intentionnellement emp√™cher les autres joueurs de finir la carte.</j></p>\n‚Ä¢ Le troll en revanche d'un autre troll<B>n'est pas une raison valable</B> et vous serez quand m√™me puni.\n‚Ä¢ Aider un joueur disant vouloir faire la carte seule est aussi consid√©r√© comme du troll.\n‚Ä¢ <J>Si un joueur veut r√©aliser la carte sans aide, merci de le laisser libre de son choix et d'aider les autres joueurs</J>. Si un autre joueur a besoin d'aide au m√™me point de sauvegarde que celui-ci, vous pouvez aider les deux.\n\nSi un joueur est surpris en train de troller, il sera punis en fonction d‚Äôun syst√®me de temps. Notez que du troll r√©p√©titif peut amener √† des sanctions de plus en plus s√©v√®res.",
		help_contribute = "<font size='14'>\n<p align='center'>L'√©quipe de management de parkour aime l'open-source car <t>cela aide la communaut√©</t>. Vous pouvez <o>voir</o> et <o>modifier</o> le code source sur <o><u><a href='event:github'>GitHub</a></u></o>.\n\nEntretenir le module est <t>strictement volontaire</t>, donc toute aide √† propos du <t>code</t>, <t>des rapports de bugs</t>, <t>des suggestions</t> et <t>la cr√©ation de cartes</t> est toujours <u>la bienvenue et appr√©ci√©</u>.\nVous pouvez <vp>rapporter des bugs</vp> et <vp>faire des suggestions</vp> dans <o><u><a href='event:discord'>Discord</a></u></o> et/ou <o><u><a href='event:github'>GitHub</a></u></o>.\nVous pouvez <vp>proposer des cartes</vp> sur le <o><u><a href='event:map_submission'>Forum</a></u></o>.\n\nEntretenir le parkour n'est pas cher, mais ce n'est pas non plus gratuit. Nous appr√©cierons si vous nous aidez en <t>faisant un don</t> <o><u><a href='event:donate'>ici</a></u></o>.\n<u>Toutes les donations iront directement dans l'am√©lioration du module.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Version 2.6.0 - 01/10/2021</o></p>\n\n<font size='11'>‚Ä¢ Ajout d'un <cep>syst√®me de record</cep>! Viens le v√©rifier dans le salon <vp><u>*#parkour0records TonPseudo#Tag</u></vp>\n‚Ä¢ Am√©lioration de la rotation de carte.\n‚Ä¢ Am√©lioration de la v√©rification <o><u><a href='event:discord'>Discord</a></u></o>.",

		-- Congratulation messages
		reached_level = "<d>Bravo! Vous avez atteint le niveau <vp>%s</vp>.",
		finished = "<d><o>%s</o> a fini le parkour en <vp>%s</vp> secondes, <fc>f√©licitations !",
		unlocked_power = "<ce><d>%s</d> a d√©bloqu√© le pouvoir <vp>%s</vp>.",

		-- Information messages
		staff_power = "<r>Le staff de parkour <b>n'a pas</b> de pouvoir en dehors du module.",
		donate = "<vp>Tapez <b>!donate</b> si vous souhaitez faire un don pour ce module!",
		paused_events = "<cep><b>[Attention!]</b> <n>Le module a atteint sa limite critique et est en pause.",
		resumed_events = "<n2>Le module n'est plus en pause.",
		welcome = "<n>Bienvenue √†<t>#parkour</t>!",
		module_update = "<r><b>[Attention!]</b> <n>Le module va se r√©initialiser dans<d>%02d:%02d</d>.",
		leaderboard_loaded = "<j>Le tableau des scores a √©t√© charg√©. Appuyer sur L pour l'ouvrir.",
		kill_minutes = "<R>Vos pouvoirs ont √©t√© d√©sactiv√©s pour %s minutes.",
		permbanned = "<r>Vous avez √©t√© banni de #parkour d√©finitevement.",
		tempbanned = "<r>Vous avez √©t√© banni de parkour pendant %s minutes.",

		-- Records
		records_enabled = "<v>[#] <d>Le mode de records a √©t√© activ√© dans ce salon. Les statistiques ne compteront pas et les pouvoirs sont d√©sactiv√©s !\nVous pouvez trouver plus d'informations √† propos des records sur <b>%s</b>",
		records_admin = "<v>[#] <d>Vous √™tes un administrateur de ce salon de records. Vous pouvez utiliser les commandes <b>!map</b>, <b>!pw</b> et <b>!time</b>.",
		records_completed = "<v>[#] <d>Vous avez compl√©t√© la carte ! Si vous voulez la refaire, ecrivez <b>!redo</b>.",
		records_submit = "<v>[#] <d>Wow ! On dirait que vous avez fait le temps le plus rapide dans ce salon. Si vous voulez envoyez voter record, ecrivez <b>!submit</b>.",
		records_invalid_map = "<v>[#] <r>On dirait que cette carte n'est pas dans la rotation de parkour... Vous ne pouvez pas envoyer de records pour celle-ci !",
		records_not_fastest = "<v>[#] <r>On dirait que vous n'√™tes pas le joueur le plus rapide dans ce salon...",
		records_already_submitted = "<v>[#] <r>Vous avez d√©j√† envoy√© votre record pour cette carte !",
		records_submitted = "<v>[#] <d>Votre record pour la carte <b>%s</b> a √©t√© envoy√©.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Options de Parkour</font></p>\n\nUtiliser les particules comme points de sauvegarde\n\nUtiliser le clavier <b>QWERTY</b> (d√©sactiver si votre clavier est en <b>AZERTY</b>)\n\nUtiliser <b>M</b> comme raccourci pour <b>/mort</b> (d√©sactiver pour <b>DEL</b>)\n\nAffiche le temps de recharge de vos comp√©tences\n\nAffiche les boutons pour utiliser les comp√©tences\n\nAffiche le bouton d'aide\n\nAffiche les annonces des cartes achev√©es\n\nAffichage d'un indicateur pour ne pas √™tre aid√©.",
		cooldown = "<v>[#] <r>Attends quelques secondes avant de pouvoir recommencer.",
		power_options = ("<font size='13' face='Lucida Console'>Clavier <b>QWERTY</b>" ..
						 "\n\n<b>Cacher</b> le nombre de cartes"),
		unlock_power = ("<font size='13' face='Lucida Console'><p align='center'>Compl√®te <v>%s</v> cartes" ..
						"<font size='5'>\n\n</font>pour d√©bloquer le pouvoir" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='13' face='Lucida Console'><p align='center'>Compl√®te <v>%s</v> cartes" ..
						"<font size='5'>\n\n</font>pour am√©liorer le pouvoir" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Rang <v>%s</v>" ..
						"<font size='5'>\n\n</font>pour d√©bloquer le pouvoir" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='13' face='Lucida Console'><p align='center'>Rang <v>%s</v>" ..
						"<font size='5'>\n\n</font>pour am√©liorer le pouvoir" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Cartes compl√©t√©es"),
		overall_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Classement Global"),
		weekly_info = ("<p align='center'><font size='11' face='Lucida Console'><b><v>%s</v></b>" ..
					   "<font size='5'>\n\n</font>Classement Hebdomadaire"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Badges (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>Le nombre de cartes compl√©t√©es de ce joueur est priv√©. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Position dans le classement global: <b><v>%s</v></b>\n\n" ..
					"Position dans le classement hebdomadaire: <b><v>%s</v></b>"),
		map_count = "Nombre de maps compl√©t√©es: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Les badges sont des accomplissements que peuvent obtenir les joueurs. Clique sur un badge pour voir sa description.",
		help_private_maps = "Ce joueur ne souhaite pas partager son nombre de maps compl√©t√©es ! Tu peux √©galement le cacher sur ton profil.",
		help_badge_1 = "Ce joueur a √©t√© un membre du staff de parkour.",
		help_badge_2 = "Ce joueur est ou √©tait sur la page 1 du classement global.",
		help_badge_3 = "Ce joueur est ou √©tait sur la page 2 du classement global.",
		help_badge_4 = "Ce joueur est ou √©tait sur la page 3 du classement global.",
		help_badge_5 = "Ce joueur est ou √©tait sur la page 4 du classement global.",
		help_badge_6 = "Ce joueur est ou √©tait sur la page 5 du classement global.",
		help_badge_7 = "Ce joueur a √©t√© sur le podium √† la fin d'un classement hebdomadaire.",
		help_badge_8 = "Ce joueur a un record de 30 cartes par heure.",
		help_badge_9 = "Ce joueur a un record de 35 cartes par heure.",
		help_badge_10 = "Ce joueur a un record de 40 cartes par heure.",
		help_badge_11 = "Ce joueur a un record de 45 cartes par heure.",
		help_badge_12 = "Ce joueur a un record de 50 cartes par heure.",
		help_badge_13 = "Ce joueur a un record de 55 cartes par heure.",
		help_badge_14 = "Ce joueur a v√©rifi√© son compte discord sur le discord officiel de parkour (√©crivez <b>!discord</b>).",
		help_badge_15 = "Ce joueur a obtenu le temps le plus rapide sur 1 carte.",
		help_badge_16 = "Ce joueur a obtenu le temps le plus rapide sur 5 cartes.",
		help_badge_17 = "Ce joueur a obtenu le temps le plus rapide sur 10 cartes.",
		help_badge_18 = "Ce joueur a obtenu le temps le plus rapide sur 15 cartes.",
		help_badge_19 = "Ce joueur a obtenu le temps le plus rapide sur 20 cartes.",
		help_badge_20 = "Ce joueur a obtenu le temps le plus rapide sur 25 cartes.",
		help_badge_21 = "Ce joueur a obtenu le temps le plus rapide sur 30 cartes.",
		help_badge_22 = "Ce joueur a obtenu le temps le plus rapide sur 35 cartes.",
		help_badge_23 = "Ce joueur a obtenu le temps le plus rapide sur 40 cartes.",
		make_public = "Rendre publique",
		make_private = "Rendre priv√©",
		moderators = "Mod√©rateurs",
		mappers = "Mappers",
		managers = "Managers",
		administrators = "Administrateurs",
		close = "Fermer",
		cant_load_bot_profile = "<v>[#] <r>Vous ne pouvez pas voir le profile de ce robot car #parkour l'utilise int√©rieurement pour faire fonctionner le module correctement.",
		cant_load_profile = "<v>[#] <r>Le joueur <b>%s</b> semble √™tre hors ligne ou n'existe pas.",
		like_map = "Aimez-vous cette carte ?",
		yes = "Oui",
		no = "Non",
		idk = "Je ne sais pas",
		unknown = "Inconnu",
		powers = "Pouvoirs",
		press = "<vp>Appuyer sur %s",
		click = "<vp>Clic gauche",
		ranking_pos = "Classement #%s",
		completed_maps = "<p align='center'><BV><B>Cartes compl√©t√©es: %s</B></p></BV>",
		leaderboard = "Tableau des scores",
		position = "<V><p align=\"center\">Position",
		username = "<V><p align=\"center\">Pseudo",
		community = "<V><p align=\"center\">Communaut√©",
		completed = "<V><p align=\"center\">Cartes compl√©t√©es",
		overall_lb = "Permanent",
		weekly_lb = "Hebdomadaire",
		new_lang = "<v>[#] <d>Langue chang√©e vers Fran√ßais",

		-- Power names
		balloon = "Ballon",
		masterBalloon = "Ballon Ma√Ætre",
		bubble = "Bulle",
		fly = "Voler",
		snowball = "Boule de neige",
		speed = "Vitesse",
		teleport = "T√©l√©portation",
		smallbox = "Petite boite",
		cloud = "Nuage",
		rip = "Tombe",
		choco = "Planche de chocolat",
		bigBox = "Grande bo√Æte",
		trampoline = "Trampoline",
		toilet = "Toilettes",
		pig = "Cochon",
		sink = "Evier",
		bathtub = "Baignoire",
		campfire = "Feu de Camp",
		chair = "Chaise",
	}
	--[[ End of file translations/parkour/fr.lua ]]--
	--[[ File translations/parkour/tr.lua ]]--
	translations.tr = {
		name = "tr",
		fullname = "T√ºrk√ße",

		-- Error messages
		corrupt_map= "<r>Harita bozulmu≈ü. Ba≈üka bir tane y√ºkleniyor.",
		corrupt_map_vanilla = "<r>[ERROR] <n>Bu harita hakkƒ±nda bilgi alƒ±namƒ±yor.",
		corrupt_map_mouse_start= "<r>[ERROR] <n>Bu haritanƒ±n bir ba≈ülangƒ±√ß noktasƒ± olmasƒ± gerekiyor (fare ba≈ülangƒ±√ß noktasƒ±).",
		corrupt_map_needing_chair= "<r>[ERROR] <n>Haritanƒ±n biti≈ü koltuƒüu olmasƒ± gerekiyor.",
		corrupt_map_missing_checkpoints = "<r>[ERROR] <n>Haritada en az bir kontrol noktasƒ± olmasƒ± gerekiyor(sarƒ± √ßivi).",
		corrupt_data = "<r>Maalesef, sizin verileriniz kayboldu ve sƒ±fƒ±rlandƒ±.",
		min_players = "<r>Verinizin kaydedilebilmesi i√ßin odada en az 4 farklƒ± oyuncunun bulunmasƒ± gerekmektedir. <bl>[%s/%s]",
		tribe_house = "<r>Veri kabile evlerinde i≈ülenmeyecektir..",
		invalid_syntax = "<r>Ge√ßersiz s√∂z dizimi.",
		code_error = "<r>Bir sorun olu≈ütu: <bl>%s-%s-%s %s",
		emergency_mode = "<r>Acil durum modu ba≈ülatƒ±lƒ±yor, yeni oyunculara izin verilmemektedir. L√ºtfen ba≈üka bir #parkour odasƒ±na ge√ßin.",
		leaderboard_not_loaded = "<r>Lider tablosu hen√ºz y√ºklenemedi. L√ºtfen bekleyin.",
		max_power_keys = "<v>[#] <r>Aynƒ± tu≈üta sadece %s g√º√ß bulundurabilirsin",

		-- Help window
		help = "Yardƒ±m",
		staff = "Ekip",
		rules = "Kurallar",
		contribute = "Baƒüƒ±≈ü",
		changelog = "Yenilikler",
		help_help = "<p align = 'center'><font size = '14'>Ho≈ü geldiniz <T>#parkour!</T></font></p>\n<font size = '12'><p align='center'><J>Amacƒ±nƒ±z haritayƒ± tamamlayana kadar b√ºt√ºn kontrol noktalarƒ±na ula≈ümak.</J></p>\n\n<font size='11'><N>‚Ä¢  Ayarlar men√ºs√º a√ßmak i√ßin klavyeden <O>O</O> tu≈üuna basabilir, <O>!op</O> yazabilir veya <O>√ßark</O> simgesine tƒ±klayabilirsiniz.\n‚Ä¢ Beceri men√ºs√ºne ula≈ümak i√ßin klavyeden <O>P</O> tu≈üuna basabilir veya saƒü √ºst k√∂≈üedeki <O>El</O> simgesine tƒ±klayabilirsiniz.\n‚Ä¢ Lider tablosuna ula≈ümak i√ßin <O>L</O> tu≈üuna basabilir veya <O>!lb</O> yazabilirsiniz.\n‚Ä¢ √ñlmek i√ßin <O>M</O> veya <O>Delete</O> tu≈üuna basabilirsiniz. <O>Delete</O> tu≈üunu kullanabilmek i√ßin <J>Ayarlar</J> kƒ±sƒ±mƒ±ndan <O>M</O> tu≈üu ile √∂lmeyi kapatmanƒ±z gerekmektedir.\n‚Ä¢  Ekip ve parkur kurallarƒ± hakkƒ±nda daha fazla bilgi bilgi almak i√ßin, <O>Ekip</O> ve <O>Kurallar</O> sekmesine tƒ±klayƒ±n.\n‚Ä¢ <a href='event:discord'><o>Buraya Tƒ±klayarak</o></a> discord davet baƒülantƒ±mƒ±za ula≈üabilir ve <a href='event:map_submission'><o>Buraya Tƒ±klayarak</o></a> da harita g√∂ndermek i√ßin konu baƒülantƒ±sƒ±nƒ± alabilirsiniz.\n‚Ä¢ Kaydƒ±rma yapmanƒ±z gerektiƒüinde <o>yukarƒ±</o> ve <o>a≈üaƒüƒ±</o> ok tu≈ülarƒ±nƒ± kullanƒ±n.\n\n<p align = 'center'><font size = '13'><T>Artƒ±k bize baƒüƒ±≈üta bulunabilirsiniz! Daha fazla bilgi i√ßin, <O>Baƒüƒ±≈ü</O> sekmesine tƒ±klayƒ±n!</T></font></p>",
		help_staff = "<p align = 'center'><font size = '13'><r>Bildiri: Parkur ekibi Transformice'ƒ±n ekibi DEƒûƒ∞LDƒ∞R, sadece parkur mod√ºl√ºnde yetkililerdir.</r>\nParkur ekibi mod√ºl√ºn akƒ±cƒ± bir ≈üekilde kalmasƒ±nƒ± saƒülar ve her zaman oyunculara yardƒ±mcƒ± olurlar.</font></p>\nEkip listesini g√∂rebilmek i√ßin <D>!staff</D> yazabilirsiniz.\n\n<font color = '#E7342A'>Y√∂neticiler:</font> Mod√ºl√º y√∂netir, yeni g√ºncellemeler getirir ve hatalarƒ± d√ºzeltirler.\n\n<font color = '#D0A9F0'>Ekip Y√∂neticileri:</font> Moderat√∂rleri ve Haritacƒ±larƒ± kontrol eder ve i≈ülerini iyi yaptƒ±klarƒ±ndan emin olurlar. Ayrƒ±ca ekibe yeni moderat√∂r almaktan da onlar sorumludur.\n\n<font color = '#FFAAAA'>Moderat√∂rler:</font> Kurallarƒ± uygulamak ve uygulamayan oyuncularƒ± cezalandƒ±rmaktan sorumludurlar.\n\n<font color = '#25C059'>Haritacƒ±lar:</font> Yeni yapƒ±lan haritalarƒ± inceler, harita listesine ekler ve siz oyuncularƒ±mƒ±zƒ±n eƒülenceli bir oyun deneyimi ge√ßirmenizi saƒülarlar.",
		help_rules = "<font size = '13'><B><J>Transformice'ƒ±n b√ºt√ºn kural ve ko≈üullarƒ± #parkour i√ßinde ge√ßerlidir</J></B></font>\n\nEƒüer kurallara uymayan bir oyuncu g√∂r√ºrseniz, oyun i√ßinde parkour ekibindeki moderat√∂rlerden birine mesaj atabilirsiniz. Eƒüer hi√ßbir moderat√∂r √ßevrimi√ßi deƒüilse discord sunucumuzda bildirebilirsiniz.\nBildirirken l√ºtfen sunucuyu, oda ismini ve oyuncu ismini belirtiniz.\n‚Ä¢ √ñrnek: tr-#parkour10 Sperjump#6504 trolling\nEkran g√∂r√ºnt√ºs√º,video ve gifler i≈üe yarayacaktƒ±r fakat gerekli deƒüildir..\n\n<font size = '11'>‚Ä¢#parkour odalarƒ±nda <font color = '#ef1111'>hile ve hata</font> kullanmak YASAKTIR!\n‚Ä¢ <font color = '#ef1111'>VPN farming</font> yasaktƒ±r, <B>Haksƒ±z kazan√ß elde etmeyin</B> .. <p align = 'center'><font color = '#cc2222' size = '12'><B>\nKurallarƒ± √ßiƒüneyen herkes uzakla≈ütƒ±ralacaktƒ±r.</B></font></p>\n\n<font size = '12'>Transformice trolleme konseptine izin verir. Fakat, <font color='#cc2222'><B>biz buna parkur mod√ºl√ºnde izin vermiyoruz.</B></font></font>\n\n<p align = 'center'><J>Trollemek, bir oyuncunun, ba≈üka bir oyuncuya haritayƒ± bitirmesini engellemek amacƒ±yla g√º√ßlerini veya malzemelerini kullanmasƒ±dƒ±r.</j></p>\n‚Ä¢ ƒ∞ntikam almak i√ßin trollemek <B>ge√ßerli bir sebep deƒüildir</B> ve cezalandƒ±rƒ±lacaktƒ±r.\n‚Ä¢ Haritayƒ± tek ba≈üƒ±na bitirmek isteyen bir oyuncuya zorla yardƒ±m etmeye √ßalƒ±≈ümak trollemek olarak kabul edilecek ve cezalandƒ±rƒ±lacaktƒ±r.\n‚Ä¢ <J>Eƒüer bir oyuncu yardƒ±m istemiyorsa ve haritayƒ± tek ba≈üƒ±na bitirmek istiyorsa l√ºtfen diƒüer oyunculara yardƒ±m etmeyi deneyin.</J>. Ancak yardƒ±m isteyen diƒüer oyuncu haritayƒ± tek ba≈üƒ±na yapmak isteyen bir oyuncunun yanƒ±ndaysa ona yardƒ±m edebilirsiniz.\n\nEƒüer bir oyuncu trollerken (ba≈üka bir oyuncunun haritayƒ± bitirmesini engellerken) yakalanƒ±rsa, zaman temel alƒ±narak cezalandƒ±rƒ±lacaktƒ±r. S√ºrekli bir ≈üekilde trollemekten dolayƒ± ceza alan bir oyuncu eƒüer hala trollemeye devam ederse cezalarƒ± daha aƒüƒ±r olacaktƒ±r..",
		help_contribute = "<font size='14'>\n<p align='center'>Parkur y√∂netim ekibi a√ßƒ±k kaynak kodunu seviyor √ß√ºnk√º <t>bu topluluƒüa yardƒ±m ediyor</t>. Kaynak kodunu <o>g√∂r√ºnt√ºleyebilir</o> ve <o>deƒüi≈ütirebilirsiniz</o> <o><u><a href='event:github'>GitHub'a Git</a></u></o>.\n\nMod√ºl√ºn bakƒ±mƒ± <t>isteklere g√∂redir</t>, bu y√ºzden yardƒ±mda bulunmak i√ßin <t>kodlara</t> g√∂z atmanƒ±z, <t>hatalarƒ± bildirmeniz</t>, <t>√∂neride bulunmanƒ±z</t> ve <t>harita olu≈üturmanƒ±z</t> her zaman <u>ho≈ü kar≈üƒ±lanƒ±r ve takdir edilir</u>.\n<o><u><a href='event:discord'>Discord</a></u></o> veya <o><u><a href='event:github'>GitHub</a></u></o> hakkƒ±nda <vp>hatalarƒ± bildirmeniz</vp> ve <vp>√∂neride bulunmanƒ±z</vp> √ßok i≈üimize yarƒ±yacaktƒ±r.\n<o><u><a href='event:map_submission'>Forumdaki Konumuza</a></u></o> <vp>Haritalarƒ±nƒ±zƒ±</vp> g√∂nderebilirsiniz.\n\nParkour bakƒ±mƒ± pahalƒ± deƒüil ama √ºcretsiz de deƒüil. Herhangi bir miktar baƒüƒ±≈ülayarak bize yardƒ±mcƒ± olabilirseniz seviniriz.</t><o><u><a href='event:donate'>Baƒüƒ±≈ü Yapmak ƒ∞√ßin Tƒ±kla</a></u></o>.\n<u>T√ºm baƒüƒ±≈ülar mod√ºl√ºn geli≈ütirilmesine y√∂nelik olacaktƒ±r.</u></p>",
		help_changelog = "<font size='13'><p align='center'><o>Versiyon 2.6.0 - 01/10/2020</o></p>\n\n<font size='11'>‚Ä¢ Bir <cep>rekor sistemi</cep> geldi! Gidip bir g√∂z at <vp><u>*#parkour0records Kullanƒ±cƒ±Adƒ±#Kod</u></vp>\n‚Ä¢ Harita rotasyonu iyile≈ütirildi.\n‚Ä¢ Gelistirilmi≈ü <o><u><a href='event:discord'>Discord</a></u></o> doƒürulamasƒ±.",

		-- Congratulation messages
		reached_level = "<d>Tebrikler! <vp>%s</vp>. seviyeye ula≈ütƒ±nƒ±z.",
		finished = "<d><o>%s</o> parkuru <vp>%s</vp> saniyede bitirdi, <fc>Tebrikler!",
		unlocked_power = "<ce><d>%s</d>, <vp>%s</vp> becerisini a√ßtƒ±.",

		-- Information messages
		staff_power = "<r>Parkour personelinin #parkour odalarƒ±nƒ±n dƒ±≈üƒ±nda hi√ßbir g√ºc√º <b>yoktur</b>.",
		donate = "<vp>Bu mod√ºl i√ßin baƒüƒ±≈ü yapmak istiyorsanƒ±z <b>!donate</b> yazƒ±n!",
		paused_events = "<cep><b>[Dikkat!]</b> <n>Mod√ºl kritik seviyeye ula≈ütƒ± ve durduruluyor.",
		resumed_events = "<n2>Mod√ºl devam ettirildi.",
		welcome = "<n><t>#parkour</t>! Odasƒ±na ho≈ü geldiniz.",
		module_update = "<r><b>[Dikkat!]</b> <n> Mod√ºl <d>%02d:%02d</d> i√ßinde g√ºncellenecektir.",
		leaderboard_loaded = "<j>Lider tablosu g√ºncellendi. G√∂r√ºnt√ºlemek i√ßin klavyeden L tu≈üuna basƒ±n.",
		kill_minutes = "<R>Becerilerin %s dakika boyunca devre dƒ±≈üƒ± bƒ±rakƒ±lmƒ±≈ütƒ±r.",
		permbanned = "<r>#Parkour'dan kalƒ±cƒ± olarak yasaklandƒ±nƒ±z.",
		tempbanned = "<r>#Parkour'dan %s dakika boyunca yasaklandƒ±nƒ±z.",

		-- Records
		records_enabled = "<v>[#] <d>Rekor modu bu odada a√ßƒ±k. ƒ∞statistikleriniz bu odada sayƒ±lmaz ve g√º√ßlerinizi kullanamazsƒ±nƒ±z!\nRekorlar hakkƒ±nda daha fazla bilgi edinmek i√ßin <b>%s</b>  .",
		records_admin = "<v>[#] <d>Bu rekor odasƒ±nƒ±n y√∂neticisisiniz. <b>!map</b>, <b>!pw</b> ve <b>!time</b> komutlarƒ±nƒ± kullanabilirsiniz.",
		records_completed = "<v>[#] <d>Haritayƒ± tamamladƒ±nƒ±z! Eƒüer tekrar yapmak istiyorsanƒ±z <b>!redo</b> yazabilirsiniz.",
		records_submit = "<v>[#] <d>Harika! G√∂r√ºn√º≈üe g√∂re bu haritayƒ± en kƒ±sa s√ºrede siz tamamladƒ±nƒ±z. Rekorunuzu g√∂ndermek isterseniz <b>!submit</b> yazƒ±n.",
		records_invalid_map = "<v>[#] <r>G√∂r√ºn√º≈üe g√∂re bu harita parkur bi√ßiminde deƒüil... Bu harita i√ßin rekor g√∂nderemezsiniz!",
		records_not_fastest = "<v>[#] <r>G√∂r√ºn√º≈üe g√∂re odada bu haritayƒ± en kƒ±sa s√ºrede bitiren siz deƒüilsiniz...",
		records_already_submitted = "<v>[#] <r>Bu harita i√ßin zaten bir rekor g√∂nderdin!",
		records_submitted = "<v>[#] <d>Rekorunuz bu harita i√ßin <b>%s</b> olarak g√∂nderildi.",

		-- Miscellaneous
		options = "<p align='center'><font size='20'>Parkur ayarlarƒ±</font></p>\n\nKontrol noktalarƒ± i√ßin par√ßacƒ±klarƒ± kullan.\n\n<b>QWERTY</b> klavye kullan (Kapatƒ±ldƒ±ƒüƒ±nda <b>AZERTY</b> klavye kullanƒ±lƒ±r).\n\n<b>/mort</b>'un kƒ±sayolu <b>M</b> tu≈üudur (<b>DELETE</b> tu≈üu olmasƒ± i√ßin kapat.).\n\nBeceri bekleme s√ºrelerini g√∂ster.\n\nBeceriler simgesini g√∂ster.\n\nYardƒ±m butonunu g√∂ster.\n\nHarita bitirme duyurularƒ±nƒ± g√∂ster.\n\nYardƒ±m istemiyorum simgesini g√∂ster.",
		cooldown = "<v>[#] <r>Bunu tekrar yapmadan √∂nce birka√ß saniye bekleyin",
		power_options = ("<font size='13' face='Lucida Console'><b>QWERTY</b> Klavye" ..
						 "\n\nTamamlanan harita sayƒ±sƒ±nƒ± <b>gizle</b>"),
		unlock_power = ("<font size='5'>\n\n</font>Kilidi a√ßmak i√ßin" ..
						"<font size='13' face='Lucida Console'><p align='center'><v>%s</v> harita tamamlayƒ±nƒ±z" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power = ("<font size='5'>\n\n</font>Y√ºkseltmek i√ßin" ..
						"<font size='13' face='Lucida Console'><p align='center'><v>%s</v> harita tamamlayƒ±nƒ±z" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		unlock_power_rank = ("<font size='5'>\n\n</font>Kilidi a√ßmak i√ßin" ..
						"<font size='13' face='Lucida Console'><p align='center'>sƒ±ralamanƒ±z <v>%s</v> olmalƒ±dƒ±r" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		upgrade_power_rank = ("<font size='5'>\n\n</font>Y√ºkseltmek i√ßin" ..
						"<font size='13' face='Lucida Console'><p align='center'>sƒ±ralamanƒ±z <v>%s</v> olmalƒ±dƒ±r" ..
						"<font size='5'>\n\n</font><v>%s</v>"),
		maps_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
					 "<font size='5'>\n\n</font>Tamamlanmƒ±≈ü Harita"),
		overall_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Genel Sƒ±ralamanƒ±z"),
		weekly_info = ("<p align='center'><font size='13' face='Lucida Console'><b><v>%s</v></b>" ..
						"<font size='5'>\n\n</font>Bu Haftaki Sƒ±ralamanƒ±z"),
		badges = "<font size='14' face='Lucida Console,Verdana'>Rozetler (%s): <a href='event:_help:badge'><j>[?]</j></a>",
		private_maps = "<bl>Bu oyuncunun tamamladƒ±ƒüƒ± harita sayƒ±sƒ± √∂zeldir. <a href='event:_help:private_maps'><j>[?]</j></a></bl>\n",
		profile = ("<font size='12' face='Lucida Console,Verdana'>%s%s %s\n\n" ..
					"Genel skor tablosu konumu: <b><v>%s</v></b>\n\n" ..
					"Haftalƒ±k liderlik sƒ±ralamasƒ±: <b><v>%s</v></b>"),
		map_count = "Tamamlanan harita sayƒ±sƒ±: <b><v>%s</v> / <a href='event:_help:yellow_maps'><j>%s</j></a> / <a href='event:_help:red_maps'><r>%s</r></a></b>",
		help_badge = "Rozetler, bir oyuncunun elde edebileceƒüi ba≈üarƒ±dƒ±r. A√ßƒ±klamalarƒ±nƒ± g√∂rmek i√ßin √ºzerlerine tƒ±klayƒ±n.",
		help_private_maps = "Bu oyuncu tamamladƒ±ƒüƒ± harita sayƒ±sƒ±nƒ± herkese a√ßƒ±k olarak payla≈ümaktan ho≈ülanmƒ±yor! ƒ∞stersen sen de kendi profilinde bu bilgileri gizleyebilirsin.",
		help_badge_1 = "Bu oyuncu ge√ßmi≈üte parkur ekibindeydi.",
		help_badge_2 = "Bu oyuncu genel liderlik tablosunun 1. sayfasƒ±nda yer alƒ±yor.",
		help_badge_3 = "Bu oyuncu genel liderlik tablosunun 2. sayfasƒ±nda yer alƒ±yor.",
		help_badge_4 = "Bu oyuncu genel liderlik tablosunun 3. sayfasƒ±nda yer alƒ±yor.",
		help_badge_5 = "Bu oyuncu genel liderlik tablosunun 4. sayfasƒ±nda yer alƒ±yor.",
		help_badge_6 = "Bu oyuncu genel liderlik tablosunun 5. sayfasƒ±nda yer alƒ±yor.",
		help_badge_7 = "Bu oyuncu haftalƒ±k liderlik tablosunun sonunda podyuma √ßƒ±ktƒ±.",
		help_badge_8 = "Bu oyuncu bir saatte 30 harita tamamlamƒ±≈ü!",
		help_badge_9 = "Bu oyuncu bir saatte 35 harita tamamlamƒ±≈ü!",
		help_badge_10 = "Bu oyuncu bir saatte 40 harita tamamlamƒ±≈ü!",
		help_badge_11 = "Bu oyuncu bir saatte 45 harita tamamlamƒ±≈ü!",
		help_badge_12 = "Bu oyuncu bir saatte 50 harita tamamlamƒ±≈ü!",
		help_badge_13 = "Bu oyuncu bir saatte 55 harita tamamlamƒ±≈ü!",
		help_badge_14 = "Bu oyuncu, resmi parkour discord sunucusunda discord hesabƒ±nƒ± doƒüruladƒ± (<b>!discord</b> yazƒ±n).",
		help_badge_15 = "Bu oyuncu 1 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_16 = "Bu oyuncu 5 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_17 = "Bu oyuncu 10 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_18 = "Bu oyuncu 15 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_19 = "Bu oyuncu 20 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_20 = "Bu oyuncu 25 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_21 = "Bu oyuncu 30 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_22 = "Bu oyuncu 35 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		help_badge_23 = "Bu oyuncu 40 haritayƒ± en kƒ±sa s√ºrede tamamladƒ±.",
		make_public = "herkese a√ßƒ±k",
		make_private = "ki≈üiye √∂zel",
		moderators = "Moderat√∂rler",
		mappers = "Haritacƒ±lar",
		managers = "Ekip Y√∂neticileri",
		administrators = "Y√∂neticiler",
		close = "Kapat",
		cant_load_bot_profile = "<v>[#] <r>#Parkour'un d√ºzg√ºn √ßalƒ±≈ümasƒ± i√ßin dahil edildiƒüinden bu botun profilini g√∂remezsiniz.",
		cant_load_profile = "<v>[#] <r>Oyuncu <b>%s</b> √ßevrimdƒ±≈üƒ± g√∂z√ºk√ºyor veya b√∂yle bir kullanƒ±cƒ± yok.",
		like_map = "Bu haritayƒ± beƒüendin mi?",
		yes = "Evet",
		no = "Hayƒ±r",
		idk = "Bilmiyorum",
		unknown = "Bilinmiyor",
		powers = "Beceriler",
		press = "<vp>%s Tu≈üuna Bas",
		click = "<vp>Sol tƒ±k",
		ranking_pos = "Sƒ±ralama #%s",
		completed_maps = "<p align='center'><BV><B>Tamamlanan haritalar: %s</B></p></BV>",
		leaderboard = "Lider sƒ±ralamasƒ±",
		position = "<V><p align=\"center\">Sƒ±ralama",
		username = "<V><p align=\"center\">Kullanƒ±cƒ± adƒ±",
		community = "<V><p align=\"center\">Topluluk",
		completed = "<V><p align=\"center\">Tamamlanan haritalar",
		overall_lb = "Genel",
		weekly_lb = "Haftalƒ±k",
		new_lang = "<v>[#] <d>Diliniz T√ºrk√ße olarak ayarlandƒ±",

		-- Power names
		balloon = "Balon",
		masterBalloon = "Usta ƒ∞≈üi Balon",
		bubble = "Baloncuk",
		fly = "U√ßma",
		snowball = "Kar topu",
		speed = "Hƒ±z",
		teleport = "I≈üƒ±nlanma",
		smallbox = "K√º√ß√ºk kutu",
		cloud = "Bulut",
		rip = "Mezar ta≈üƒ±",
		choco = "√áikolata Tahta",
		bigBox = "B√ºy√ºk Kutu",
		trampoline = "Trambolin",
		toilet = "Tuvalet",
		pig = "Domuzcuk",
		sink = "Lavabo",
		bathtub = "K√ºvet",
		campfire = "Kamp Ate≈üi",
		chair = "Sandalye",
	}
	--[[ End of file translations/parkour/tr.lua ]]--
	--[[ End of directory translations/parkour ]]--
	--[[ File modes/parkour/timers.lua ]]--
	local timers = {}
	local aliveTimers = false

	local function addNewTimer(delay, fnc, arg1, arg2, arg3, arg4, arg5)
		aliveTimers = true
		local list = timers[delay]
		if list then
			list._count = list._count + 1
			list[list._count] = {os.time() + delay, fnc, arg1, arg2, arg3, arg4, arg5}
		else
			timers[delay] = {
				_count = 1,
				_pointer = 1,
				[1] = {os.time() + delay, fnc, arg1, arg2, arg3, arg4, arg5}
			}
		end
	end

	onEvent("Loop", function()
		if aliveTimers then
			aliveTimers = false
			local now = os.time()
			local timer, newPointer
			for delay, list in next, timers do
				newPointer = list._pointer
				for index = newPointer, list._count do
					timer = list[index]

					if now >= timer[1] then
						timer[2](timer[3], timer[4], timer[5], timer[6], timer[7])
						newPointer = index + 1
					else
						break
					end
				end
				list._pointer = newPointer
				if newPointer <= list._count then
					aliveTimers = true
				end
			end
		end
	end)

	onEvent("NewGame", function()
		if aliveTimers then
			local timer, count
			for delay, list in next, timers do
				count = list._count
				for index = list._pointer, count do
					timer = list[index]
					timer[2](timer[3], timer[4], timer[5], timer[6], timer[7])
				end

				if list._count > count then
					for index = count + 1, list._count do
						timer = list[index]
						timer[2](timer[3], timer[4], timer[5], timer[6], timer[7])
					end
				end
			end
			timers = {}
			aliveTimers = false
		end
	end)
	--[[ End of file modes/parkour/timers.lua ]]--
	--[[ File modes/parkour/communication.lua ]]--
	if room.name == "*#parkour4bots" then
		recv_channel, send_channel = "Sharpiebot#0000", "Parkour#8558"
	else
		recv_channel, send_channel = "Parkour#8558", "Sharpiebot#0000"
	end

	function sendPacket(packet_id, packet) end
	if not is_tribe then
		--[[
			Packets from 4bots:
				0 - join request
				1 - game update
				2 - update pdata
				3 - !ban
				4 - !announce
				5 - !cannounce
				6 - pw request

			Packets to 4bots:
				0 - room crash
				1 - suspect
				2 - ban field set to playerdata
				3 - farm/hack suspect
				4 - weekly lb reset
				5 - pw info
				6 - record submission
		]]

		local last_id = os.time() - 10000
		local next_channel_load = 0

		local common_decoder = {
			["&0"] = "&",
			["&1"] = ";",
			["&2"] = ","
		}
		local common_encoder = {
			["&"] = "&0",
			[";"] = "&1",
			[","] = "&2"
		}

		function sendPacket(packet_id, packet)
			if not add_packet_data then
				add_packet_data = ""
			end

			add_packet_data = add_packet_data .. ";" .. packet_id .. "," .. string.gsub(packet, "[&;,]", common_encoder)
		end

		packet_handler = function(player, data)
			if player == send_channel then
				if not buffer then return end
				local send_id
				send_id, data = string.match(data, "^(%d+)(.*)$")
				if not send_id then
					send_id, data = 0, ""
				else
					send_id = tonumber(send_id)
				end

				local now = os.time()
				if now < send_id + 10000 then
					buffer = data .. buffer
				end

				system.savePlayerData(player, now .. buffer)
				buffer = nil
				if eventPacketSent then
					eventPacketSent()
				end
			elseif player == recv_channel then
				if data == "" then
					data = "0"
				end

				local send_id
				send_id, data = string.match(data, "^(%d+)(.*)$")
				send_id = tonumber(send_id)
				if send_id <= last_id then return end
				last_id = send_id

				if eventPacketReceived then
					for packet_id, packet in string.gmatch(data, ";(%d+),([^;]*)") do
						packet = string.gsub(packet, "&[012]", common_decoder)

						eventPacketReceived(tonumber(packet_id), packet)
					end
				end
			end
		end
		onEvent("PlayerDataLoaded", packet_handler)

		onEvent("Loop", function()
			local now = os.time()
			if now >= next_channel_load then
				next_channel_load = now + 10000

				if eventChannelLoad then
					eventChannelLoad()
				end
				if add_packet_data then
					buffer = add_packet_data
					add_packet_data = nil
					system.loadPlayerData(send_channel)
				end
				system.loadPlayerData(recv_channel)
			end
		end)
	end
	--[[ End of file modes/parkour/communication.lua ]]--
	--[[ File modes/parkour/maps.lua ]]--
	--[[
		The map quantity is HUGE (over 300). We need a system that:
		- Picks a random map quickly
		- Does NOT repeat maps unless the whole rotation has played
		- Is able to switch the map list quickly (add/remove maps)

		This system uses sections:
		Every section is a pointer to the index of a map, depending
		on the maps per section quantity. If it is 10, section 0
		points to the maps 1-10, section 1 to the maps 11-20 and so
		on.

		The sections do NOT point to the map, but to the index.
		This way we can update the maps easily.

		We shuffle these sections when they're calculated, and keep
		a pointer to the next section, which we increase every time
		we want to select a map. Every section has an internal
		counter too, and it works the same way.

		When a section is selected, if the maps it contains weren't
		shuffled, they will be shuffled at that moment. When all
		the maps are played, the sections will reshuffle and their
		maps will be flagged as unshuffled.
		This way we can do small shuffles without the need of
		shuffling a big array with a lot of elements. Due to the
		runtime limitations in transformice lua, this is way better
	]]

	local first_data_load = true
	local maps_per_section = math.random(10, 20)
	local maps = {
		sections_high = {
			_count = 0,
			_pointer = 0,
			_map_pointer = 1
		},
		sections_low = {
			_count = 0,
			_pointer = 0,
			_map_pointer = 1
		},

		list_high = {7171137},
		high_count = 1,

		list_low = {7171137},
		low_count = 1
	}
	local is_invalid = false
	local count_stats = true
	local map_change_cd = 0

	local levels
	local perms
	local review_mode
	local records_admins = string.find(room.lowerName, "records", 1, true) and {}

	local function selectMap(sections, list, count)
		if sections._map_pointer > maps_per_section then
			-- All maps played, reset sections
			sections._map_pointer = 1
			sections._pointer = 0
			sections._count = 0
		end

		if sections._count == 0 then
			-- No sections, calculate them
			local quantity = math.ceil(count / maps_per_section)

			local section, start, limit
			for i = 1, quantity do
				start = maps_per_section * (i - 1)
				limit = math.min(maps_per_section * i, count)

				section = {}
				for j = 1, limit - start do
					section[j] = j + start
				end

				sections[i] = section
			end

			-- shuffle sections
			local current, swap
			for index = 1, quantity do
				swap = math.random(index, quantity)

				current = sections[index]
				sections[index] = sections[swap]
				sections[swap] = current
			end

			sections._count = quantity
		end

		-- make pointer go through 1 to _count
		-- 0 -> 1, _count -> 1, x -> x + 1
		sections._pointer = sections._pointer % sections._count + 1

		local section = sections[sections._pointer]
		if not section._count then -- the section has not been shuffled!
			section._count = #section

			local current, swap
			for index = 1, section._count do
				swap = math.random(index, section._count)

				current = section[index]
				section[index] = section[swap]
				section[swap] = current
			end

		elseif (section._pointer == sections._count -- is it the las section?
				and section._count < maps_per_section -- does it have less maps than a regular section?
				and sections._map_pointer > section._count) then -- have all the maps from this section been played?
			sections._map_pointer = sections._map_pointer + 1 -- increase map pointer
			return selectMap(sections, list, count) -- and select another map
		end

		local map = section[sections._map_pointer]

		if sections._pointer == sections._count then
			-- if it is the last section, the next map pointer has to be increased
			sections._map_pointer = sections._map_pointer + 1
		end

		return list[map]
	end

	local function newMap()
		count_stats = true
		map_change_cd = os.time() + 20000

		local map
		if math.random((maps.low_count + maps.high_count * 2) * 1000000) <= (maps.low_count * 1000000) then -- 1/3
			map = selectMap(maps.sections_low, maps.list_low, maps.low_count)
		else
			map = selectMap(maps.sections_high, maps.list_high, maps.high_count)
		end

		tfm.exec.newGame(map)
	end

	local function invalidMap(arg)
		levels = nil
		is_invalid = os.time() + 3000
		translatedChatMessage("corrupt_map")
		translatedChatMessage("corrupt_map_" .. arg)
	end

	local function getTagProperties(tag)
		local properties = {}
		for name, value in string.gmatch(tag, '(%S+)%s*=%s*"([^"]+)"') do
			properties[name] = tonumber(value) or value
		end
		return properties
	end

	onEvent("GameDataLoaded", function(data)
		if data.maps then
			maps.list_high = data.maps
			maps.high_count = #data.maps

			if maps.high_count == 0 then
				maps.list_high = {7171137}
				maps.high_count = 1
			end

			local sections = maps.sections_high
			if sections._count ~= 0 then
				if sections._count ~= math.ceil(maps.high_count / maps_per_section) then
					sections._map_pointer = maps_per_section + 1 -- reset everything

				elseif sections._count == needed then
					local section = sections[sections._count]
					local modulo = maps.high_count % maps_per_section

					if modulo == 0 then
						modulo = maps_per_section
					end

					if section._count ~= 0 and section._count ~= modulo then
						sections._map_pointer = maps_per_section + 1
					end
				end
			end

			if first_data_load then
				newMap()
				first_data_load = false
			end
		end

		if data.lowmaps then
			maps.list_low = data.lowmaps
			maps.low_count = #data.lowmaps

			if maps.low_count == 0 then
				maps.list_low = {7171137}
				maps.low_count = 1
			end

			local sections = maps.sections_low
			if sections._count ~= 0 then
				if sections._count ~= math.ceil(maps.low_count / maps_per_section) then
					sections._map_pointer = maps_per_section + 1 -- reset everything

				elseif sections._count == needed then
					local section = sections[sections._count]
					local modulo = maps.low_count % maps_per_section

					if modulo == 0 then
						modulo = maps_per_section
					end

					if section._count ~= 0 and section._count ~= modulo then
						sections._map_pointer = maps_per_section + 1
					end
				end
			end
		end
	end)

	onEvent("NewGame", function()
		-- When a map is loaded, this function reads the XML to know where the
		-- checkpoints are

		levels = {}
		if not room.xmlMapInfo then return invalidMap("vanilla") end
		local xml = room.xmlMapInfo.xml

		local count = 1
		local mouse_start = string.match(xml, '<DS%s+(.-)%s+/>')

		if not mouse_start then
			return invalidMap("mouse_start")
		end

		local properties = getTagProperties(mouse_start)
		levels[count] = {x = properties.X, y = properties.Y}

		for tag in string.gmatch(xml, '<O%s+(.-)%s+/>') do
			properties = getTagProperties(tag)

			if properties.C == 22 then
				count = count + 1
				levels[count] = {x = properties.X, y = properties.Y}
			end
		end

		local chair = false
		for tag in string.gmatch(xml, '<P%s+(.-)%s+/>') do
			properties = getTagProperties(tag)

			if properties.T == 19 and properties.C == "329cd2" then
				chair = true
				count = count + 1
				levels[count] = {x = properties.X, y = properties.Y - 25}
				break
			end
		end

		if not chair or count < 3 then -- start, at least one nail and end chair
			return invalidMap(not chair and "needing_chair" or "missing_checkpoints")
		end

		if room.mirroredMap then
			for index = 1, count do
				levels[index].x = 1600 - levels[index].x
			end
		end

		tfm.exec.setGameTime(1080)

		if count_stats and not is_tribe and not records_admins and not review_mode and room.xmlMapInfo.permCode ~= 41 then
			is_invalid = os.time() + 3000
			return
		end
		is_invalid = false
	end)

	onEvent("Loop", function(elapsed, remaining)
		-- Changes the map when needed
		if (is_invalid and os.time() >= is_invalid) or remaining < 500 then
			newMap()
		end
	end)

	onEvent("ParsedChatCommand", function(player, cmd, quantity, args)
		if cmd == "map" then
			local records_cond = records_admins and records_admins[player]
			local tribe_cond = is_tribe and room.playerList[player].tribeName == string.sub(room.name, 3)
			local normal_cond = perms[player] and perms[player].change_map
			if not records_cond and not tribe_cond and not normal_cond then return end

			if quantity > 0 then
				if not records_cond and not tribe_cond and not perms[player].load_custom_map then
					return tfm.exec.chatMessage("<v>[#] <r>You can't load a custom map.", player)
				end

				count_stats = false
				local map = tonumber(args[1]) or tonumber(string.sub(args[1], 2))
				if not map or map < 1000 then
					translatedChatMessage("invalid_syntax", player)
					return
				end
				tfm.exec.newGame(args[1], args[2] and string.lower(args[2]) == "flipped")
			elseif os.time() < map_change_cd and not review_mode then
				tfm.exec.chatMessage("<v>[#] <r>You need to wait a few seconds before changing the map.", player)
			else
				newMap()
			end
		end
	end)

	onEvent("GameStart", function()
		tfm.exec.disableAutoNewGame(true)
		tfm.exec.disableAutoShaman(true)
		tfm.exec.disableAfkDeath(true)
		tfm.exec.disableAutoTimeLeft(true)
		tfm.exec.setAutoMapFlipMode(false)

		system.disableChatCommandDisplay("map")
	end)
	--[[ End of file modes/parkour/maps.lua ]]--
	--[[ File modes/parkour/join-system.lua ]]--
	local room_max_players = 12

	onEvent("PacketReceived", function(packet_id, packet)
		if packet_id == 0 then
			if packet == room.name then
				tfm.exec.setRoomMaxPlayers(room_max_players + 10)
				addNewTimer(15000, tfm.exec.setRoomMaxPlayers, room_max_players)
			end
		end
	end)
	--[[ End of file modes/parkour/join-system.lua ]]--
	--[[ File modes/parkour/game.lua ]]--
	local checkpoint_range = 15 ^ 2 -- radius of 15px
	local min_save = 4

	local check_position = 6
	local player_count = 0
	local victory_count = 0
	local map_start = 0
	local less_time = false
	local victory = {_last_level = {}}
	local bans = {[0] = true} -- souris banned
	local in_room = {}
	local online = {}
	local hidden = {}
	local players_level = {}
	local generated_at = {}
	local spec_mode = {}
	local ck = {
		particles = {},
		images = {}
	}
	local players_file
	review_mode = false
	local cp_available = {}

	local checkCooldown
	local savePlayerData
	local ranks
	local bindKeyboard

	local function addCheckpointImage(player, x, y)
		if not x then
			local level = levels[ players_level[player] + 1 ]
			if not level then return end
			x, y = level.x, level.y
		end

		ck.images[player] = tfm.exec.addImage("150da4a0616.png", "_51", x - 20, y - 30, player)
	end

	local function enableSpecMode(player, enable)
		if spec_mode[player] and enable then return end
		if not spec_mode[player] and not enable then return end

		if enable then
			spec_mode[player] = true
			tfm.exec.killPlayer(player)

			player_count = player_count - 1
			if victory[player] then
				victory_count = victory_count - 1
			elseif player_count == victory_count and not less_time then
				tfm.exec.setGameTime(20)
				less_time = true
			end
		else
			spec_mode[player] = nil

			if (not levels) or (not players_level[player]) then return end

			local level = levels[ players_level[player] ]

			tfm.exec.respawnPlayer(player)
			tfm.exec.movePlayer(player, level.x, level.y)

			player_count = player_count + 1
			if victory[player] then
				victory_count = victory_count + 1
			end
		end
	end

	onEvent("NewPlayer", function(player)
		spec_mode[player] = nil
		in_room[player] = true
		player_count = player_count + 1
		cp_available[player] = 0

		if levels then
			tfm.exec.respawnPlayer(player)

			if victory[player] then
				victory_count = victory_count + 1
			end

			if players_level[player] then
				local level = levels[ players_level[player] ]
				if level then
					tfm.exec.movePlayer(player, level.x, level.y)
				end
			else
				players_level[player] = 1
				tfm.exec.movePlayer(player, levels[1].x, levels[1].y)

				for key = 0, 2 do
					bindKeyboard(player, key, true, true)
				end
			end

			tfm.exec.setPlayerScore(player, players_level[player], false)
		end
	end)

	onEvent("Keyboard", function(player, key)
		if key >= 0 and key <= 2 then
			if players_level[player] == 1 and not generated_at[player] then
				generated_at[player] = os.time()

				for key = 0, 2 do
					bindKeyboard(player, key, true, false)
				end
			end
		end
	end)

	onEvent("PlayerLeft", function(player)
		players_file[player] = nil
		in_room[player] = nil

		if spec_mode[player] then return end

		player_count = player_count - 1

		if victory[player] then
			victory_count = victory_count - 1
		elseif player_count == victory_count and not less_time then
			tfm.exec.setGameTime(20)
			less_time = true
		end
	end)

	onEvent("PlayerDied", function(player)
		if not room.playerList[player] then return end
		if bans[room.playerList[player].id] then return end
		if (not levels) or (not players_level[player]) then return end

		local level = levels[ players_level[player] ]

		if not spec_mode[player] then
			tfm.exec.respawnPlayer(player)
			if level then
				tfm.exec.movePlayer(player, level.x, level.y)
			end
		end
	end)

	onEvent("PlayerWon", function(player)
		victory_count = victory_count + 1
		victory[player] = true
		victory._last_level[player] = false

		if victory_count == player_count and not less_time then
			tfm.exec.setGameTime(20)
			less_time = true
		end
	end)

	onEvent("PlayerRespawn", function(player)
		cp_available[player] = os.time() + 750

		if not room.playerList[player] then return end
		if bans[room.playerList[player].id] then return tfm.exec.killPlayer(player) end
		if (not levels) or (not players_level[player]) then return end

		local level = levels[ players_level[player] ]
		if not level then return end
		tfm.exec.movePlayer(player, level.x, level.y)
	end)

	onEvent("NewGame", function()
		check_position = 6
		victory_count = 0
		victory = {_last_level = {}}
		players_level = {}
		generated_at = {}
		map_start = os.time()

		if records_admins then
			less_time = true
		else
			less_time = false
		end

		local start_x, start_y
		if levels then
			start_x, start_y = levels[2].x, levels[2].y

			for player, particles in next, ck.particles do
				if not particles then
					if ck.images[player] then
						tfm.exec.removeImage(ck.images[player])
					end
					addCheckpointImage(player, start_x, start_y)
				end
			end
		end

		for player in next, in_room do
			players_level[player] = 1
			tfm.exec.setPlayerScore(player, 1, false)

			for key = 0, 2 do
				bindKeyboard(player, key, true, true)
			end
		end

		for player in next, spec_mode do
			tfm.exec.killPlayer(player)
		end
	end)

	onEvent("Loop", function()
		if not levels then return end

		if check_position > 0 then
			check_position = check_position - 1
		else
			for player, to_give in next, victory._last_level do
				if not victory[player] and to_give then
					eventPlayerWon(player)
				end
			end

			local last_level = #levels
			local level_id, next_level, player
			local particle = 29--math.random(21, 23)
			local x, y = math.random(-10, 10), math.random(-10, 10)
			local now = os.time()

			for name in next, in_room do
				player = room.playerList[name]
				if spec_mode[name] then
					tfm.exec.killPlayer(name)
				elseif player and now >= cp_available[name] then
					level_id = (players_level[name] or 1) + 1
					next_level = levels[level_id]

					if next_level then
						if ((player.x - next_level.x) ^ 2 + (player.y - next_level.y) ^ 2) <= checkpoint_range then
							players_level[name] = level_id
							if not victory[name] then
								tfm.exec.setPlayerScore(name, level_id, false)
							end
							if ck.particles[name] == false then
								tfm.exec.removeImage(ck.images[name])
							end

							if level_id == last_level then
								if victory[name] then -- !cp
									translatedChatMessage("reached_level", name, level_id)
								else
									victory._last_level[name] = true
									tfm.exec.giveCheese(name)
									tfm.exec.playerVictory(name)
									tfm.exec.respawnPlayer(name)
									tfm.exec.movePlayer(name, next_level.x, next_level.y)
								end
							else
								translatedChatMessage("reached_level", name, level_id)

								if ck.particles[name] == false then
									addCheckpointImage(name, levels[level_id + 1].x, levels[level_id + 1].y)
								end
							end
						elseif ck.particles[name] then
							tfm.exec.displayParticle(
								particle,
								next_level.x + x,
								next_level.y + y,
								0, 0, 0, 0,
								name
							)
						end
					end
				end
			end
		end
	end)

	onEvent("ParsedChatCommand", function(player, cmd, quantity, args)
		if cmd == "review" then
			local tribe_cond = is_tribe and room.playerList[player].tribeName == string.sub(room.name, 3)
			local normal_cond = (perms[player] and
								perms[player].enable_review and
								not records_admins and

								(string.find(room.lowerName, "review") or
								 ranks.admin[player]))
			if not tribe_cond and not normal_cond then
				return tfm.exec.chatMessage("<v>[#] <r>You can't toggle review mode in this room.", player)
			end

			review_mode = not review_mode
			if review_mode then
				tfm.exec.chatMessage("<v>[#] <d>Review mode enabled by " .. player .. ".")
			else
				tfm.exec.chatMessage("<v>[#] <d>Review mode disabled by " .. player .. ".")
			end

		elseif cmd == "cp" then
			if not review_mode then
				if not victory[player] then return end
				if not checkCooldown(player, "cp_command", 10000) then
					return translatedChatMessage("cooldown", player)
				end
			end

			local checkpoint = tonumber(args[1])
			if not checkpoint then
				return translatedChatMessage("invalid_syntax", player)
			end

			if not levels[checkpoint] then return end

			players_level[player] = checkpoint
			tfm.exec.killPlayer(player)
			if not victory[player] then
				tfm.exec.setPlayerScore(player, checkpoint, false)
			end

			if ck.particles[player] == false then
				tfm.exec.removeImage(ck.images[player])
				local next_level = levels[checkpoint + 1]
				if next_level then
					addCheckpointImage(player, next_level.x, next_level.y)
				end
			end

		elseif cmd == "spec" then
			if not perms[player] or not perms[player].spectate then return end

			enableSpecMode(player, not spec_mode[player])
			players_file[player].spec = spec_mode[player]
			savePlayerData(player)

		elseif cmd == "time" then
			if not records_admins or not records_admins[player] then
				if not perms[player] then return end
				if not perms[player].set_map_time then
					if perms[player].set_map_time_review then
						if not review_mode then
							return tfm.exec.chatMessage("<v>[#] <r>You can only change the map time with review mode enabled.", player)
						end
					else return end
				end
			end

			local time = tonumber(args[1])
			if not time then
				return translatedChatMessage("invalid_syntax", player)
			end

			tfm.exec.setGameTime(time)

		elseif cmd == "redo" then
			if not records_admins or not generated_at[player] then return end

			players_level[player] = 1
			generated_at[player] = nil
			victory[player] = nil
			victory_count = victory_count - 1

			tfm.exec.setPlayerScore(player, 1, false)
			tfm.exec.killPlayer(player)
			tfm.exec.respawnPlayer(player)
			for key = 0, 2 do
				bindKeyboard(player, key, true, true)
			end

			if ck.particles[player] == false then
				if ck.images[player] then
					tfm.exec.removeImage(ck.images[player])
				end
				addCheckpointImage(player, levels[2].x, levels[2].y)
			end
		end
	end)

	onEvent("PlayerDataParsed", function(player, data)
		ck.particles[player] = data.settings[1] == 1

		if levels and not ck.particles[player] then
			local next_level = levels[(players_level[player] or 1) + 1]
			if next_level then
				if ck.images[player] then
					tfm.exec.removeImage(ck.images[player])
				end
				addCheckpointImage(player, next_level.x, next_level.y)
			end
		end

		if players_file[player].spec then
			enableSpecMode(player, true)
			tfm.exec.chatMessage("<v>[#] <d>Your spec mode has been carried to this room since it's enabled.", player)
		end

		if data.banned and (data.banned == 2 or os.time() < data.banned) then
			bans[room.playerList[player].id] = true

			enableSpecMode(player, true)

			if data.banned == 2 then
				translatedChatMessage("permbanned", player)
			else
				local minutes = math.floor((data.banned - os.time()) / 1000 / 60)
				translatedChatMessage("tempbanned", player, minutes)
			end
		end
	end)

	onEvent("GameDataLoaded", function(data)
		if data.banned then
			bans = {[0] = true}
			for id, value in next, data.banned do
				if value == 1 or os.time() < value then
					bans[tonumber(id)] = true
				end
			end

			local id, ban
			for player, pdata in next, players_file do
				if room.playerList[player] and in_room[player] then
					id = room.playerList[player].id
					ban = data.banned[tostring(id)]

					if ban then
						if ban == 1 then
							pdata.banned = 2
						else
							pdata.banned = ban
						end
						savePlayerData(player)
						sendPacket(2, id .. "\000" .. ban)
					end

					if pdata.banned and (pdata.banned == 2 or os.time() < pdata.banned) then
						bans[id] = true

						if pdata.banned == 2 then
							translatedChatMessage("permbanned", player)
						else
							local minutes = math.floor((pdata.banned - os.time()) / 1000 / 60)
							translatedChatMessage("tempbanned", player, minutes)
						end
					end
				end
			end

			for player, data in next, room.playerList do
				if in_room[player] and bans[data.id] then
					enableSpecMode(player, true)
				end
			end
		end
	end)

	onEvent("PacketReceived", function(packet_id, packet)
		if packet_id == 3 then -- !ban
			local player, val = string.match(packet, "^([^\000]+)\000[^\000]+\000([^\000]+)$")
			local file, data = players_file[player], room.playerList[player]
			if in_room[player] and data and file then
				file.banned = val == "1" and 2 or tonumber(val)
				bans[data.id] = file.banned == 2 or os.time() < file.banned

				if bans[data.id] then
					if not spec_mode[player] then
						spec_mode[player] = true
						tfm.exec.killPlayer(player)

						player_count = player_count - 1
						if victory[player] then
							victory_count = victory_count - 1
						elseif player_count == victory_count and not less_time then
							tfm.exec.setGameTime(20)
							less_time = true
						end
					end

					if file.banned == 2 then
						translatedChatMessage("permbanned", player)
					else
						local minutes = math.floor((file.banned - os.time()) / 1000 / 60)
						translatedChatMessage("tempbanned", player, minutes)
					end

				elseif spec_mode[player] then
					enableSpecMode(player, false)
				end

				savePlayerData(player)
				sendPacket(2, data.id .. "\000" .. val)
			end
		end
	end)

	onEvent("GameStart", function()
		tfm.exec.disablePhysicalConsumables(true)
		tfm.exec.setRoomMaxPlayers(room_max_players)
		tfm.exec.setRoomPassword("")
		tfm.exec.disableAutoScore(true)

		system.disableChatCommandDisplay("review")
		system.disableChatCommandDisplay("cp")
		system.disableChatCommandDisplay("spec")
		system.disableChatCommandDisplay("time")
		system.disableChatCommandDisplay("redo")
	end)
	--[[ End of file modes/parkour/game.lua ]]--
	--[[ File modes/parkour/files.lua ]]--
	local next_file_load = os.time() + math.random(60500, 90500)
	local player_ranks
	local no_powers
	local unbind
	local bindNecessary
	local NewBadgeInterface
	local to_save = {}
	local files = {
		--[[
			File values:

			- maps        (1)
			- ranks       (1)
			- chats       (1)

			- ranking     (2)
			- weekranking (2)

			- lowmaps     (3)
			- banned      (3)
		]]

		[1] = 20, -- maps, ranks, chats
		[2] = 21, -- ranking, weekranking
		[3] = 22, -- lowmaps, banned
	}
	local total_files = 3
	local file_index = 1
	local file_id = files[file_index]
	local timed_maps = {
		week = {},
		hour = {}
	}
	local badges = {
		[1] = { -- former staff
			{ 1, "1745f43783e.png", "1745f432e33.png"},
		},
		[2] = { -- leaderboard
			{ 2, "17435b0098c.png", "1745a88ffce.png"}, -- 1
			{ 3, "17435b03030.png", "1745a892d25.png"}, -- 2
			{ 4, "17435b06052.png", "1745a89eb17.png"}, -- 3
			{ 5, "17435af7df1.png", "1745a89bc52.png"}, -- 4
			{ 6, "17435afd7c2.png", "1745a899776.png"}, -- 5
		},
		[3] = { -- weekly podium
			{ 7, "1745a660504.png", "1745a6bfa2c.png"},
		},
		[4] = { -- hour records
			{ 8, "1745a5547a9.png", "1745afa8577.png"}, -- 30
			{ 9, "1745a53f4c9.png", "1745afac029.png"}, -- 35
			{10, "1745a5506b3.png", "1745afaf043.png"}, -- 40
			{11, "1745a54a1e3.png", "1745afb4333.png"}, -- 45
			{12, "1745a541bdd.png", "1745afc2c32.png"}, -- 50
			{13, "1745a54869e.png", "1745afc5c2e.png"}, -- 55
		},
		[5] = { -- discord
			filePriority = true, -- always takes the value from the file

			{14, "1746ef93af1.png", "1746ef8f813.png"},
		},
		[6] = { -- records
			filePriority = true,

			{15, "174e4ab6c8e.png", "174e4ad310f.png"}, -- 1
			{16, "174e4abd8bf.png", "174e4ad809d.png"}, -- 5
			{17, "174e4ab90e8.png", "174e4ad9ac9.png"}, -- 10
			{18, "174e4ac1da4.png", "174e4adb7b6.png"}, -- 15
			{19, "174e4ac3c80.png", "174e4add665.png"}, -- 20
			{20, "174e4ac5e0c.png", "174e4adf461.png"}, -- 25
			{21, "174e4acbb91.png", "174e4ae116f.png"}, -- 30
			{22, "174e4acd5af.png", "174e4ae2cd5.png"}, -- 35
			{23, "174e4acee82.png", "174e4ae49a3.png"}, -- 40
		},
	}
	players_file = {}

	local data_migrations = {
		["0.0"] = function(player, data)
			data.parkour = data.modules.parkour
			data.drawbattle = data.modules.drawbattle

			data.modules = nil

			data.parkour.v = "0.1" -- version
			data.parkour.c = data.parkour.cm -- completed maps

			data.parkour.cm = nil
		end,
		["0.1"] = function(player, data)
			data.parkour.v = "0.2"
			data.parkour.ckpart = 1 -- particles for checkpoints (1 -> true, 0 -> false)
			data.parkour.mort = 1 -- /mort hotkey
			data.parkour.pcool = 1 -- power cooldowns
			data.parkour.pbut = 1 -- powers button
			data.parkour.keyboard = (room.playerList[player] or room).community == "fr" and 0 or 1 -- 1 -> qwerty, 0 -> azerty
		end,
		["0.2"] = function(player, data)
			data.parkour.v = "0.3"
			data.parkour.killed = 0
		end,
		["0.3"] = function(player, data)
			data.parkour.v = "0.4"
			data.parkour.hbut = 1 -- help button
			data.parkour.congrats = 1 -- contratulations message
		end,
		["0.4"] = function(player, data)
			data.parkour.v = "0.5"
			data.parkour.troll = 0
		end,
		["0.5"] = function(player, data)
			data.parkour.v = "0.6"
			data.parkour.week_c = 0 -- completed maps this week
			data.parkour.week_r = timed_maps.week.last_reset -- last week reset
			data.parkour.hour_c = 0 -- completed maps this hour
			data.parkour.hour_r = os.time() + 60 * 60 * 1000 -- next hour reset
			data.parkour.help = 0 -- doesn't want help?
		end,
		["0.6"] = function(player, data)
			data.parkour.v = "0.7"
			data.parkour.keys = {}
			data.parkour.badges = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
		end,
		["0.7"] = function(player, data)
			data.parkour.v = "0.8"
			data.parkour.badges[13] = 0
			data.parkour.badges[14] = 0
		end,
		["0.8"] = function(player, data)
			data.parkour.v = "0.9"

			local old_badges = data.parkour.badges
			local new_badges = {0, 0, 0, 0, 0, 0}

			local limit
			for i = 1, 5 do
				if i == 2 then
					limit = 5
				elseif i == 4 then
					limit = 6
				else
					limit = 1
				end

				for j = limit, 1, -1 do
					if old_badges[ badges[i][j][1] ] == 1 then
						new_badges[i] = j
						break
					end
				end
			end

			data.parkour.badges = new_badges
		end,
		["0.9"] = function(player, data)
			data.v = 0 -- better

			data.c = data.parkour.c -- completed maps
			data.killed = data.parkour.killed -- sanction end
			data.kill = data.parkour.troll -- last sanction duration
			data.keys = data.parkour.keys -- power keys
			data.week = {data.parkour.week_c, data.parkour.week_r} -- maps this week
			data.hour_r = os.time()
			data.hour = {} -- maps in the last hour
			data.badges = data.parkour.badges -- badges
			data.settings = {
				data.parkour.ckpart, -- particle checkpoints (1) or flags (0)
				data.parkour.mort, -- M (1) or DEL (0) or /mort
				data.parkour.pcool, -- show power cooldowns
				data.parkour.pbut, -- show powers button
				data.parkour.keyboard, -- qwerty (1) or azerty (0)
				data.parkour.hbut, -- show help button
				data.parkour.congrats, -- show congratulations messages
				data.parkour.help -- show no help line
			}
			-- data.commu = "en"
			-- data.room = "en-#parkour1"
			-- data.langue = "en"
			-- data.spec = nil
			-- data.banned = nil
			-- data.private_maps = nil
			-- data.hidden = nil

			data.parkour = nil
			data.drawbattle = nil
		end
	}

	function savePlayerData(player)
		if not players_file[player] then return end

		if not to_save[player] then
			to_save[player] = true
			system.loadPlayerData(player)
		end
	end

	local function updateData(player, data)
		if not data.v and not data.parkour then
			if data.modules then
				data.parkour = {v = "0.0"}
			else
				data.parkour = {
					v = "0.1", -- version
					c = 0 -- completed maps
				}
			end
		end

		local migration = data_migrations[data.v or data.parkour.v or "0.0"]
		while migration do
			migration(player, data)
			migration = data_migrations[data.v or data.parkour.v]
		end
	end

	onEvent("PlayerDataLoaded", function(player, data)
		if player == send_channel or player == recv_channel then return end
		if in_room[player] then return end

		if data == "" then
			data = {}
		else
			local done
			done, data = pcall(json.decode, data)

			if not done then
				data = {}
			end
		end

		updateData(player, data)

		local commu = data.commu or "xx"
		if not data.hidden then
			online[player] = commu
		else
			hidden[player] = commu
		end

		eventOutPlayerDataParsed(player, data)
	end)

	onEvent("PlayerDataLoaded", function(player, data)
		if player == send_channel or player == recv_channel then return end
		if not in_room[player] then return end

		if data == "" then
			data = {}
		else
			local done
			done, data = pcall(json.decode, data)

			if not done then
				data = {}
				translatedChatMessage("corrupt_data", player)
			end
		end

		updateData(player, data)

		local commu = data.commu or "xx"
		if not data.hidden then
			online[player] = commu
		else
			hidden[player] = commu
		end

		if players_file[player] then
			local old = players_file[player]
			if old.killed < data.killed then
				old.killed = data.killed
				translatedChatMessage("kill_minutes", player, math.ceil((data.killed - os.time()) / 1000 / 60))
				if os.time() < data.killed then
					no_powers[player] = true
					unbind(player)
				else
					no_powers[player] = false
					if victory[player] then
						bindNecessary(player)
					end
				end
			end

			local p_badges = data.badges
			for index = 1, #badges do
				if badges[index].filePriority then
					if old.badges[index] ~= p_badges[index] then
						old.badges[index] = p_badges[index]
						NewBadgeInterface:show(player, index, math.max(p_badges[index], 1))
					end
				end
			end

			eventPlayerDataUpdated(player, data)

			if to_save[player] then
				to_save[player] = false
				system.savePlayerData(player, json.encode(old))
			end
			return
		end

		players_file[player] = data
		players_file[player].room = room.name

		if room.playerList[player] then
			players_file[player].commu = room.playerList[player].community
		end

		eventPlayerDataParsed(player, data)

		system.savePlayerData(
			player,
			json.encode(players_file[player])
		)
	end)

	onEvent("SavingFile", function(id, data)
		system.saveFile(filemanagers[id]:dump(data), id)
	end)

	onEvent("FileLoaded", function(id, data)
		data = filemanagers[id]:load(data)
		eventGameDataLoaded(data)
		if data.ranking or data.weekranking then -- the only file that can get written by rooms
			eventSavingFile(id, data) -- if it is reaching a critical point, it will pause and then save the file
		end
	end)

	onEvent("Loop", function()
		local now = os.time()
		if now >= next_file_load then
			system.loadFile(file_id)
			next_file_load = now + math.random(60500, 63000)
			file_index = file_index % total_files + 1
			file_id = files[file_index]
		end
	end)

	onEvent("GameStart", function()
		system.loadFile(file_id)
		local ts = os.time()

		next_file_load = ts + math.random(60500, 90500)
		file_index = file_index % total_files + 1
		file_id = files[file_index]

		local now = os.date("*t", ts / 1000) -- os.date is weird in tfm, *t accepts seconds, %d/%m/%Y accepts ms
		now.wday = now.wday - 1
		if now.wday == 0 then
			now.wday = 7
		end
		timed_maps.week.last_reset = os.date("%d/%m/%Y", ts - (now.wday - 1) * 24 * 60 * 60 * 1000)
		timed_maps.week.next_reset = os.date("%d/%m/%Y", ts + (8 - now.wday) * 24 * 60 * 60 * 1000)
	end)

	onEvent("NewPlayer", function(player)
		players_file[player] = nil -- don't cache lol
		system.loadPlayerData(player)
	end)

	onEvent("PlayerDataParsed", function(player, data)
		if data.week_r ~= timed_maps.week.last_reset then
			data.week_c = 0
			data.week_r = timed_maps.week.last_reset
		end
	end)

	onEvent("PacketReceived", function(packet_id, packet)
		if packet_id == 2 then -- update pdata
			if in_room[packet] then
				system.loadPlayerData(packet)
			end
		end
	end)
	--[[ End of file modes/parkour/files.lua ]]--
	--[[ File modes/parkour/ranks.lua ]]--
	local band = (bit or bit32).band
	local bxor = (bit or bit32).bxor

	ranks = {
		admin = {_count = 0},
		bot = {_count = 0},
		manager = {_count = 0},
		mod = {_count = 0},
		mapper = {_count = 0},
		trainee = {_count = 0},
		translator = {_count = 0}
	}
	local ranks_id = {
		admin = 2 ^ 0,
		manager = 2 ^ 1,
		mod = 2 ^ 2,
		mapper = 2 ^ 3,
		trainee = 2 ^ 4,
		translator = 2 ^ 5,
		bot = 2 ^ 6
	}
	local ranks_permissions = {
		admin = {}, -- will get every permission
		bot = {}, -- will get every permission
		manager = {
			force_stats = true,
			set_room_limit = true,
			set_map_time = true,
			hide = true,
			handle_map_polls = true,
			see_map_polls = true,
			give_command = true
		},
		mod = {
			ban = true,
			unban = true,
			spectate = true,
			get_player_room = true,
			change_map = true,
			load_custom_map = true,
			kill = true,
			see_private_maps = true,
			use_tracker = true,
			hide = true
		},
		mapper = {
			change_map = true,
			load_custom_map = true,
			enable_review = true,
			hide = true,
			start_round_poll = true,
			see_map_polls = true,
			set_map_time_review = true
		},
		trainee = {
			kill = true,
			spectate = true,
			change_map = true,
			get_player_room = true,
			see_private_maps = true,
			use_tracker = true
		},
		translator = {
			change_map = true,
			hide = true
		}
	}
	player_ranks = {}
	perms = {}

	for rank, perms in next, ranks_permissions do
		if rank ~= "admin" and rank ~= "bot" then
			for perm_name, allowed in next, perms do
				ranks_permissions.admin[perm_name] = allowed
				ranks_permissions.bot[perm_name] = allowed
			end
		end
	end

	onEvent("GameDataLoaded", function(data)
		if data.ranks then
			ranks, perms, player_ranks = {
				admin = {_count = 0},
				bot = {_count = 0},
				manager = {_count = 0},
				mod = {_count = 0},
				mapper = {_count = 0},
				trainee = {_count = 0},
				translator = {_count = 0}
			}, {}, {}
			local player_perms, _player_ranks
			for player, rank in next, data.ranks do
				player_perms, _player_ranks = {}, {}
				for name, id in next, ranks_id do
					if band(rank, id) > 0 then
						_player_ranks[name] = true
						ranks[name][player] = true
						ranks[name]._count = ranks[name]._count + 1
						ranks[name][ ranks[name]._count ] = player
						for perm, enabled in next, ranks_permissions[name] do
							player_perms[perm] = enabled
						end
					end
				end
				player_ranks[player] = _player_ranks
				perms[player] = player_perms
			end
		end
	end)
	--[[ End of file modes/parkour/ranks.lua ]]--
	--[[ File modes/parkour/powers.lua ]]--
	local max_leaderboard_rows
	local leaderboard
	local keyboard

	no_powers = {}
	local facing = {}
	local cooldowns = {}
	local obj_whitelist = {_count = 0, _index = 1}
	local keybindings = {}
	local used_powers = {_count = 0}

	-- Keep track of the times the key has been binded and wrap system.bindKeyboard
	function bindKeyboard(player, key, down, active)
		if not keybindings[player] then
			if not active then return end

			keybindings[player] = {
				[key] = {
					[down] = 0,
					[not down] = 0
				}
			}
		end

		local keyInfo = keybindings[player][key]
		if not keyInfo then
			if not active then return end

			keyInfo = {
				[down] = 1,
				[not down] = 0
			}
			keybindings[player][key] = keyInfo
		elseif active then
			keyInfo[down] = keyInfo[down] + 1
		else
			keyInfo[down] = keyInfo[down] - 1
		end

		if keyInfo[down] == 1 then
			system.bindKeyboard(player, key, down, true)
		elseif keyInfo[down] == 0 then
			system.bindKeyboard(player, key, down, false)
		end
	end

	local function addShamanObject(id, x, y, ...)
		obj_whitelist._count = obj_whitelist._count + 1
		obj_whitelist[obj_whitelist._count] = {id, x, y}
		return tfm.exec.addShamanObject(id, x, y, ...)
	end

	function checkCooldown(player, name, long, img, x, y, show)
		if cooldowns[player] then
			if cooldowns[player][name] and os.time() < cooldowns[player][name] then
				return false
			end
			cooldowns[player][name] = os.time() + long
		else
			cooldowns[player] = {
				[name] = os.time() + long
			}
		end

		if show then
			addNewTimer(
				long, tfm.exec.removeImage,
				tfm.exec.addImage(img, ":1", x, y, player)
			)
		end

		return true
	end

	local function despawnableObject(when, ...)
		local obj = addShamanObject(...)
		addNewTimer(when, tfm.exec.removeObject, obj)
	end

	local function fixHourCount(player, data)
		local reset = data.hour_r
		local hour = data.hour
		local count = #hour
		local save = false

		local now = os.time()
		if now - reset >= 3600000 then -- 1 hour
			save = true

			local index
			local absolute
			for i = 1, count do
				absolute = hour[i] * 10000 + reset

				if now - absolute >= 3600000 then
					hour[i] = nil
				else
					index = i + 1 -- avoid hour check as they're younger than 1 hour
					-- change offset
					hour[i] = math.floor((absolute - now) / 10000)
					break
				end
			end

			if index then
				for i = index, count do
					hour[i] = math.floor(
						(hour[i] * 10000 + reset - now) / 10000
					)
				end
			end

			data.hour_r = now
			reset = now
		else
			for i = 1, count do
				if now - (hour[i] * 10000 + reset) >= 3600000 then
					hour[i] = nil
				else
					break
				end
			end
		end

		-- Normalize indexes
		local offset = 0
		for i = 1, count do
			if hour[i] then
				if offset == 0 then
					break
				end

				hour[i - offset] = hour[i]
			else
				offset = offset + 1
			end
		end

		for i = count - offset + 1, count do
			hour[i] = nil
		end

		if player and (save or offset > 0) then
			savePlayerData(player)
		end
	end

	-- in small x: positive -> towards the sides, negative -> towards the center
	local powers
	powers = {
		{
			name = "fly", maps = 5,
			dontShowTracker = true,
			availableRecords = true,

			small = "173db50edf6.png", big = "173db512e9c.png", -- icons
			lockedSmall = "173db51091f.png", lockedBig = "173db5151fd.png",
			smallX = 0, smallY = -10,
			bigX = 0, bigY = -10,

			cooldown = nil,
			default = {5, 4}, -- SPACE

			fnc = function(player, key, down, x, y)
				tfm.exec.movePlayer(player, 0, 0, true, 0, -50, false)
			end
		},
		{
			name = "speed", maps = 10,
			dontShowTracker = true,
			availableRecords = true,

			small = "173db21af6a.png", big = "173db214773.png",
			lockedSmall = "173db21d270.png", lockedBig = "173db217990.png",
			smallX = 0, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 8,
			cooldown_y = 373,
			cooldown_img = "17127e682ff.png",

			cooldown = 1000,
			default = {4, 1}, -- SHIFT

			fnc = function(player, key, down, x, y)
				tfm.exec.movePlayer(player, 0, 0, true, facing[player] and 60 or -60, 0, true)
			end
		},
		{
			name = "snowball", maps = 15,

			small = "173db1165c1.png", big = "173db111ba4.png",
			lockedSmall = "173db118b89.png", lockedBig = "173db114395.png",
			smallX = 0, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 30,
			cooldown_y = 374,
			cooldown_img = "17127e6674c.png",

			cooldown = 5000,
			default = {2, 4}, -- E

			fnc = function(player, key, down, x, y)
				local right = facing[player]
				despawnableObject(5000, 34, x + (right and 20 or -20), y, 0, right and 10 or -10)
			end
		},
		{
			name = "balloon", maps = 20,

			small = "173db033fb8.png", big = "173db02a545.png",
			lockedSmall = "173db039519.png", lockedBig = "173db035f01.png",
			smallX = 0, smallY = -10,
			bigX = 0, bigY = 0,

			cooldown_x = 52,
			cooldown_y = 372,
			cooldown_img = "17127e5b2d5.png",

			cooldown = 10000,
			default = {2, 2}, -- Q, A

			fnc = function(player, key, down, x, y)
				despawnableObject(2000, 28, x, y + 10)
			end,

			upgrades = {
				{
					name = "masterBalloon", maps = 200,

					small = "173db167a26.png", big = "173db165783.png",
					smallX = 0, smallY = 10,
					bigX = 0, bigY = 10,

					cooldown_img = "17127e62809.png",

					fnc = function(player, key, down, x, y)
						despawnableObject(3000, 2804, x, y + 10)
					end
				},
				{
					name = "bubble", maps = 400,

					small = "173db16a824.png", big = "173db175547.png",
					smallX = 0, smallY = 0,
					bigX = 0, bigY = 0,

					cooldown_img = "17127e5ca47.png",

					fnc = function(player, key, down, x, y)
						despawnableObject(4000, 59, x, y + 12)
					end
				},
			}
		},
		{
			name = "teleport", maps = 35,
			dontShowTracker = true,
			availableRecords = true,

			small = "173db226b7a.png", big = "173db21f2b7.png",
			lockedSmall = "173db22ee81.png", lockedBig = "173db223336.png",
			smallX = 10, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 74,
			cooldown_y = 373,
			cooldown_img = "17127e73965.png",

			cooldown = 10000,
			click = true,

			fnc = tfm.exec.movePlayer
		},
		{
			name = "smallbox", maps = 50,

			small = "173db0ecb64.png", big = "173db0cd7fb.png",
			lockedSmall = "173db0d3c0b.png", lockedBig = "173db0d172b.png",
			smallX = 10, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 96,
			cooldown_y = 373,
			cooldown_img = "17127e77dbe.jpg",

			cooldown = 10000,
			default = {4, 3}, -- Z, W

			fnc = function(player, key, down, x, y)
				despawnableObject(3000, 1, x, y + 10)
			end
		},
		{
			name = "cloud", maps = 100,

			small = "173db14a1d6.png", big = "173db145497.png",
			lockedSmall = "173db15baf3.png", lockedBig = "173db15868b.png",
			smallX = 0, smallY = 10,
			bigX = 0, bigY = 20,

			cooldown_x = 121,
			cooldown_y = 377,
			cooldown_img = "17127e5f927.png",

			cooldown = 10000,
			default = {4, 4}, -- X

			fnc = function(player, key, down, x, y)
				despawnableObject(2000, 57, x, y + 10)
			end
		},
		{
			name = "rip", maps = 700,

			small = "173db33e169.png", big = "173db33602c.png",
			lockedSmall = "173db3407b0.png", lockedBig = "173db33ac9c.png",
			smallX = 0, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 142,
			cooldown_y = 373,
			cooldown_img = "17127e69ea4.png",

			cooldown = 10000,
			default = {4, 6}, -- V

			fnc = function(player, key, down, x, y)
				despawnableObject(4000, 90, x, y + 10)
			end
		},
		{
			name = "choco", maps = 1500,

			small = "173db2812bc.png", big = "173db27b241.png",
			lockedSmall = "173db2853a0.png", lockedBig = "173db27dba6.png",
			smallX = 0, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 164,
			cooldown_y = 374,
			cooldown_img = "17127fc6b27.png",

			cooldown = 25000,
			default = {5, 1}, -- CTRL

			fnc = function(player, key, down, x, y)
				despawnableObject(4000, 46, x + (facing[player] and 20 or -20), y - 30, 90)
			end
		},
		{
			name = "bigBox", maps = 2500,

			small = "173db0ecb64.png", big = "173db0cd7fb.png",
			lockedSmall = "173db0d3c0b.png", lockedBig = "173db0d172b.png",
			smallX = 0, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 186,
			cooldown_y = 374,
			cooldown_img = "17127e77dbe.jpg",

			cooldown = 25000,
			default = {4, 7}, -- B

			fnc = function(player, key, down, x, y)
				despawnableObject(4000, 2, x, y + 10, 0)
			end
		},
		{
			name = "trampoline", maps = 4000,

			small = "173db3307ed.png", big = "173db3288d3.png",
			lockedSmall = "173db3335b7.png", lockedBig = "173db32e496.png",
			smallX = 0, smallY = 0,
			bigX = 0, bigY = 0,

			cooldown_x = 208,
			cooldown_y = 374,
			cooldown_img = "171cd9f5188.png",

			cooldown = 25000,
			default = {4, 8}, -- N

			fnc = function(player, key, down, x, y)
				despawnableObject(4000, 701, x, y + 10, 0)
			end
		},
		{
			name = "pig", maps = 5000,

			small = "173deea75bd.png", big = "173deea2cc0.png",
			lockedSmall = "173deea9a02.png", lockedBig = "173deea4edc.png",
			smallX = 0, smallY = 20,
			bigX = 0, bigY = 15,

			cooldown_x = 229,
			cooldown_y = 380,
			cooldown_img = "1741cfb9868.png",

			cooldown = 30000,
			default = {3, 9}, -- K

			piggies = {
				"17404198506.png", -- angry
				"174042180f2.png", -- crying
				"174042d5ba0.png", -- love
				"174042eda4f.png", -- blushed
				"174043b0085.png", -- clown
				"1740455e72a.png", -- glasses
				"1740455bd82.png", -- smoking
				"17404561700.png", -- glasses blushed
				"1745e9316ae.png", -- roasted
			},

			fnc = function(player, key, down, x, y)
				local id1 = bit32.bxor(room.playerList[player].id, 32768) -- unfortunately physicobjects only use 16 bits as id
				local id2 = bit32.bxor(room.playerList[player].id, 16384)
				local sprite = powers.pig.piggies[math.random(#powers.pig.piggies)]
				local img = tfm.exec.addImage(sprite, "_51", x - 24, y - 15)

				local circles = {
					type = 14,
					friction = 0.3
				}
				tfm.exec.addPhysicObject(id1, x + 13, y, circles)
				tfm.exec.addPhysicObject(id2, x - 5, y + 2, circles)

				addNewTimer(5000, powers.pig.explode, id1, id2, img, x, y)
			end,

			explode = function(id1, id2, img, x, y)
				tfm.exec.removePhysicObject(id1)
				tfm.exec.removePhysicObject(id2)
				tfm.exec.removeImage(img)

				for confetti = 1, 10 do
					tfm.exec.displayParticle(math.random(21, 24), x, y, math.random(-10, 10), math.random(-10, 10))
				end
				tfm.exec.explosion(x, y, 10, 100, true)
			end
		},
		{
			name = "sink", ranking = 70,

			small = "173deeb1e05.png", big = "173deeac174.png",
			lockedSmall = "173deeb3dac.png", lockedBig = "173deeaf781.png",
			smallX = 0, smallY = 10,
			bigX = 5, bigY = 10,

			cooldown_x = 252,
			cooldown_y = 374,
			cooldown_img = "1741cfd281e.png",

			cooldown = 30000,
			default = {4, 5}, -- C

			fnc = function(player, key, down, x, y)
				local id = room.playerList[player].id
				local img = tfm.exec.addImage("17426b19d76.png", "_51", x - 20, y - 10)
				tfm.exec.addPhysicObject(id, x, y + 13, {
					type = 14,
					friction = 0.3,
					width = 30
				})

				addNewTimer(5000, powers.sink.despawn, id, img)
			end,

			despawn = function(id, img)
				tfm.exec.removePhysicObject(id)
				tfm.exec.removeImage(img)
			end,

			upgrades = {
				{
					name = "toilet", ranking = 56,

					small = "173db3f2c95.png", big = "173db3f0d81.png",
					smallX = 0, smallY = -10,
					bigX = 10, bigY = 0,

					cooldown_img = "171cd9e02d3.png",

					fnc = function(player, key, down, x, y)
						local id = room.playerList[player].id
						local img = tfm.exec.addImage("171cd3eddf1.png", "_51", x - 20, y - 20)
						tfm.exec.addPhysicObject(id, x, y + 13, {
							type = 14,
							friction = 0.3,
							width = 30
						})

						addNewTimer(5000, powers.toilet.water, img, id, x, y)
					end,

					water = function(img, id, x, y)
						tfm.exec.removeImage(img)

						local obj = addShamanObject(63, x, y)
						tfm.exec.addPhysicObject(id, x, y - 20, {
							type = 9,
							width = 30,
							height = 60,
							miceCollision = false,
							groundCollision = false,
							foreground = true
						})

						addNewTimer(5000, powers.toilet.despawn, id, obj)
					end,

					despawn = function(id, obj)
						tfm.exec.removePhysicObject(id)
						tfm.exec.removeObject(obj)
					end
				},
				{
					name = "bathtub", ranking = 42,

					small = "173deeb8924.png", big = "173deeb6576.png",
					smallX = 0, smallY = 5,
					bigX = 5, bigY = 10,

					cooldown_img = "1741cfd8396.png",

					fnc = function(player, key, down, x, y)
						local id = room.playerList[player].id
						local img = tfm.exec.addImage("17426f98ce6.png", "!1", x - 48, y - 65)
						tfm.exec.addPhysicObject(id, x, y + 13, {
							type = 14,
							friction = 0.3,
							width = 80
						})

						addNewTimer(5000, powers.bathtub.water, img, id, x, y)
					end,

					water = function(img, id, x, y)
						tfm.exec.removeImage(img)

						tfm.exec.addPhysicObject(id, x, y - 40, {
							type = 9,
							width = 90,
							height = 80,
							miceCollision = false,
							groundCollision = false,
							foreground = true
						})

						addNewTimer(5000, powers.bathtub.despawn, id)
					end,

					despawn = function(id, obj)
						tfm.exec.removePhysicObject(id)
					end
				},
			}
		},
		{
			name = "campfire", ranking = 28,
			dontShowTracker = true,
			availableRecords = true,

			small = "173dee9c5d9.png", big = "173dee98c61.png",
			lockedSmall = "173dee9e873.png", lockedBig = "173dee9aaea.png",
			smallX = 0, smallY = 10,
			bigX = 0, bigY = 10,

			cooldown_x = 274,
			cooldown_y = 376,
			cooldown_img = "1741cfdadc9.png",

			cooldown = 15000,
			default = {3, 8}, -- J

			fnc = function(player, key, down, x, y)
				local id = room.playerList[player].id + 2147483648 -- makes 32nd bit 1 so it doesn't play around with the interface textareas

				local img = tfm.exec.addImage("17426539be5.png", "_51", x - 30, y - 26)
				ui.addTextArea(id, "<a href='event:emote:11'>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", nil, x - 32, y - 26, 64, 56, 0, 0, 0)
				addNewTimer(powers.campfire.cooldown, powers.campfire.despawn, img, id)
			end,

			despawn = function(img, id)
				tfm.exec.removeImage(img)
				ui.removeTextArea(id)
			end
		},
		{
			name = "chair", ranking = 14,

			small = "1745a769e88.png", big = "1745a765105.png",
			lockedSmall = "1745a76c506.png", lockedBig = "1745a7675e6.png",
			smallX = 0, smallY = 10,
			bigX = 10, bigY = 10,

			cooldown_x = 296,
			cooldown_y = 376,
			cooldown_img = "17459a21979.png",

			cooldown = 15000,
			default = {3, 6}, -- G

			fnc = function(player, key, down, x, y)
				local id = bit32.bxor(room.playerList[player].id, 49152)
				local img = tfm.exec.addImage("17459a230e9.png", "_51", x - 30, y - 20)
				tfm.exec.addPhysicObject(id, x - 5, y + 20, {
					type = 14,
					friction = 0.3,
					width = 32
				})

				addNewTimer(14000, powers.chair.despawn, id, img)
			end,

			despawn = function(id, img)
				tfm.exec.removePhysicObject(id)
				tfm.exec.removeImage(img)
			end
		},
	}

	local keys = {
		triggers = {}
	}

	local function getPowerUpgrade(completed, pos, power, strict, with_review)
		if with_review then
			if not power.upgrades then return power end
			return power.upgrades[#power.upgrades]
		end

		if strict then
			if power.ranking and power.ranking < pos then return end
			if not power.ranking and completed < power.maps then return end
		end

		if not power.upgrades then return power end

		local upgrade
		for index = #power.upgrades, 1, -1 do
			upgrade = power.upgrades[index]
			if upgrade.ranking then
				if upgrade.ranking >= pos then
					return upgrade
				end
			elseif (completed or 0) >= upgrade.maps then
				return upgrade
			end
		end

		return power
	end

	function bindNecessary(player)
		if not keys[player] or not players_file[player] or keys.triggers[player] then return end

		local triggers = {}
		local completed = players_file[player].c
		local pos = leaderboard[player] or max_leaderboard_rows + 1
		local variation_index = players_file[player].settings[5] + 1

		local player_keys = keys[player]
		local power, key
		for index = 1, #powers do
			power = getPowerUpgrade(completed, pos, powers[index], true, review_mode)

			if power and (not records_admins or power.availableRecords) then
				if power.click then
					system.bindMouse(player, true)
				else
					if player_keys[index] then
						key = player_keys[index]
					elseif powers[index].key[1] then -- variation qwerty/azerty
						key = keyboard.bindings[ powers[index].key[variation_index] ]
					else
						key = keyboard.bindings[ powers[index].key ]
					end

					if triggers[key] then
						triggers[key]._count = triggers[key]._count + 1
						triggers[key][ triggers[key]._count ] = power
					else
						triggers[key] = {_count = 1, [1] = power}
						bindKeyboard(player, key, true, true)
					end
				end
			end
		end

		bindKeyboard(player, 0, true, true)
		bindKeyboard(player, 2, true, true)

		keys.triggers[player] = triggers
	end

	function unbind(player)
		if not keys.triggers[player] then return end

		bindKeyboard(player, 0, true, false)
		bindKeyboard(player, 2, true, false)
		for key in next, keys.triggers[player] do
			bindKeyboard(player, key, true, false)
		end
		system.bindMouse(player, false)

		keys.triggers[player] = nil
	end

	onEvent("Keyboard", function(player, key, down, x, y)
		if not victory[player] or not players_file[player] or not keys.triggers[player] then return end
		if spec_mode[player] then return end

		if key == 0 or key == 2 then
			facing[player] = key == 2
			return
		end

		local power = keys.triggers[player][key]
		if power then
			for index = 1, power._count do
				if power[index] and (not power[index].cooldown or checkCooldown(
					player, power[index].name, power[index].cooldown,

					power[index].cooldown_img,
					power[index].cooldown_x, power[index].cooldown_y,

					players_file[player].settings[3] == 1
				)) and (not records_admins or power[index].availableRecords) then
					power[index].fnc(player, key, down, x, y)

					if not power[index].dontShowTracker then
						used_powers._count = used_powers._count + 1
						used_powers[ used_powers._count ] = {player, power[index].name}
					end
				end
			end
		end
	end)

	onEvent("Mouse", function(player, x, y)
		if not victory[player] or not players_file[player] then return end

		local power = powers.teleport
		if players_file[player].c >= power.maps then
			if (not power.cooldown or checkCooldown(
				player, power.name, power.cooldown,

				power.cooldown_img,
				power.cooldown_x, power.cooldown_y,

				players_file[player].settings[3] == 1
			)) and (not records_admins or power.availableRecords) then
				power.fnc(player, x, y)

				if not power.dontShowTracker then
					used_powers._count = used_powers._count + 1
					used_powers[ used_powers._count ] = {player, power.name}
				end
			end
		end
	end)

	onEvent("GameStart", function()
		local upgrade
		for index = 1, #powers do
			powers[ powers[index].name ] = powers[index]

			if powers[index].upgrades then
				for _index = 1, #powers[index].upgrades do
					upgrade = powers[index].upgrades[_index]
					powers[ upgrade.name ] = upgrade

					upgrade.cooldown_x = powers[index].cooldown_x
					upgrade.cooldown_y = powers[index].cooldown_y
					upgrade.cooldown = powers[index].cooldown
				end
			end
		end
	end)

	onEvent("PlayerLeft", function(player)
		keys.triggers[player] = nil
		keybindings[player] = nil
	end)

	onEvent("PlayerDataParsed", function(player, data)
		keys[player] = {}
		for index = 1, #data.keys do
			if data.keys[index] > 0 then
				keys[player][index] = data.keys[index]
			end
		end

		if data.killed > os.time() then
			no_powers[player] = true
			translatedChatMessage("kill_minutes", player, math.ceil((data.killed - os.time()) / 1000 / 60))
		else
			no_powers[player] = nil
		end

		if victory[player] then
			if not no_powers[player] then
				bindNecessary(player)
			end
		else
			unbind(player)
		end

		-- don't save as it will trigger this twice, and this will be saved
		-- right after this event finishes anyway
		fixHourCount(nil, data)
	end)

	onEvent("PlayerDataUpdated", function(player, data)
		if data.killed > os.time() then
			if not no_powers[player] then
				no_powers[player] = true
				unbind(player)
			end
			translatedChatMessage("kill_minutes", player, math.ceil((data.killed - os.time()) / 1000 / 60))
		elseif no_powers[player] then
			no_powers[player] = nil
			if victory[player] then
				bindNecessary(player)
			end
		end

		fixHourCount(player, data)
	end)

	onEvent("PlayerWon", function(player)
		if bans[ room.playerList[player].id ] then return end
		if not players_file[player] then return end

		if (count_stats and
			room.uniquePlayers >= min_save and
			player_count >= min_save and
			not records_admins and
			not is_tribe and
			not review_mode) then

			local file = players_file[player]
			file.c = file.c + 1
			file.hour[#file.hour + 1] = math.floor((os.time() - file.hour_r) / 10000) -- convert to ms and count every 10s
			file.week[1] = file.week[1] + 1

			local hour_count = #file.hour

			if hour_count >= 30 and hour_count % 5 == 0 then
				if hour_count >= 35 then
					sendPacket(3, room.name .. "\000" .. room.playerList[player].id .. "\000" .. player .. "\000" .. hour_count)
				end

				local badge = math.ceil((hour_count - 29) / 5)
				if badge <= #badges[4] then
					if file.badges[4] == 0 or file.badges[4] < badge then
						file.badges[4] = badge
						NewBadgeInterface:show(player, 4, badge)
					end
				end
			end

			savePlayerData(player)
		end

		if not no_powers[player] then
			bindNecessary(player)
		end
	end)

	onEvent("NewGame", function()
		local now = os.time()

		local to_remove, count = {}, 0
		for player in next, no_powers do
			if not players_file[player] or players_file[player].killed <= now then
				count = count + 1
				to_remove[count] = player
			end
		end

		for index = 1, count do
			no_powers[to_remove[index]] = nil
		end

		facing = {}
		cooldowns = {}
		obj_whitelist = {_count = 0, _index = 1}

		setmetatable(room.objectList, {
			__newindex = function(self, key, value)
				if self[key] == value then return end

				rawset(self, key, value)

				local obj
				for index = obj_whitelist._index, obj_whitelist._count do
					obj = obj_whitelist[index]
					if obj[1] ~= value.type or obj[2] ~= value.x or obj[3] ~= value.y then
						tfm.exec.removeObject(key)
					else
						obj_whitelist._index = index + 1
					end
					break
				end
			end
		})

		local file
		for player in next, in_room do
			file = players_file[player]
			if file then
				fixHourCount(player, file)
			end
			unbind(player)
		end
	end)
	--[[ End of file modes/parkour/powers.lua ]]--
	--[[ File modes/parkour/leaderboard.lua ]]--
	max_leaderboard_rows = 70
	max_weekleaderboard_rows = 28
	local max_leaderboard_pages = math.ceil(max_leaderboard_rows / 14) - 1
	local max_weekleaderboard_pages = math.ceil(max_weekleaderboard_rows / 14) - 1
	local loaded_leaderboard = false
	leaderboard = {}
	weekleaderboard = {}
	-- {id, name, completed_maps, community}
	local default_leaderboard_user = {0, nil, 0, "xx"}

	local function leaderboardSort(a, b)
		return a[3] > b[3]
	end

	local remove, sort = table.remove, table.sort

	local function checkPlayersPosition(week)
		local max_lb_rows = week and max_weekleaderboard_rows or max_leaderboard_rows
		local lb = week and weekleaderboard or leaderboard
		local totalRankedPlayers = #lb
		local cachedPlayers = {}

		local playerId, position

		local toRemove, counterRemoved = {}, 0
		for player = 1, totalRankedPlayers do
			position = lb[player]
			playerId = position[1]

			if bans[playerId] then
				counterRemoved = counterRemoved + 1
				toRemove[counterRemoved] = player
			else
				cachedPlayers[playerId] = position
			end
		end

		for index = counterRemoved, 1, -1 do
			remove(lb, toRemove[index])
		end
		toRemove = nil

		totalRankedPlayers = totalRankedPlayers - counterRemoved

		local cacheData
		local playerFile, playerData, completedMaps

		for player in next, in_room do
			playerFile = players_file[player]

			if playerFile then
				completedMaps = week and playerFile.week[1] or playerFile.c
				playerData = room.playerList[player]
				if playerData then
					playerId = playerData.id

					if not bans[playerId] then
						cacheData = cachedPlayers[playerId]
						if cacheData then
							cacheData[2] = player
							cacheData[3] = completedMaps
							cacheData[4] = playerData.community
						else
							totalRankedPlayers = totalRankedPlayers + 1
							lb[totalRankedPlayers] = {
								playerId,
								player,
								completedMaps,
								playerData.community
							}
						end
					end
				end
			end
		end

		sort(lb, leaderboardSort)

		for index = max_lb_rows + 1, totalRankedPlayers do
			lb[index] = nil
		end

		if not week then
			local name, badges, badge
			for pos = 1, #lb do
				name = lb[pos][2]
				lb[name] = pos

				if players_file[name] then
					badges = players_file[name].badges
					badge = math.ceil(pos / 14)

					if badges[2] == 0 or badges[2] > badge then
						badges[2] = badge
						NewBadgeInterface:show(name, 2, badge)
						savePlayerData(name)
					end
				end
			end
		else
			for index = 1, #lb do
				lb[lb[index][2]] = index
			end
		end
	end

	onEvent("GameDataLoaded", function(data)
		if data.ranking then
			if not loaded_leaderboard then
				loaded_leaderboard = true

				translatedChatMessage("leaderboard_loaded")
			end

			leaderboard = data.ranking

			checkPlayersPosition(false)
		end
		if data.weekranking then
			local ts = os.time()
			local now = os.date("*t", ts / 1000)
			now.wday = now.wday - 1
			if now.wday == 0 then
				now.wday = 7
			end

			local new_reset = os.date("%d/%m/%Y", ts - (now.wday - 1) * 24 * 60 * 60 * 1000)
			if new_reset ~= timed_maps.week.last_reset then
				if #data.weekranking > 2 and data.weekranking[1][3] > 30 then
					sendPacket(
						4,
						timed_maps.week.last_reset .. "\000" .. os.date("%d/%m/%Y", ts - 24 * 60 * 60 * 1000) ..
						"\000" .. data.weekranking[1][4] .. "\000" .. data.weekranking[1][2] .. "\000" .. data.weekranking[1][3] ..
						"\000" .. data.weekranking[2][4] .. "\000" .. data.weekranking[2][2] .. "\000" .. data.weekranking[2][3] ..
						"\000" .. data.weekranking[3][4] .. "\000" .. data.weekranking[3][2] .. "\000" .. data.weekranking[3][3]
					)
					system.loadPlayerData(send_channel) -- force send
				end

				timed_maps.week.last_reset = new_reset
				timed_maps.week.next_reset = os.date("%d/%m/%Y", ts + (8 - now.wday) * 24 * 60 * 60 * 1000)

				for player, data in next, players_file do
					data.week = {0, new_reset}
				end

				data.weekranking = {}
			end

			weekleaderboard = data.weekranking

			checkPlayersPosition(true)
		end
	end)
	--[[ End of file modes/parkour/leaderboard.lua ]]--
	--[[ File modes/parkour/chat-ui.lua ]]--
	-- Stuff related to the chat (not keyboard nor interface)

	local fetching_player_room = {}
	local roompw = {}
	local fastest = {}

	local GameInterface
	local setNameColor

	local function capitalize(str)
		local first = string.sub(str, 1, 1)
		if first == "+" then
			return "+" .. string.upper(string.sub(str, 2, 2)) .. string.lower(string.sub(str, 3))
		else
			return string.upper(first) .. string.lower(string.sub(str, 2))
		end
	end

	local function checkRoomRequest(player, data)
		local fetch = fetching_player_room[player]
		if fetch then
			if data.commu then
				tfm.exec.chatMessage("<v>[#] <d>" .. player .. "<n>'s community: <d>" .. data.commu, fetch[1])
			end
			if data.room then
				tfm.exec.chatMessage("<v>[#] <d>" .. player .. "<n>'s room: <d>" .. data.room, fetch[1])
			end
			fetching_player_room[player] = nil
		end
	end

	onEvent("NewGame", function()
		fastest = {}

		if is_tribe then
			translatedChatMessage("tribe_house")
		elseif room.uniquePlayers < min_save then
			translatedChatMessage("min_players", nil, room.uniquePlayers, min_save)
		end
	end)

	onEvent("NewPlayer", function(player)
		if levels then
			if is_tribe then
				translatedChatMessage("tribe_house", player)
			elseif room.uniquePlayers < min_save then
				translatedChatMessage("min_players", player, room.uniquePlayers, min_save)
			end
		end
	end)

	onEvent("PlayerWon", function(player)
		local id = room.playerList[player].id
		if bans[id] then return end
		if not players_file[player] then return end

		if records_admins then
			translatedChatMessage("records_completed", player)
		end

		-- If the player joined the room after the map started,
		-- eventPlayerWon's time is wrong. Also, eventPlayerWon's time sometimes bug.
		local taken = (os.time() - (generated_at[player] or map_start)) / 1000

		if not records_admins and count_stats and taken <= 45 and not review_mode and not is_tribe then
			sendPacket(1, room.name .. "\000" .. player .. "\000" .. id .. "\000" .. room.currentMap .. "\000" .. taken)
		end
		if not fastest.record or taken < fastest.record then
			local old = fastest.player

			fastest.record = taken
			fastest.player = player
			fastest.submitted = nil

			if old and in_room[old] then
				setNameColor(old)
			end

			if records_admins then
				translatedChatMessage("records_submit", player)
			end
		end

		if players_file[player].settings[7] == 0 then
			translatedChatMessage("finished", player, player, taken)
		end

		for _player in next, in_room do
			if players_file[_player] and players_file[_player].settings[7] == 1 then
				translatedChatMessage("finished", _player, player, taken)
			end
		end

		if is_tribe then
			translatedChatMessage("tribe_house", player)
		elseif room.uniquePlayers < min_save or player_count < min_save then
			translatedChatMessage("min_players", player, room.uniquePlayers, min_save)
		elseif count_stats and not review_mode then
			local power
			for index = 1, #powers do
				power = powers[index]

				if players_file[player].c == power.maps then
					for _player in next, in_room do
						translatedChatMessage("unlocked_power", _player, player, translatedMessage(power.name, _player))
					end
					break
				end
			end
		end
	end)

	onEvent("ChatCommand", function(player, msg)
		local cmd, args, pointer = "", {}, -1
		for slice in string.gmatch(msg, "%S+") do
			pointer = pointer + 1
			if pointer == 0 then
				cmd = string.lower(slice)
			else
				args[pointer] = slice
			end
		end

		eventParsedChatCommand(player, cmd, pointer, args)
	end)

	onEvent("ParsedChatCommand", function(player, cmd, quantity, args)
		if cmd == "donate" then
			tfm.exec.chatMessage("<rose>" .. links.donation, player)

		elseif cmd == "discord" then
			tfm.exec.chatMessage("<rose>" .. links.discord, player)

		elseif cmd == "submit" then
			if not records_admins then return end
			local map = tonumber(string.sub(room.currentMap, 2))

			if fastest.player ~= player then
				return translatedChatMessage("records_not_fastest", player)
			end
			if fastest.submitted then
				return translatedChatMessage("records_already_submitted", player)
			end
			if not count_stats then
				local exists = false

				for index = 1, maps.high_count do
					if map == maps.list_high[index] then
						exists = true
						break
					end
				end

				if not exists then
					for index = 1, maps.low_count do
						if map == maps.list_low[index] then
							exists = true
							break
						end
					end

					if not exists then
						return translatedChatMessage("records_invalid_map", player)
					end
				end
			end

			fastest.submitted = true
			sendPacket(
				6,
				(map .. "\000" ..
				 room.playerList[player].id .. "\000" ..
				 math.floor(fastest.record * 100) .. "\000" ..
				 room.name)
			)
			translatedChatMessage("records_submitted", player, room.currentMap)

		elseif cmd == "give" then
			if not perms[player] or not perms[player].give_command then return end

			if quantity < 2 then
				return translatedChatMessage("invalid_syntax", player)
			end

			local target = capitalize(args[1])
			if not string.find(target, "#", 1, true) then
				target = target .. "#0000"
			end

			local file = players_file[target]
			if not file then
				return tfm.exec.chatMessage("<v>[#] <r>wtf u doin <b>" .. target .. "</b> is not here??¬ø¬ø¬ø", player)
			end

			local thing = string.lower(args[2])
			if thing == "maps" then
				if quantity < 4 then
					return tfm.exec.chatMessage("<v>[#] <r>u gotta specify an action and a quantity noob", player)
				end

				local action, quantity = string.lower(args[3]), tonumber(args[4])
				if not quantity then
					return tfm.exec.chatMessage("<v>[#] <r>" .. args[4] .. " doesnt look like a number; did u fail math?", player)
				end

				if action == "add" then
					file.c = file.c + quantity
				elseif action == "sub" then
					file.c = file.c - quantity
				elseif action == "set" then
					file.c = quantity
				else
					return tfm.exec.chatMessage("<v>[#] <r>" .. action .. " doesnt look like an action wtf", player)
				end

				tfm.exec.chatMessage("<v>[#] <d>" .. target .. "'s new map count: " .. file.c, player)

			elseif thing == "badge" then
				if quantity < 4 then
					return tfm.exec.chatMessage("<v>[#] <r>u gotta specify a badge group and badge id", player)
				end

				local group, badge = tonumber(args[3]), tonumber(args[4])
				if not group then
					return tfm.exec.chatMessage("<v>[#] <r>" .. args[3] .. " doesnt look like a badge group?", player)
				elseif not badge then
					return tfm.exec.chatMessage("<v>[#] <r>" .. args[4] .. " doesnt look like a badge id?", player)
				elseif group < 1 or group > #badges then
					return tfm.exec.chatMessage(
						"<v>[#] <r>there are " .. #badges .. " badge groups but u want to give the n¬∞ " .. badge .. "?", player
					)
				elseif badge < 0 or badge > #badges[group] then
					return tfm.exec.chatMessage(
						"<v>[#] <r>that group has ids 0-" .. #badges[group] .. " but u want " .. badge .. "?", player
					)
				elseif badges[group].filePriority then
					return tfm.exec.chatMessage("<v>[#] <r>that badge group can only be affected by bots", player)
				end

				file.badges[group] = badge
				if badge > 0 then
					NewBadgeInterface:show(target, group, badge)
				end

				tfm.exec.chatMessage("<v>[#] <d>badge group " .. group .. " affected on player " .. target, player)

			elseif thing == "migration" then
				file.migrated = true
				tfm.exec.chatMessage("<v>[#] <d>given migration flag to " .. target, player)

			else
				return tfm.exec.chatMessage("<v>[#] <r>idk wtf is <b>" .. thing .. "</b>", player)
			end

			savePlayerData(target)

		elseif cmd == "pw" then
			if not records_admins or not records_admins[player] then
				if not perms[player] or not perms[player].enable_review then return end

				if not review_mode and not ranks.admin[player] then
					return tfm.exec.chatMessage("<v>[#] <r>You can't set the password of a room without review mode.", player)
				end
			end

			if roompw.owner and roompw.owner ~= player and not ranks.admin[player] then
				return tfm.exec.chatMessage("<v>[#] <r>You can't set the password of this room. Ask " .. roompw.owner .. " to do so.", player)
			end

			local password = table.concat(args, " ")
			tfm.exec.setRoomPassword(password)

			if password == "" then
				roompw.owner = nil
				roompw.password = nil
				return tfm.exec.chatMessage("<v>[#] <d>Room password disabled by " .. player .. ".")
			end
			tfm.exec.chatMessage("<v>[#] <d>Room password changed by " .. player .. ".")
			tfm.exec.chatMessage("<v>[#] <d>You set the room password to: " .. password, player)

			if not roompw.owner then
				roompw.owner = player
			end
			roompw.password = password

		elseif cmd == "roomlimit" then
			if not perms[player] or not perms[player].set_room_limit then return end

			local limit = tonumber(args[1])
			if not limit then
				return translatedChatMessage("invalid_syntax", player)
			end

			tfm.exec.setRoomMaxPlayers(limit)
			tfm.exec.chatMessage("<v>[#] <d>Set room max players to " .. limit .. ".", player)

		elseif cmd == "langue" then
			if quantity == 0 then
				tfm.exec.chatMessage("<v>[#] <d>Available languages:", player)
				for name, data in next, translations do
					if name ~= "pt" then
						tfm.exec.chatMessage("<d>" .. name .. " - " .. data.fullname, player)
					end
				end
				tfm.exec.chatMessage("<d>Type <b>!langue ID</b> to switch your language.", player)
			elseif players_file[player] then
				local lang = string.lower(args[1])
				if translations[lang] then
					player_langs[player] = translations[lang]
					players_file[player].langue = lang
					translatedChatMessage("new_lang", player)

					savePlayerData(player)
				else
					tfm.exec.chatMessage("<v>[#] <r>Unknown language: <b>" .. lang .. "</b>", player)
				end
			end

		elseif cmd == "forcestats" then
			if not perms[player].force_stats then return end

			if records_admins then
				return tfm.exec.chatMessage("<v>[#] <r>you can't forcestats in a records room", player)
			end

			count_stats = true
			tfm.exec.chatMessage("<v>[#] <d>count_stats set to true", player)

		elseif cmd == "room" then
			if not perms[player] or not perms[player].get_player_room then return end

			if quantity == 0 then
				return translatedChatMessage("invalid_syntax", player)
			end

			local fetching = capitalize(args[1])
			fetching_player_room[fetching] = {player, os.time() + 1000}
			system.loadPlayerData(fetching)
		end
	end)

	onEvent("RawTextAreaCallback", function(id, player, callback)
		if callback == "discord" then
			tfm.exec.chatMessage("<rose>" .. links.discord, player)
		elseif callback == "map_submission" then
			tfm.exec.chatMessage("<rose>" .. links.maps, player)
		elseif callback == "donate" then
			tfm.exec.chatMessage("<rose>" .. links.donation, player)
		elseif callback == "github" then
			tfm.exec.chatMessage("<rose>" .. links.github, player)
		end
	end)

	onEvent("ParsedTextAreaCallback", function(id, player, action, args)
		if action == "_help" then
			tfm.exec.chatMessage("<v>[#] <d>" .. translatedMessage("help_" .. args, player), player)
		elseif action == "msg" then
			tfm.exec.chatMessage("<j>" .. args, player)
		end
	end)

	onEvent("OutPlayerDataParsed", checkRoomRequest)

	onEvent("PlayerDataParsed", function(player, data)
		if data.langue and translations[data.langue] then
			player_langs[player] = translations[data.langue]
		end

		translatedChatMessage("welcome", player)
		translatedChatMessage("donate", player)

		checkRoomRequest(player, data)

		if records_admins then
			translatedChatMessage("records_enabled", player, links.records)

			if string.find(room.lowerName, string.lower(player), 1, true) then
				records_admins[player] = true
				translatedChatMessage("records_admin", player)
			end
		end
	end)

	onEvent("PlayerDataUpdated", checkRoomRequest)

	onEvent("Loop", function()
		local now = os.time()

		local to_remove, count = {}, 0
		for player, data in next, fetching_player_room do
			if now >= data[2] then
				count = count + 1
				to_remove[count] = player
				tfm.exec.chatMessage("<v>[#] <d>" .. player .. "<n> is offline.", data[1])
			end
		end

		for idx = 1, count do
			fetching_player_room[to_remove[idx]] = nil
		end
	end)

	onEvent("PacketReceived", function(packet_id, packet)
		if packet_id == 4 then -- !announce
			tfm.exec.chatMessage("<vi>[#parkour] <d>" .. packet)
		elseif packet_id == 5 then -- !cannounce
			local commu, msg = string.match(packet, "^([^\000]+)\000(.+)$")
			if commu == room.community then
				tfm.exec.chatMessage("<vi>[" .. commu .. "] [#parkour] <d>" .. msg)
			end
		elseif packet_id == 6 then -- pw request
			if packet == room.name then
				if roompw.password then
					sendPacket(5, room.name .. "\000" .. roompw.password .. "\000" .. roompw.owner)
				else
					sendPacket(5, room.name .. "\000")
				end
			end
		end
	end)

	onEvent("GameStart", function()
		system.disableChatCommandDisplay("donate")
		system.disableChatCommandDisplay("discord")
		system.disableChatCommandDisplay("submit")
		system.disableChatCommandDisplay("give")
		system.disableChatCommandDisplay("pw")
		system.disableChatCommandDisplay("roomlimit")
		system.disableChatCommandDisplay("langue")
		system.disableChatCommandDisplay("forcestats")
		system.disableChatCommandDisplay("room")
	end)
	--[[ End of file modes/parkour/chat-ui.lua ]]--
	--[[ Directory modes/parkour/objects ]]--
	--[[ File modes/parkour/objects/Toggle.lua ]]--
	local Toggle
	do
		local callbacks = {}
		local lastId = -1

		Toggle = {}
		Toggle.__index = Toggle

		function Toggle.new(x, y, default, name)
			lastId = lastId + 1
			return setmetatable({
				x = x,
				y = y,
				default = default,

				name = name,

				toggleCallback = nil,
				updateCallback = nil,
				callback = "component_toggle_" .. lastId
			}, Toggle)
		end

		function Toggle:onToggle(callback)
			self.toggleCallback = callback
			return self
		end

		function Toggle:onUpdate(callback)
			self.updateCallback = callback
			return self
		end

		function Toggle:asTemplate(interface)
			local click = {
				x = self.x - 7, y = self.y - 7,
				width = 30, height = 20,
				text = "<a href='event:" .. self.callback .. "'>\n\n\n",
				alpha = 0
			}
			local switch = {
				name = self.name,
				default = self.default,

				y = self.y + 3,
				width = 1, height = 1,

				state = {},
				toggle = function(txt, player)
					local states = txt.state
					if states[player] == nil then
						states[player] = self.default
					end
					states[player] = not states[player]

					txt:checkState(player)
				end,
				onToggle = function(txt, player)
					txt:toggle(player)

					if self.toggleCallback then
						self.toggleCallback(txt, player, txt.state[player])
					end
				end,
				checkState = function(txt, player)
					local states = txt.state

					if states[player] then -- on
						ui.addTextArea(
							txt.id, "", player,
							interface.x + self.x + 16, txt.y,
							txt.width, txt.height,
							0xbeb17d, 0xbeb17d, 1,
							interface.fixed
						)
					else
						ui.addTextArea(
							txt.id, "", player,
							interface.x + self.x + 3, txt.y,
							txt.width, txt.height,
							0x78462b, 0x78462b, 1,
							interface.fixed
						)
					end

					ui.updateTextArea(click.id, click.text, player)
				end,
				onUpdate = function(txt, player)
					txt:checkState(player)
					if self.updateCallback then
						self.updateCallback(txt, player)
					end
				end
			}
			callbacks[self.callback] = {
				fnc = switch.onToggle,
				class = switch
			}

			if self.default then -- on
				switch.x = self.x + 16
				switch.color = {0xbeb17d, 0xbeb17d, 1}
			else -- off
				switch.x = self.x + 3
				switch.color = {0x78462b, 0x78462b, 1}
			end

			interface:addTextArea({
				x = self.x, y = self.y,
				width = 20, height = 7,
				color = {0x232a35, 0x232a35, 1}
			}):addTextArea(switch):addTextArea(click)
		end

		onEvent("TextAreaCallback", function(id, player, cb)
			local callback = callbacks[cb]
			if callback and callback.class.parent.open[player] then
				if not checkCooldown(player, "simpleToggle", 500) then return end

				callback.fnc(callback.class, player)
			end
		end)
	end
	--[[ End of file modes/parkour/objects/Toggle.lua ]]--
	--[[ File modes/parkour/objects/Interface.lua ]]--
	local Interface
	do
		local nextId = 0
		local all_interfaces = {}

		Interface = {}
		Interface.__index = Interface

		function Interface.new(x, y, width, height, fixed)
			local self = setmetatable({
				x = x, y = y,
				width = width, height = height,
				fixed = fixed,

				textarea_count = 0,
				textareas = {},

				image_count = 0,
				images = {},

				args = {},
				defaultArgs = {},

				open = {},

				elements = {},

				updateCallback = nil,
				removeCallback = nil,
				showCheck = nil,

				checkArguments = false
			}, Interface)
			all_interfaces[#all_interfaces + 1] = self
			return self
		end

		function Interface:setShowCheck(callback)
			self.showCheck = callback
			return self
		end

		function Interface:setDefaultArgs(...)
			self.defaultArgs = {...}
			return self
		end

		function Interface:avoidDoubleUpdates()
			self.checkArguments = true
			return self
		end

		function Interface:loadTemplate(template)
			template(self)
			return self
		end

		function Interface:loadComponent(component)
			component:asTemplate(self)
			return self
		end

		function Interface:onUpdate(callback)
			self.updateCallback = callback
			return self
		end

		function Interface:onRemove(callback)
			self.removeCallback = callback
			return self
		end

		function Interface:addTextArea(data)
			if data.name then
				self.elements[data.name] = data
			end

			data.id = nextId
			nextId = nextId + 1

			data.parent = self
			data.x = (data.x or 0) + self.x
			data.y = (data.y or 0) + self.y
			data.width = data.width or self.width
			data.height = data.height or self.height

			if not data.text then
				data.text_str = ""
			elseif type(data.text) == "function" then
				data.text_fnc = data.text
			else
				data.text_str = tostring(data.text)
			end

			if data.color then
				data.background = data.color[1]
				data.border = data.color[2]
				data.alpha = data.color[3]
			end

			self.textarea_count = self.textarea_count + 1
			self.textareas[self.textarea_count] = data

			return self
		end

		function Interface:addImage(data)
			if data.name then
				self.elements[data.name] = data
			end

			data.players = {}

			data.parent = self
			data.x = (data.x or 0) + self.x
			data.y = (data.y or 0) + self.y

			assert(data.image, "an image should have the image id")
			assert(data.target, "an image should have the image target")

			if type(data.image) == "function" then
				data.image_fnc = data.image
			else
				data.image_str = data.image
			end
			if type(data.target) == "function" then
				data.target_fnc = data.target
			else
				data.target_str = data.target
			end

			self.image_count = self.image_count + 1
			self.images[self.image_count] = data

			return self
		end

		function Interface:showDefault(player)
			return self:show(player, self.defaultArgs[1], self.defaultArgs[2], self.defaultArgs[3], self.defaultArgs[4])
		end

		function Interface:show(player, arg1, arg2, arg3, arg4)
			if self.showCheck and not self:showCheck(player, arg1, arg2, arg3, arg4) then return end
			if self.open[player] then return end

			local args
			if self.args[player] then
				args = self.args[player]
			else
				args = {}
				self.args[player] = args
			end
			args[1] = arg1
			args[2] = arg2
			args[3] = arg3
			args[4] = arg4

			local data
			for index = 1, self.textarea_count do
				data = self.textareas[index]

				ui.addTextArea(
					data.id,

					data.translation and translatedMessage(data.translation, player) or
					data.text_str and data.text_str or
					data:text_fnc(player, arg1, arg2, arg3, arg4),

					player,

					data.x, data.y,
					data.width, data.height,

					data.background, data.border, data.alpha,

					self.fixed
				)

				if data.onUpdate then
					data:onUpdate(player, arg1, arg2, arg3, arg4)
				end
			end

			for index = 1, self.image_count do
				data = self.images[index]

				if data.players[player] then
					tfm.exec.removeImage(data.players[player])
				end

				data.players[player] = tfm.exec.addImage(
					data.image_str and data.image_str or
					data:image_fnc(player, arg1, arg2, arg3, arg4),

					data.target_str and data.target_str or
					data:target_fnc(player, arg1, arg2, arg3, arg4),

					data.x, data.y,
					player
				)

				if data.onUpdate then
					data:onUpdate(player, arg1, arg2, arg3, arg4)
				end
			end

			if self.updateCallback then
				self:updateCallback(player, arg1, arg2, arg3, arg4)
			end
			self.open[player] = true
			-- it is at the end to let updateCallback know if it is an update or a show
		end

		function Interface:update(player, arg1, arg2, arg3, arg4)
			if not self.open[player] then return end

			local args = self.args[player]
			if self.checkArguments then
				if args[1] == arg1 and args[2] == arg2 and args[3] == arg3 and args[4] == arg4 then
					return
				end
			end
			args[1] = arg1
			args[2] = arg2
			args[3] = arg3
			args[4] = arg4

			local data
			for index = 1, self.textarea_count do
				data = self.textareas[index]

				if data.canUpdate then
					ui.updateTextArea(
						data.id,

						data.translation and translatedMessage(data.translation, player) or
						data.text_str and data.text_str or
						data:text_fnc(player, arg1, arg2, arg3, arg4),

						player
					)

					if data.onUpdate then
						data:onUpdate(player, arg1, arg2, arg3, arg4)
					end
				end
			end

			for index = 1, self.image_count do
				data = self.images[index]

				if data.canUpdate then
					if data.players[player] then
						tfm.exec.removeImage(data.players[player])
					end

					data.players[player] = tfm.exec.addImage(
						data.image_str and data.image_str or
						data:image_fnc(player, arg1, arg2, arg3, arg4),

						data.target_str and data.target_str or
						data:target_fnc(player, arg1, arg2, arg3, arg4),

						data.x, data.y,
						player
					)

					if data.onUpdate then
						data:onUpdate(player, arg1, arg2, arg3, arg4)
					end
				end
			end

			if self.updateCallback then
				self:updateCallback(player, arg1, arg2, arg3, arg4)
			end
		end

		function Interface:remove(player)
			self.open[player] = nil

			for index = 1, self.textarea_count do
				ui.removeTextArea(self.textareas[index].id, player)
			end

			local data
			for index = 1, self.image_count do
				data = self.images[index].players

				if data[player] then
					tfm.exec.removeImage(data[player])
					data[player] = nil
				end
			end

			if self.removeCallback then
				self:removeCallback(player)
			end
		end

		onEvent("PlayerLeft", function(player)
			for index = 1, #all_interfaces do
				all_interfaces[index].open[player] = nil
			end
		end)
	end
	--[[ End of file modes/parkour/objects/Interface.lua ]]--
	--[[ File modes/parkour/objects/WindowBackground.lua ]]--
	local WindowBackground = function(self)
		self:addTextArea({
			color = {0x78462b, 0x78462b, 1}
		}):addTextArea({
			y = self.height / 4,
			height = self.height / 2,
			color = {0x9d7043, 0x9d7043, 1}
		}):addTextArea({
			x = self.width / 4,
			width = self.width / 2,
			color = {0x9d7043, 0x9d7043, 1}
		}):addTextArea({
			width = 20, height = 20,
			color = {0xbeb17d, 0xbeb17d, 1}
		}):addTextArea({
			x = self.width - 20,
			width = 20, height = 20,
			color = {0xbeb17d, 0xbeb17d, 1}
		}):addTextArea({
			y = self.height - 20,
			width = 20, height = 20,
			color = {0xbeb17d, 0xbeb17d, 1}
		}):addTextArea({
			x = self.width - 20,
			y = self.height - 20,
			width = 20, height = 20,
			color = {0xbeb17d, 0xbeb17d, 1}
		}):addTextArea({
			x = 3, y = 3,
			width = self.width - 6, height = self.height - 6,
			color = {0x1c3a3e, 0x232a35, 1}
		})
	end
	--[[ End of file modes/parkour/objects/WindowBackground.lua ]]--
	--[[ File modes/parkour/objects/Button.lua ]]--
	local Button
	do
		local callbacks = {}
		local lastId = -1

		Button = {}
		Button.__index = Button

		function Button.new()
			lastId = lastId + 1
			return setmetatable({
				callback = "component_button_" .. lastId
			}, Button)
		end

		function Button:setText(text)
			if type(text) == "function" then
				self.text_fnc = text
			else
				self.text_str = text .. "\n"
			end
			return self
		end

		function Button:setTranslation(translation)
			self.translation = translation
			return self
		end

		function Button:canUpdate(enabled)
			self.update = enabled
			return self
		end

		function Button:onClick(callback)
			self.clickCallback = callback
			return self
		end

		function Button:onUpdate(callback)
			self.updateCallback = callback
			return self
		end

		function Button:setPosition(x, y)
			self.x = x
			self.y = y
			return self
		end

		function Button:setSize(width, height)
			self.width = width
			self.height = height
			return self
		end

		function Button:asTemplate(interface)
			local enabled_prefix = "<a href='event:" .. self.callback .. "'><p align='center'>"
			local disabled_prefix = "<p align='center'>"
			local textarea = {
				x = self.x, y = self.y,
				width = self.width, height = self.height,

				canUpdate = self.update,
				text = "",
				color = {0x314e57, 0x314e57, 1},
				onUpdate = self.updateCallback,

				enabled = {},
				disable = function(self, player)
					self.enabled[player] = false
					ui.addTextArea(
						self.id,
						self.text_str,
						player,

						self.x, self.y,
						self.width, self.height,

						0x2a424b, 0x2a424b, self.alpha,
						interface.fixed
					)
				end,
				enable = function(self, player)
					self.enabled[player] = true
					ui.addTextArea(
						self.id,
						self.text_str,
						player,

						self.x, self.y,
						self.width, self.height,

						self.background, self.border, self.alpha,
						interface.fixed
					)
				end
			}
			local text = {
				x = self.x, y = self.y,
				width = self.width, height = self.height + 2,

				canUpdate = self.update,
				text = function(txt, player, arg1, arg2, arg3, arg4)
					if textarea.enabled[player] == nil then
						textarea.enabled[player] = true
					end

					local prefix = textarea.enabled[player] and enabled_prefix or disabled_prefix
					if self.translation then
						return prefix .. translatedMessage(self.translation, player) .. "\n"
					elseif self.text_fnc then
						return prefix .. self.text_fnc(textarea, player, arg1, arg2, arg3, arg4) .. "\n"
					else
						return prefix .. self.text_str
					end
				end,
				alpha = 0,

				disable = function(self, player)
					return textarea:disable(player)
				end,
				enable = function(self, player)
					return textarea:enable(player)
				end
			}
			callbacks[self.callback] = {
				fnc = self.clickCallback,
				class = textarea
			}

			interface:addTextArea({
				x = self.x - 1, y = self.y - 1,
				width = self.width, height = self.height,

				canUpdate = self.update,
				color = {0x7a8d93, 0x7a8d93, 1}
			}):addTextArea({
				x = self.x + 1, y = self.y + 1,
				width = self.width, height = self.height,

				canUpdate = self.update,
				color = {0x0e1619, 0x0e1619, 1}
			}):addTextArea(textarea):addTextArea(text)
		end

		onEvent("TextAreaCallback", function(id, player, cb)
			local callback = callbacks[cb]
			if callback and callback.class.enabled and callback.class.parent.open[player] then
				callback.fnc(callback.class, player)
			end
		end)
	end
	--[[ End of file modes/parkour/objects/Button.lua ]]--
	--[[ End of directory modes/parkour/objects ]]--
	--[[ Directory modes/parkour/interfaces ]]--
	--[[ File modes/parkour/interfaces/staff.lua ]]--
	local Staff
	do
		local nameCache = {}
		local function formatName(name)
			if nameCache[name] then
				return nameCache[name]
			end

			nameCache[name] = "<a href='event:msg:/w " .. name .. "'>" .. string.gsub(
				string.gsub(name, "(#%d%d%d%d)", "<font size='11'><g>%1</g></font>"),
				"([Hh]t)tp", "%1<>tp"
			) .. "</a>"
			return nameCache[name]
		end
		local tab = {}
		local images = {
			{},
			{},
			{}
		}
		local communities = {
			xx = "1651b327097.png",
			ar = "1651b32290a.png",
			bg = "1651b300203.png",
			br = "1651b3019c0.png",
			cn = "1651b3031bf.png",
			cz = "1651b304972.png",
			de = "1651b306152.png",
			ee = "1651b307973.png",
			en = "1723dc10ec2.png",
			e2 = "1723dc10ec2.png",
			es = "1651b309222.png",
			fi = "1651b30aa94.png",
			fr = "1651b30c284.png",
			gb = "1651b30da90.png",
			hr = "1651b30f25d.png",
			hu = "1651b310a3b.png",
			id = "1651b3121ec.png",
			he = "1651b3139ed.png",
			it = "1651b3151ac.png",
			jp = "1651b31696a.png",
			lt = "1651b31811c.png",
			lv = "1651b319906.png",
			nl = "1651b31b0dc.png",
			ph = "1651b31c891.png",
			pl = "1651b31e0cf.png",
			pt = "17459ce7e29.png",
			ro = "1651b31f950.png",
			ru = "1651b321113.png",
			tr = "1651b3240e8.png",
			vk = "1651b3258b3.png"
		}
		local community_list = {
			"xx", "en", "e2", "ar", "bg", "br", "cn", "cz", "de", "ee", "es", "fi", "fr", "gb", "hr",
			"hu", "id", "he", "it", "jp", "lt", "lv", "nl", "ph", "pl", "ro", "ru", "tr", "vk"
		}

		local function names(container, x, start)
			return function(self, player)
				local image_x, image_y = self.parent.x + x, self.parent.y + 56
				local imgs = images[container][player]
				local show_hidden = perms[player] -- true for staff peeps

				if not imgs then
					imgs = {_count = 0}
					images[container][player] = imgs
				else
					for index = 1, imgs._count do
						tfm.exec.removeImage(imgs[index])
					end
				end

				local rank = self.parent.sorted_members[
					tab[player] == 0 and "mod" or
					tab[player] == 1 and "mapper" or
					tab[player] == 2 and "manager" or
					"admin"
				]
				local names = {}

				local commu_list = {}
				local commu, member
				for index = 1 + start, math.min(17 + start, rank._count) do
					member = rank[index]

					if hidden[member] then -- hidden
						if not show_hidden then
							break
						end
						names[index - start] = "<r>" .. formatName(member) .. "</r>"
						commu = hidden[member]
					else
						names[index - start] = formatName(member)
						commu = online[member]
					end

					imgs[index - start] = tfm.exec.addImage(communities[ commu ], "&1", image_x, image_y, member)
					image_y = image_y + 12
					imgs._count = index - start
				end

				return "<font face='Lucida Console' size='12'><v>" .. table.concat(names, "\n")
			end
		end

		Staff = Interface.new(170, 50, 459, 300, true)
			:loadTemplate(WindowBackground)

			:loadComponent(
				Button.new():setTranslation("moderators")

				:onClick(function(self, player)
					tab[player] = 0
					self.parent:update(player)
				end)

				:canUpdate(true):onUpdate(function(self, player)
					if not tab[player] then tab[player] = 0 end
					if tab[player] == 0 then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(10, 10):setSize(100, 15)
			)
			:loadComponent(
				Button.new():setTranslation("mappers")

				:onClick(function(self, player)
					tab[player] = 1
					self.parent:update(player)
				end)

				:canUpdate(true):onUpdate(function(self, player)
					if tab[player] == 1 then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(123, 10):setSize(100, 15)
			)
			:loadComponent(
				Button.new():setTranslation("managers")

				:onClick(function(self, player)
					tab[player] = 2
					self.parent:update(player)
				end)

				:canUpdate(true):onUpdate(function(self, player)
					if tab[player] == 2 then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(236, 10):setSize(100, 15)
			)
			:loadComponent(
				Button.new():setTranslation("administrators")

				:onClick(function(self, player)
					tab[player] = 3
					self.parent:update(player)
				end)

				:canUpdate(true):onUpdate(function(self, player)
					if tab[player] == 3 then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(349, 10):setSize(100, 15)
			)

			:addTextArea({
				y = 35, x = 5,
				height = 230, width = 449,
				translation = "staff_power",
				alpha = 0
			})

			:addTextArea({
				y = 55, x = 22,
				height = 210, width = 130,
				canUpdate = true,
				text = names(1, 5, 0),
				alpha = 0
			})

			:addTextArea({
				y = 55, x = 172,
				height = 210, width = 130,
				canUpdate = true,
				text = names(2, 155, 17),
				alpha = 0
			})

			:addTextArea({
				y = 55, x = 322,
				height = 210, width = 130,
				canUpdate = true,
				text = names(3, 305, 34),
				alpha = 0
			})

			:onRemove(function(self, player)
				local cont
				for container = 1, 3 do
					cont = images[container][player]
					if cont then
						for index = 1, cont._count do
							tfm.exec.removeImage(cont[index])
						end
					end
				end
			end)

			:loadComponent(
				Button.new():setTranslation("close")

				:onClick(function(self, player)
					self.parent:remove(player)
				end)

				:setPosition(10, 275):setSize(439, 15)
			)

		Staff.sorted_members = {}
	end
	--[[ End of file modes/parkour/interfaces/staff.lua ]]--
	--[[ File modes/parkour/interfaces/tracker.lua ]]--
	local PowerTracker
	do
		local nameCache = {}
		local function formatName(name)
			if nameCache[name] then
				return nameCache[name]
			end

			nameCache[name] = string.gsub(
				string.gsub(name, "(#%d%d%d%d)", "<font size='10'><g>%1</g></font>"),
				"([Hh]t)tp", "%1<>tp"
			)
			return nameCache[name]
		end

		PowerTracker = Interface.new(200, 50, 400, 300, true)
			:loadTemplate(WindowBackground)

			:addTextArea({
				alpha = 0,
				text = "<p align='center'><font size='14'><cep><b>Power Tracker</b></cep></font></p>"
			})

			:addTextArea({
				canUpdate = true,
				y = 25, height = 240,
				alpha = 0,

				text = function(self, player, powers)
					local pieces, count = {}, 0

					local power
					for index = powers._count, math.max(powers._count - 18, 1), -1 do
						power = powers[index]
						count = count + 1
						pieces[count] = formatName(power[1]) .. "<n> -> </n>" .. power[2]
					end

					return "<v>" .. table.concat(pieces, "\n")
				end
			})

			:loadComponent(
				Button.new():setTranslation("close")

				:onClick(function(self, player)
					self.parent:remove(player)
				end)

				:setPosition(10, 275):setSize(380, 15)
			)
	end
	--[[ End of file modes/parkour/interfaces/tracker.lua ]]--
	--[[ File modes/parkour/interfaces/options.lua ]]--
	local no_help
	local OptionsInterface = Interface.new(168, 46, 465, 330, true)
		:loadTemplate(WindowBackground)

		:addTextArea({
			translation = "options",
			alpha = 0
		})
		:loadComponent(
			Button.new():setTranslation("close")
			:onClick(function(self, player)
				self.parent:remove(player)
			end)
			:setPosition(10, 305):setSize(445, 15)
		)
		:onRemove(function(self, player)
			savePlayerData(player)
		end)

		:loadComponent(
			Toggle.new(435, 55, false)
			:onToggle(function(self, player, state) -- particles or images for checkpoints
				players_file[player].settings[1] = state and 1 or 0
				ck.particles[player] = state

				if state then
					if ck.images[player] then
						tfm.exec.removeImage(ck.images[player])
					end
				else
					addCheckpointImage(player)
				end
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[1] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 81, false)
			:onToggle(function(self, player, state) -- qwerty or azerty keyboard
				players_file[player].settings[5] = state and 1 or 0

				if victory[player] then
					unbind(player)
					if not no_powers[player] then
						bindNecessary(player)
					end
				end
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[5] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 107, false)
			:onToggle(function(self, player, state) -- M or DEL for mort
				players_file[player].settings[2] = state and 1 or 0

				if state then
					bindKeyboard(player, 77, true, true)
					bindKeyboard(player, 46, true, false)
				else
					bindKeyboard(player, 77, true, false)
					bindKeyboard(player, 46, true, true)
				end
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[2] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 133, false)
			:onToggle(function(self, player, state) -- powers cooldown
				players_file[player].settings[3] = state and 1 or 0
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[3] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 159, false)
			:onToggle(function(self, player, state) -- powers button
				players_file[player].settings[4] = state and 1 or 0

				GameInterface:update(player)
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[4] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 185, false)
			:onToggle(function(self, player, state) -- help button
				players_file[player].settings[6] = state and 1 or 0

				GameInterface:update(player)
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[6] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 211, false)
			:onToggle(function(self, player, state) -- congrats messages
				players_file[player].settings[7] = state and 1 or 0
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[7] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
		:loadComponent(
			Toggle.new(435, 238, false)
			:onToggle(function(self, player, state) -- no help indicator
				players_file[player].settings[8] = state and 1 or 0

				if not state then
					if no_help[player] then
						tfm.exec.removeImage(no_help[player])
						no_help[player] = nil
					end
				else
					no_help[player] = tfm.exec.addImage("1722eeef19f.png", "$" .. player, -10, -35)
				end
			end)
			:onUpdate(function(self, player)
				local setting = players_file[player].settings[8] == 1
				if (self.state[player] and not setting) or (not self.state[player] and setting) then
					self:toggle(player)
				end
			end)
		)
	--[[ End of file modes/parkour/interfaces/options.lua ]]--
	--[[ File modes/parkour/interfaces/keyboard.lua ]]--
	keyboard = {}
	local Keyboard
	do
		local selection = {}
		keyboard.keys = {
			[1] = {
				"|", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "-", "=", "BACKSPACE"
			},

			[2] = {
				"Tab",
				{"A", "Q"},
				{"Z", "W"},
				"E", "R", "T", "Y", "U", "I", "O", "P",
				{"^", "["},
				{"$", "]"}
			},

			[3] = {
				"Caps\nLock",
				{"Q", "A"},
				"S", "D", "F", "G", "H", "J", "K", "L",
				{"M", ";"},
				{"%", "'"},
				{"*", "\\"}
			},

			[4] = {
				"Shift", ">",
				{"W", "Z"},
				"X", "C", "V", "B", "N",
				{"?", "M"},
				{".", ","},
				{"/", "."},
				{"!", "/"},
				"RShift"
			},

			[5] = {
				"Ctrl", "LWin", "Alt", "SPACE", "Alt Gr", "RWin", "OPT", "RCtrl"
			}
		}
		keyboard.bindings = {
			BACKSPACE = 8, [8] = "BACKSPACE",
			Tab = 9, [9] = "Tab",
			Shift = 16, [16] = "Shift",
			Ctrl = 17, [17] = "Ctrl",
			Alt = 18, [18] = "Alt",
			["Caps\nLock"] = 20, [20] = "Caps\nLock",
			SPACE = 32, [32] = "SPACE",
			["0"] = 48, [48] = "0",
			["1"] = 49, [49] = "1",
			["2"] = 50, [50] = "2",
			["3"] = 51, [51] = "3",
			["4"] = 52, [52] = "4",
			["5"] = 53, [53] = "5",
			["6"] = 54, [54] = "6",
			["7"] = 55, [55] = "7",
			["8"] = 56, [56] = "8",
			["9"] = 57, [57] = "9",
			A = 65, [65] = "A",
			B = 66, [66] = "B",
			C = 67, [67] = "C",
			D = 68, [68] = "D",
			E = 69, [69] = "E",
			F = 70, [70] = "F",
			G = 71, [71] = "G",
			H = 72, [72] = "H",
			I = 73, [73] = "I",
			J = 74, [74] = "J",
			K = 75, [75] = "K",
			L = 76, [76] = "L",
			M = 77, [77] = "M",
			N = 78, [78] = "N",
			O = 79, [79] = "O",
			P = 80, [80] = "P",
			Q = 81, [81] = "Q",
			R = 82, [82] = "R",
			S = 83, [83] = "S",
			T = 84, [84] = "T",
			U = 85, [85] = "U",
			V = 86, [86] = "V",
			W = 87, [87] = "W",
			X = 88, [88] = "X",
			Y = 89, [89] = "Y",
			Z = 90, [90] = "Z",
			LWin = 91, [91] = "LWin",
			RWin = 92, [92] = "RWin",
			[";"] = 186, [186] = ";",
			[","] = 188, [188] = ",",
			["."] = 190, [190] = ".",
			["/"] = 191, [191] = "/",
			["["] = 219, [219] = "[",
			["\\"] = 220, [220] = "\\",
			["]"] = 221, [221] = "]",
			["'"] = 222, [222] = "'"
		}

		Keyboard = Interface.new(65, 170, 665, 215, true)
			:addTextArea({
				name = "enter_key",

				x = 610, y = 45,
				width = 55, height = 80,

				text = "<a href='event:keyboard:enter'>ENTER\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

				border = 0x1c3a3e
			})
			:addTextArea({
				x = 587, y = 88,
				width = 35, height = 37,

				color = {0x1c3a3e, 0x1c3a3e, 1}
			})

			-- Layer 1
			:addTextArea({
				x = 0, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 45, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 90, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 135, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 180, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 225, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 270, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 315, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 360, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 405, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 450, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 495, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 540, y = 0,
				width = 35, height = 35
			})
			:addTextArea({
				x = 585, y = 0,
				width = 80, height = 35
			})

			-- Layer 2
			:addTextArea({
				x = 0, y = 45,
				width = 60, height = 35
			})
			:addTextArea({
				x = 70, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 115, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 160, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 205, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 250, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 295, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 340, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 385, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 430, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 475, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 520, y = 45,
				width = 35, height = 35
			})
			:addTextArea({
				x = 565, y = 45,
				width = 35, height = 35
			})

			-- Layer 3
			:addTextArea({
				x = 0, y = 90,
				width = 80, height = 35
			})
			:addTextArea({
				x = 90, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 135, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 180, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 225, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 270, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 315, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 360, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 405, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 450, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 495, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 540, y = 90,
				width = 35, height = 35
			})
			:addTextArea({
				x = 585, y = 90,
				width = 35, height = 35
			})

			-- Layer 4
			:addTextArea({
				x = 0, y = 135,
				width = 45, height = 35
			})
			:addTextArea({
				x = 55, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 100, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 145, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 190, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 235, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 280, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 325, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 370, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 415, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 460, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 505, y = 135,
				width = 35, height = 35
			})
			:addTextArea({
				x = 550, y = 135,
				width = 115, height = 35
			})

			-- Layer 5
			:addTextArea({
				x = 0, y = 180,
				width = 65, height = 35
			})
			:addTextArea({
				x = 75, y = 180,
				width = 45, height = 35
			})
			:addTextArea({
				x = 130, y = 180,
				width = 45, height = 35
			})
			:addTextArea({
				x = 185, y = 180,
				width = 240, height = 35
			})
			:addTextArea({
				x = 435, y = 180,
				width = 45, height = 35
			})
			:addTextArea({
				x = 490, y = 180,
				width = 45, height = 35
			})
			:addTextArea({
				x = 545, y = 180,
				width = 45, height = 35
			})
			:addTextArea({
				x = 600, y = 180,
				width = 65, height = 35
			})
			:onUpdate(function(self, player, qwerty, numkey, keyname)
				local txt
				if selection[player] then
					txt = selection[player]
					ui.addTextArea(
						txt.id,
						txt.text_str and txt.text_str or
						txt:text_fnc(player, qwerty),
						player,
						txt.x, txt.y,
						txt.width, txt.height,
						txt.background, txt.border, txt.alpha,
						true
					)
					selection[player] = nil
				end

				if numkey then
					local text_id = self.elements.enter_key.id + numkey

					for index = 1, self.textarea_count do
						txt = self.textareas[index]
						if txt.id == text_id then
							selection[player] = txt
							break
						end
					end
				elseif keyname then
					for index = 1, self.textarea_count do
						txt = self.textareas[index]
						if txt.key == keyname then
							selection[player] = txt
							break
						end
					end
				end

				if not selection[player] then return end

				ui.addTextArea(
					txt.id,
					txt.text_str and txt.text_str or
					txt:text_fnc(player, qwerty),
					player,
					txt.x, txt.y,
					txt.width, txt.height,
					0x232a35, 0x1c3a3e, 1,
					true
				)
			end)

		local newlines = string.rep("\n", 10)
		local key = 2
		local txt
		for i = 1, #keyboard.keys do
			for j = 1, #keyboard.keys[i] do
				key = key + 1
				txt = Keyboard.textareas[key]

				txt.border = 0x1c3a3e

				if keyboard.keys[i][j][1] then -- variation
					txt.canUpdate = true
					txt.text_str = nil

					txt.text_fnc = function(self, player, qwerty)
						self.key = keyboard.keys[i][j][qwerty and 2 or 1]
						return "<a href=\"event:keyboard:" .. self.key .. "\">" .. self.key .. newlines
					end
				else
					txt.key = keyboard.keys[i][j]
					txt.text_str = "<a href=\"event:keyboard:" .. txt.key .. "\">" .. txt.key .. newlines
				end
			end
		end
	end
	--[[ End of file modes/parkour/interfaces/keyboard.lua ]]--
	--[[ File modes/parkour/interfaces/poll.lua ]]--
	local polls
	do
		polls = {}

		local pollSizes = {
			tiny = {
				{200, 130, 400, 140, true},
				minOptions = 2,
				maxOptions = 2,
				optionY = 85
			},

			small = {
				{200, 100, 400, 200, true},
				minOptions = 2,
				maxOptions = 4,
				optionY = 85
			},

			medium = {
				{200, 80, 400, 260, true},
				minOptions = 2,
				maxOptions = 6,
				optionY = 85
			},

			big = {
				{200, 50, 400, 320, true},
				minOptions = 2,
				maxOptions = 8,
				optionY = 85
			}
		}

		local poll, offset
		for name, data in next, pollSizes do
			polls[name] = {}

			for options = data.minOptions, data.maxOptions do
				local text_fnc = function(self, player, translation, title)
					local text
					if translation then
						text = translatedMessage(title, player)
					else
						text = title
					end
					return "<font size='13'><v>[#parkour]</v> " .. text
				end

				result = Interface.new(table.unpack(data[1]))
				result.y = result.y - 15

				result.height = result.height + 30
				result:loadTemplate(WindowBackground)
					:addTextArea({
						alpha = 0, y = 0,
						text = text_fnc
					})

				poll = Interface.new(table.unpack(data[1]))
					:loadTemplate(WindowBackground)
					:addTextArea({
						alpha = 0, y = 0,
						text = text_fnc
					})

				offset = data.optionY + 30 * (data.maxOptions - options)

				for button = 1, options do
					local component = Button.new():setText(function(self, player, translation, title, buttons, results)
							local text
							if translation then
								text = translatedMessage(buttons[button], player)
							else
								text = buttons[button]
							end

							if results then
								local percentage = 100 * results[button] / results.total
								if percentage ~= percentage then -- NaN
									percentage = 0
								end

								return string.format(text .. " - %.2f%% (%s)", percentage, results[button])
							end
							return text
						end)

						:canUpdate(true):onUpdate(function(self, player, translation, title, buttons, results)
							if results then
								self:disable(player)
							else
								self:enable(player)
							end
						end)

						:onClick(function(self, player)
							if eventPollVote then
								eventPollVote(self.parent, player, button)
							end
						end)

						:setPosition(10, offset):setSize(poll.width - 20, 15)

					result:loadComponent(component)
					poll:loadComponent(component)
					offset = offset + 30
				end

				result:loadComponent(
					Button.new():setTranslation("close")

					:onClick(function(self, player)
						self.parent:remove(player)
					end)

					:setPosition(10, offset):setSize(poll.width - 20, 15)
				)

				poll.closer = result
				polls[name][options] = poll
			end
		end
	end
	--[[ End of file modes/parkour/interfaces/poll.lua ]]--
	--[[ File modes/parkour/interfaces/leaderboard.lua ]]--
	local LeaderboardInterface
	do
		local community_images = {}
		local communities = {
			xx = "1651b327097.png",
			ar = "1651b32290a.png",
			bg = "1651b300203.png",
			br = "1651b3019c0.png",
			cn = "1651b3031bf.png",
			cz = "1651b304972.png",
			de = "1651b306152.png",
			ee = "1651b307973.png",
			en = "1723dc10ec2.png",
			e2 = "1723dc10ec2.png",
			es = "1651b309222.png",
			fi = "1651b30aa94.png",
			fr = "1651b30c284.png",
			gb = "1651b30da90.png",
			hr = "1651b30f25d.png",
			hu = "1651b310a3b.png",
			id = "1651b3121ec.png",
			he = "1651b3139ed.png",
			it = "1651b3151ac.png",
			jp = "1651b31696a.png",
			lt = "1651b31811c.png",
			lv = "1651b319906.png",
			nl = "1651b31b0dc.png",
			ph = "1651b31c891.png",
			pl = "1651b31e0cf.png",
			pt = "17459ce7e29.png",
			ro = "1651b31f950.png",
			ru = "1651b321113.png",
			tr = "1651b3240e8.png",
			vk = "1651b3258b3.png"
		}
		local separator = string.rep("¬Ø", 50)

		LeaderboardInterface = Interface.new(168, 46, 465, 330, true)
			:avoidDoubleUpdates()
			:loadTemplate(WindowBackground)
			:setShowCheck(function(self, player, data, page, weekly)
				if not loaded_leaderboard then
					translatedChatMessage("leaderboard_not_loaded", player)
					return false
				end
				if not data then
					self:show(player, leaderboard, 0, false)
					return false
				end
				return true
			end)

			-- Titles
			:addTextArea({
				text = function(self, player)
					return string.format(
						"<p align='center'><font size='28'><B><D>%s</D></B></font>\n<font color='#32585E'>%s</font></p>",
						translatedMessage("leaderboard", player),
						separator
					)
				end,
				alpha = 0
			}):addTextArea({
				x = 12, y = 54,
				width = 50, height = 20,
				translation = "position",
				alpha = 0
			}):addTextArea({
				x = 78, y = 54,
				width = 176, height = 20,
				translation = "username",
				alpha = 0
			}):addTextArea({
				x = 267, y = 54,
				width = 70, height = 20,
				translation = "community",
				alpha = 0
			}):addTextArea({
				x = 350, y = 54,
				width = 105, height = 20,
				translation = "completed",
				alpha = 0
			})

			-- Position
			:addTextArea({
				x = 15, y = 84,
				width = 50, height = 200,

				canUpdate = true,
				text = function(self, player, data, page, weekly)
					local positions = {}
					for index = 1, 14 do
						positions[index] = 14 * page + index
					end
					return "<font size='12'><p align='center'><v>#" .. table.concat(positions, "\n#")
				end,
				color = {0x203F43, 0x193E46, 1}
			})

			-- Player names
			:addTextArea({
				x = 78, y = 84,
				width = 176, height = 200,

				canUpdate = true,
				text = function(self, player, data, page, weekly)
					local names = {}
					local row, name, unknown
					for index = 1, 14 do
						row = data[14 * page + index]

						if not row then
							if not unknown then
								unknown = translatedMessage("unknown", player)
							end
							names[index] = unknown
						else
							names[index] = row[2]
						end
					end

					if page == 0 then
						names[1] = "<cs>" .. names[1] .. "</cs>"
						names[2] = "<n>" .. names[2] .. "</n>"
						names[3] = "<ce>" .. names[3] .. "</ce>"
					end

					return "<font size='12'><p align='center'><t>" .. table.concat(names, "\n")
				end,
				color = {0x203F43, 0x193E46, 1}
			})

			-- Community
			:addTextArea({
				x = 267, y = 84,
				width = 70, height = 200,
				color = {0x203F43, 0x193E46, 1}
			}):onUpdate(function(self, player, data, page, weekly)
				if not community_images[player] then
					community_images[player] = {}
				else
					for index = 1, 14 do
						tfm.exec.removeImage(community_images[player][index])
					end
				end

				local x = self.x + 292
				local nextY = self.y + 88
				local row, image
				for index = 1, 14 do
					row = data[14 * page + index]

					if not row then
						image = communities.xx
					else
						image = communities[row[4]] or communities.xx
					end

					community_images[player][index] = tfm.exec.addImage(image, "&1", x, nextY, player)
					nextY = nextY + 14
				end
			end):onRemove(function(self, player)
				for index = 1, 14 do
					tfm.exec.removeImage(community_images[player][index])
				end
			end)

			-- Map count
			:addTextArea({
				x = 350, y = 84,
				width = 100, height = 200,

				canUpdate = true,
				text = function(self, player, data, page, weekly)
					local maps = {}
					for index = 1, 14 do
						row = data[14 * page + index]

						if not row then
							maps[index] = 0
						else
							maps[index] = row[3]
						end
					end
					return "<font size='12'><p align='center'><vp>" .. table.concat(maps, "\n")
				end,
				color = {0x203F43, 0x193E46, 1}
			})

			-- Pagination buttons
			:loadComponent( -- Left arrow
				Button.new():setText("&lt;")

				:onClick(function(self, player)
					local args = self.parent.args[player]
					self.parent:update(player, args[1], math.max(args[2] - 1, 0), args[3])
				end)

				:canUpdate(true):onUpdate(function(self, player, data, page)
					if page == 0 then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(17, 300):setSize(40, 20)
			):loadComponent( -- Right arrow
				Button.new():setText("&gt;")

				:onClick(function(self, player)
					local args = self.parent.args[player]
					self.parent:update(player, args[1], math.min(args[2] + 1, weekly and 1 or 4), args[3])
				end)

				:canUpdate(true):onUpdate(function(self, player, data, page, weekly)
					if page == (weekly and 1 or 4) then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(412, 300):setSize(40, 20)
			)

			-- Leaderboard type
			:loadComponent( -- Overall button
				Button.new():setTranslation("overall_lb")

				:onClick(function(self, player)
					local args = self.parent.args[player]
					self.parent:update(player, leaderboard, 0, false)
				end):canUpdate(true)
				:onUpdate(function(self, player, data, page, weekly)
					if not weekly then
						self:disable(player)
					else
						self:enable(player)
					end
				end):setPosition(72, 300):setSize(155, 20)
			):loadComponent( -- Weekly button
				Button.new():setTranslation("weekly_lb")

				:onClick(function(self, player)
					local args = self.parent.args[player]
					self.parent:update(player, weekleaderboard, 0, true)
				end)

				:canUpdate(true):onUpdate(function(self, player, data, page, weekly)
					if weekly then
						self:disable(player)
					else
						self:enable(player)
					end
				end)

				:setPosition(242, 300):setSize(155, 20)
			)
	end
	--[[ End of file modes/parkour/interfaces/leaderboard.lua ]]--
	--[[ File modes/parkour/interfaces/profile.lua ]]--
	local Profile
	do
		local nameCache = {}
		local function formatName(name)
			if nameCache[name] then
				return nameCache[name]
			end

			nameCache[name] = string.gsub(
				string.gsub(name, "(#%d%d%d%d)", "<font size='15'><g>%1</g></font>"),
				"([Hh]t)tp", "%1<>tp"
			)
			return nameCache[name]
		end

		local staff = {
			{"admin", "172e0cf7ce5.png"},
			{"bot", "172e0cf7ce5.png"},
			{"mod", "173eeb6cd94.png"},
			{"mapper", "17323cc35d1.png"},
			{"translator", "173f3263916.png"}
		}
		local images = {}

		Profile = Interface.new(200, 50, 400, 300, true)
			:setShowCheck(function(self, player, profile, data)
				local file = data or players_file[profile]
				return (file
						and file.v == data_version)
			end)

			:addImage({
				image = "173f32a90da.png",
				target = ":1",
				x = -5, y = -5
			})

			:addTextArea({
				alpha = 0,
				x = 5, y = 5,
				height = 100,
				canUpdate = true,
				text = function(self, player, profile)
					return "<font size='20' face='Verdana'><v><b>" .. formatName(profile)
				end
			})
			:addTextArea({
				x = 10, y = 45, height = 1, width = 380,
				border = 0x9d7043
			})
			:addTextArea({
				x = 5, y = 47, height = 1, width = 390,
				color = {0x1c3a3e, 0x1c3a3e, 1}
			})

			:onUpdate(function(self, player, profile, data)
				local container = images[player]
				if not container then
					container = {_count = 0}
					images[player] = container
				else
					for index = 1, container._count do
						tfm.exec.removeImage(container[index])
					end
					container._count = 0
				end

				local x = self.x + 370
				if not (data or players_file[player]).hidden then
					for index = 1, #staff do
						if ranks[ staff[index][1] ][profile] then
							container._count = container._count + 1
							container[ container._count ] = tfm.exec.addImage(staff[index][2], "&1", x, self.y + 10, player)
							x = x - 25
						end
					end
				end

				x = self.x + 15
				local limit = x + 40 * 9
				local y = self.y + 180
				local pbg = (data or players_file[profile]).badges
				if pbg then
					local badge
					for index = 1, #badges do
						if pbg[index] > 0 then
							badge = badges[index][pbg[index]]

							container._count = container._count + 1
							container[ container._count ] = tfm.exec.addImage(badge[2], ":2", x, y, player)
							ui.addTextArea(
								-10000 - index,
								"<a href='event:_help:badge_" .. badge[1] .. "'>\n\n\n\n\n\n",
								player, x, y, 30, 30,
								0, 0, 0, true
							)

							x = x + 40
							if x >= limit then
								x = self.x + 15
								y = y + 40
							end
						else
							ui.removeTextArea(-10000 - index, player)
						end
					end
				end
			end)
			:onRemove(function(self, player, profile)
				for index = 1, images[player]._count do
					tfm.exec.removeImage(images[player][index])
				end
				for index = 1, #badges do
					ui.removeTextArea(-10000 - index, player)
				end
				images[player]._count = 0
			end)

			:addTextArea({
				x = 5, y = 50,
				canUpdate = true,
				text = function(self, player, profile, data)
					local file = (data or players_file[profile])

					return translatedMessage(
						"profile", player,
						file.private_maps and translatedMessage("private_maps", player) or "",
						(not file.private_maps or player == profile or (perms[player] and perms[player].see_private_maps)) and
						translatedMessage("map_count", player, file.c, file.week[1], #file.hour) or "",
						profile == player and string.format(
							"<a href='event:prof_maps:%s'><j>[%s]</j></a>",
							file.private_maps and "public" or "private",
							translatedMessage(file.private_maps and "make_public" or "make_private", player)
						) or "",
						leaderboard[profile] and ("#" .. leaderboard[profile]) or "N/A",
						weekleaderboard[profile] and ("#" .. weekleaderboard[profile]) or "N/A"
					)
				end,
				alpha = 0, height = 100
			})

			:addTextArea({
				x = 5, y = 150,
				canUpdate = true,
				text = function(self, player, profile, data)
					local count = 0
					local pbg = (data or players_file[profile]).badges
					if pbg then
						for index = 1, #badges do
							if pbg[index] == 1 then
								count = count + 1
							end
						end
					end
					return translatedMessage("badges", player, count)
				end,
				height = 20,
				alpha = 0
			})

			:loadComponent(
				Button.new():setTranslation("close")
				:onClick(function(self, player)
					self.parent:remove(player)
				end)
				:setPosition(10, 275):setSize(380, 15)
			)

		onEvent("ParsedTextAreaCallback", function(id, player, action, args)
			if action == "prof_maps" then
				if not checkCooldown(player, "mapsToggle", 500) then return end

				if args == "public" then
					players_file[player].private_maps = nil
				else
					players_file[player].private_maps = true
				end

				savePlayerData(player)

				if Profile.open[player] then
					Profile:update(player, player)
				end
			end
		end)
	end
	--[[ End of file modes/parkour/interfaces/profile.lua ]]--
	--[[ File modes/parkour/interfaces/powers.lua ]]--
	local PowersInterface
	do
		local selection, power
		for index = 1, #powers do
			selection = 1
			power = powers[index]
			if power.default then
				power.key = keyboard.keys[ power.default[1] ][ power.default[2] ]

				for layer = 1, power.default[1] - 1 do
					selection = selection + #keyboard.keys[layer]
				end

				power.default = selection + power.default[2]
			end
		end

		local images = {}

		local function getPlayerPower(player, power)
			local upgrades = power.upgrades
			if upgrades then
				local completed = players_file[player].c
				local pos = leaderboard[player] or max_leaderboard_rows + 1
				for index = #upgrades, 1, -1 do
					if upgrades[index].ranking then
						if pos <= upgrades[index].ranking then
							return upgrades[index]
						end
					elseif upgrades[index].maps <= completed then
						return upgrades[index]
					end
				end
			end
			return power
		end

		PowersInterface = Interface.new(55, 28, 685, 366, true)
			:setDefaultArgs(1)

			:addImage({
				image = "173d539e4a0.png",
				target = ":1",
				y = -5, x = -5
			})

			:addTextArea({
				text = function(self, player, power)
					return translatedMessage("maps_info", player, players_file[player].c)
				end,
				alpha = 0,
				x = 525, y = 5,
				width = 150, height = 50
			})

			:addTextArea({
				text = function(self, player, power)
					return translatedMessage("weekly_info", player, weekleaderboard[player] and ("#" .. weekleaderboard[player]) or "N/A")
				end,
				alpha = 0,
				x = 525, y = 45,
				width = 150, height = 50
			})

			:addTextArea({
				text = function(self, player, power)
					return translatedMessage("overall_info", player, leaderboard[player] and ("#" .. leaderboard[player]) or "N/A")
				end,
				alpha = 0,
				x = 520, y = 85,
				width = 160, height = 50
			})

			:addTextArea({
				canUpdate = true,
				text = function(self, player, power)
					local upgrades, completed = powers[power].upgrades, players_file[player].c
					local pos = leaderboard[player] or max_leaderboard_rows + 1
					local cond
					if powers[power].ranking then
						cond = pos <= powers[power].ranking
					else
						cond = completed >= powers[power].maps
					end

					if cond then
						if upgrades then
							for index = 1, #upgrades do
								if upgrades[index].ranking then
									if pos > upgrades[index].ranking then
										return translatedMessage(
											"upgrade_power_rank", player,
											"#" .. upgrades[index].ranking, translatedMessage(upgrades[index].name, player)
										)
									end
								elseif completed < upgrades[index].maps then
									return translatedMessage(
										"upgrade_power", player,
										upgrades[index].maps, translatedMessage(upgrades[index].name, player)
									)
								end
							end
						end
						return ""
					end

					if powers[power].ranking then
						return translatedMessage(
							"unlock_power_rank", player,
							"#" .. powers[power].ranking, translatedMessage(powers[power].name, player)
						)
					end
					return translatedMessage(
						"unlock_power", player,
						powers[power].maps, translatedMessage(powers[power].name, player)
					)
				end,
				alpha = 0,
				x = 5, y = 65,
				width = 185, height = 70
			})

			:addTextArea({
				canUpdate = true,
				text = function(self, player, power)
					local name = getPlayerPower(player, powers[power]).name
					return "<p align='center'><font size='20'><vp><b>" .. translatedMessage(name, player)
				end,
				alpha = 0,
				height = 50, width = 485,
				x = 100
			})

			:addTextArea({
				x = 37, y = 5,
				alpha = 0,
				width = 400,
				translation = "power_options",
				canUpdate = false
			})
			:loadComponent(
				Toggle.new(10, 10, false)
				:onToggle(function(self, player, state)
					if Keyboard.open[player] then
						local power = self.parent.args[player][1]
						if keys[player][power] then
							Keyboard:update(player, state, nil, keyboard.bindings[ keys[player][power] ])
						else
							Keyboard:update(player, state, powers[power].default)
						end
					elseif Keyboard.args[player] then
						Keyboard.args[player][1] = state
					end

					players_file[player].settings[5] = state and 1 or 0

					if victory[player] then
						unbind(player)
						if not no_powers[player] then
							bindNecessary(player)
						end
					end

					savePlayerData(player)
				end)
				:onUpdate(function(self, player)
					local state = not not self.state[player]
					local setting = players_file[player].settings[5] == 1
					if state ~= setting then
						self:toggle(player)
					end
				end)
			)
			:loadComponent(
				Toggle.new(10, 36, false)
				:onToggle(function(self, player, state)
					eventParsedTextAreaCallback(0, player, "prof_maps", state and "private" or "public")
				end)
				:onUpdate(function(self, player)
					local state = not not self.state[player]
					local setting = not not players_file[player].private_maps
					if state ~= setting then
						self:toggle(player)
					end
				end)
			)

			:onUpdate(function(self, player, power)
				if not images[player] then
					images[player] = {}
				else
					for idx = 1, 4 do
						if images[player][idx] then
							tfm.exec.removeImage(images[player][idx])
						end
					end
				end

				if powers[power].click then
					if Keyboard.open[player] then
						Keyboard:remove(player)
					end
					images[player][4] = tfm.exec.addImage(
						"173de7d5a5c.png", ":7",
						self.x + 250, self.y + 140, player
					)

				else
					local numkey = powers[power].default
					local keyname
					if keys[player][power] then
						numkey = nil
						keyname = keyboard.bindings[ keys[player][power] ]
					end

					if not Keyboard.open[player] then
						local qwerty = (self.open[player] and Keyboard.args[player][1] or
										players_file[player].settings[5] == 1)

						Keyboard:show(player, qwerty, numkey, keyname)
					else
						Keyboard:update(player, Keyboard.args[player][1], numkey, keyname)
					end
				end

				local completed = players_file[player].c
				local pos = leaderboard[player] or max_leaderboard_rows + 1
				local img, cond
				if power > 1 then
					if powers[power - 1].ranking then
						cond = pos <= powers[power - 1].ranking
					else
						cond = completed >= powers[power - 1].maps
					end

					if cond then
						img = getPlayerPower(player, powers[power - 1])
					else
						img = powers[power - 1]
					end
					images[player][1] = tfm.exec.addImage(
						img[(not cond) and "lockedSmall" or "small"],
						":2", self.x + 240 - img.smallX, self.y + 50 + img.smallY, player
					)
				end

				if powers[power].ranking then
					cond = pos <= powers[power].ranking
				else
					cond = completed >= powers[power].maps
				end

				if cond then
					img = getPlayerPower(player, powers[power])
				else
					img = powers[power]
				end
				images[player][2] = tfm.exec.addImage(
					img[(not cond) and "lockedBig" or "big"],
					":3", self.x + 300 + img.bigX, self.y + 30 + img.bigY, player
				)

				if power < #powers then
					if powers[power + 1].ranking then
						cond = pos <= powers[power + 1].ranking
					else
						cond = completed >= powers[power + 1].maps
					end

					if cond then
						img = getPlayerPower(player, powers[power + 1])
					else
						img = powers[power + 1]
					end
					images[player][3] = tfm.exec.addImage(
						img[(not cond) and "lockedSmall" or "small"],
						":4", self.x + 380 + img.smallX, self.y + 50 + img.smallY, player
					)
				end
			end)
			:onRemove(function(self, player)
				Keyboard:remove(player)

				for idx = 1, 4 do
					if images[player][idx] then
						tfm.exec.removeImage(images[player][idx])
					end
				end
			end)

			:addImage({
				image = "173d9bf80a1.png",
				target = ":5",
				x = 195, y = 50
			})
			:addTextArea({
				canUpdate = true,
				x = 193, y = 47,
				text = function(self, player, power)
					if power > 1 then
						return "<a href='event:power:" .. (power - 1) .. "'>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
					end
					return ""
				end,
				width = 26, height = 55,
				alpha = 0
			})

			:addImage({
				image = "173d9bfa12a.png",
				target = ":6",
				x = 460, y = 50
			})
			:addTextArea({
				canUpdate = true,
				x = 458, y = 47,
				text = function(self, player, power)
					if power < #powers then
						return "<a href='event:power:" .. (power + 1) .. "'>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
					end
					return ""
				end,
				width = 26, height = 55,
				alpha = 0
			})

		onEvent("ParsedTextAreaCallback", function(id, player, action, args)
			if not PowersInterface.open[player] then return end

			if action == "power" then
				page = tonumber(args)

				if page > 0 and page <= #powers then
					PowersInterface:update(player, page)
				end
			elseif Keyboard.open[player] and action == "keyboard" then
				if not checkCooldown(player, "changeKeys", 1000) then return end

				local binding = keyboard.bindings[args]
				if binding then
					Keyboard:update(player, Keyboard.args[player][1], nil, args)

					local power = PowersInterface.args[player][1]
					local old = keys[player][power]
					if old == binding then return end

					if not old then
						if powers[power].key[1] then -- variation qwerty/azerty
							old = keyboard.bindings[ powers[power].key[ players_file[player].settings[5] + 1 ] ]
						else
							old = keyboard.bindings[ powers[power].key ]
						end
					end

					local pkeys = players_file[player].keys
					local count = 0
					for index = 1, #pkeys do
						if pkeys[index] == binding then
							count = count + 1
						end
					end

					if count >= 2 then
						return translatedChatMessage("max_power_keys", player, 2)
					end

					pkeys[power] = binding
					for index = 1, power do
						if not pkeys[index] then
							pkeys[index] = 0
						end
					end

					keys[player][power] = binding
					savePlayerData(player)

					if not keys.triggers[player] then return end

					power = getPowerUpgrade(
						players_file[player].c,
						leaderboard[player] or max_leaderboard_rows + 1,
						powers[power], true
					)
					if not power then return end

					local triggers = keys.triggers[player]
					local oldPowers = triggers[old]
					if oldPowers then
						if oldPowers._count == 1 then
							triggers[old] = nil
							bindKeyboard(player, old, true, false)
						else
							for index = 1, oldPowers._count do
								if oldPowers[index] == power then
									oldPowers[index] = nil
									break
								end
							end

							local delete = true
							for index = 1, oldPowers._count do
								if oldPowers[index] then
									delete = false
									break
								end
							end
							if delete then
								triggers[old] = nil
								bindKeyboard(player, old, true, false)
							end
						end
					end

					if not triggers[binding] then
						triggers[binding] = {_count = 1, [1] = power}
						bindKeyboard(player, binding, true, true)
					else
						triggers[binding]._count = triggers[binding]._count + 1
						triggers[binding][ triggers[binding]._count ] = power
					end
				end
			end
		end)
	end
	--[[ End of file modes/parkour/interfaces/powers.lua ]]--
	--[[ File modes/parkour/interfaces/newbadge.lua ]]--
	do
		NewBadgeInterface = Interface.new(340, 130, 120, 140, true)
			:loadTemplate(WindowBackground)

			:setShowCheck(function(self, player, group, badge)
				if self.open[player] then
					self:update(player, group, badge)
					return false
				end
				return true
			end)

			:addImage({
				image = function(self, player, group, badge)
					return badges[group][badge][3]
				end,
				target = "&1",
				x = 10, y = 5
			})

			:loadComponent(
				Button.new():setTranslation("close")

				:onClick(function(self, player)
					self.parent:remove(player)
				end)

				:setSize(100, 15):setPosition(10, 115)
			)
	end
	--[[ End of file modes/parkour/interfaces/newbadge.lua ]]--
	--[[ File modes/parkour/interfaces/game.lua ]]--
	do
		local settings_img = "1713705576b.png"
		local powers_img = "17136ef539e.png"
		local help_img = "17136f9eefd.png"

		GameInterface = Interface.new(0, 0, 800, 400, true)
			:addImage({
				image = settings_img,
				target = ":1",
				x = 772, y = 32
			})
			:addTextArea({
				text = "<a href='event:settings'><font size='50'>  </font></a>",
				x = 767, y = 32,
				height = 30, width = 32,
				alpha = 0
			})

			:addImage({
				canUpdate = true,
				image = function(self, player)
					local file = players_file[player]
					if file.settings[4] == 1 then
						return powers_img
					elseif file.settings[6] == 1 then
						return help_img
					else
						return "a.png"
					end
				end,
				target = ":1",
				x = 744, y = 32
			})
			:addTextArea({
				canUpdate = true,
				text = function(self, player)
					local file = players_file[player]
					if file.settings[4] == 1 then
						return "<a href='event:powers'><font size='50'>  </font></a>"
					elseif file.settings[6] == 1 then
						return "<a href='event:help_button'><font size='50'>  </font></a>"
					else
						return ""
					end
				end,
				x = 739, y = 32,
				height = 30, width = 32,
				alpha = 0
			})

			:addImage({
				canUpdate = true,
				image = function(self, player)
					local file = players_file[player]
					if file.settings[4] == 1 and file.settings[6] == 1 then
						return help_img
					else
						return "a.png"
					end
				end,
				target = ":1",
				x = 714, y = 32
			})
			:addTextArea({
				canUpdate = true,
				text = function(self, player)
					local file = players_file[player]
					if file.settings[4] == 1 and file.settings[6] == 1 then
						return "<a href='event:help_button'><font size='50'>  </font></a>"
					else
						return ""
					end
				end,
				x = 709, y = 32,
				height = 30, width = 32,
				alpha = 0
			})
	end
	--[[ End of file modes/parkour/interfaces/game.lua ]]--
	--[[ End of directory modes/parkour/interfaces ]]--
	--[[ File modes/parkour/ui.lua ]]--
	-- Stuff related to the keyboard and game interface (not chat)

	local interfaces = {
		[76] = LeaderboardInterface,
		[79] = OptionsInterface,
		[80] = PowersInterface
	}
	local interfaces_ordered = {_count = 0}
	local profile_request = {}
	local update_at = 0
	local previous_power_quantity = 0
	local reset_powers = false
	local online_staff = {
		next_request = 0,
		next_show = 0,
		requesters = {_count = 0}
	}
	local shown_ranks = {"trainee", "mod", "mapper", "manager", "admin"}
	no_help = {}
	local map_polls = {}
	local current_poll

	-- legacy code (i'm too lazy to remake the help window; i'll do it soon)
	local help = {}
	local scrolldata = {
		players = {},
		texts = {}
	}

	local function addButton(id, text, action, player, x, y, width, height, disabled, left)
		id = -2000 + id * 3
		if not disabled then
			text = "<a href='event:" .. action .. "'>" .. text .. "</a>"
		end
		if not left then
			text = "<p align='center'>" .. text .. "</p>"
		end
		local color = disabled and 0x2a424b or 0x314e57

		ui.addTextArea(id    , ""  , player, x-1, y-1, width, height, 0x7a8d93, 0x7a8d93, 1, true)
		ui.addTextArea(id + 1, ""  , player, x+1, y+1, width, height, 0x0e1619, 0x0e1619, 1, true)
		ui.addTextArea(id + 2, text, player, x  , y  , width, height, color   , color   , 1, true)
	end

	local function removeButton(id, player)
		for i = -2000 + id * 3, -2000 + id * 3 + 2 do
			ui.removeTextArea(i, player)
		end
	end

	local function scrollWindow(id, player, up, force)
		local data = scrolldata.players[player]
		if not data then return end

		local old = data[2]
		data[2] = up and math.max(data[2] - 1, 1) or math.min(data[2] + 1, data[3])
		if data[2] == old and not force then return end

		ui.addTextArea(-1000 + id * 9 + 8, data[1][data[2]], player, data[4], data[5], data[6], data[7], 0, 0, 0, true)

		if not data.behind_img then
			data.behind_img = tfm.exec.addImage("1719e0e550a.png", "&1", data[8], data[9], player)
		end
		if data.img then
			tfm.exec.removeImage(data.img)
		end
		data.img = tfm.exec.addImage("1719e173ac6.png", "&2", data[8], data[9] + (125 / (data[3] - 1)) * (data[2] - 1), player)
	end

	local function addWindow(id, text, player, x, y, width, height, isHelp)
		if width < 0 or height and height < 0 then
			return
		elseif not height then
			height = width/2
		end
		local _id = id
		id = -1000 + id * 9

		ui.addTextArea(id    , "", player, x              , y               , width+100   , height+70, 0x78462b, 0x78462b, 1, true)
		ui.addTextArea(id + 1, "", player, x              , y+(height+140)/4, width+100   , height/2 , 0x9d7043, 0x9d7043, 1, true)
		ui.addTextArea(id + 2, "", player, x+(width+180)/4, y               , (width+10)/2, height+70, 0x9d7043, 0x9d7043, 1, true)
		ui.addTextArea(id + 3, "", player, x              , y               , 20          , 20       , 0xbeb17d, 0xbeb17d, 1, true)
		ui.addTextArea(id + 4, "", player, x+width+80     , y               , 20          , 20       , 0xbeb17d, 0xbeb17d, 1, true)
		ui.addTextArea(id + 5, "", player, x              , y+height+50     , 20          , 20       , 0xbeb17d, 0xbeb17d, 1, true)
		ui.addTextArea(id + 6, "", player, x+width+80     , y+height+50     , 20          , 20       , 0xbeb17d, 0xbeb17d, 1, true)

		if text[1] then -- it is a table
			if scrolldata.players[player] and scrolldata.players[player].img then
				tfm.exec.removeImage(scrolldata.players[player].img)
				tfm.exec.removeImage(scrolldata.players[player].behind_img)
			end
			scrolldata.players[player] = {text, 1, #text, x+3, y+40, width+70, height, x+width+85, y+40, _id}
			ui.addTextArea(id + 7, "", player, x+3, y+3, width+94, height+64, 0x1c3a3e, 0x232a35, 1, true)
			scrollWindow(_id, player, true, true)
		else
			ui.addTextArea(id + 7, (isHelp and "\n\n\n" or "") .. text, player, x+3, y+3, width+94, height+64, 0x1c3a3e, 0x232a35, 1, true)
		end
	end

	local function removeWindow(id, player)
		if scrolldata.players[player] and scrolldata.players[player].img then
			tfm.exec.removeImage(scrolldata.players[player].img)
			tfm.exec.removeImage(scrolldata.players[player].behind_img)
		end
		scrolldata.players[player] = nil
		for i = -1000 + id * 9, -1000 + id * 9 + 8 do
			ui.removeTextArea(i, player)
		end
	end

	local function removeHelpMenu(player)
		if not help[player] then return end

		removeWindow(7, player)

		for index = -20002, -20000 do
			ui.removeTextArea(index, player)
		end

		for button = 7, 12 do
			removeButton(button, player)
		end

		help[player] = nil
	end

	local function showHelpMenu(player, tab)
		help[player] = true

		if scrolldata.players[player] and scrolldata.players[player].img then
			tfm.exec.removeImage(scrolldata.players[player].img)
			tfm.exec.removeImage(scrolldata.players[player].behind_img)
		end
		scrolldata.players[player] = nil

		addWindow(7, scrolldata.texts[player_langs[player].name .. "_help_" .. tab], player, 100, 50, 500, 260, true)

		ui.addTextArea(-20000, "", player, 155, 55, 490, 30, 0x1c3a3e, 0x1c3a3e, 1, true)
		ui.addTextArea(-20001, "", player, 155, 358, 490, 17, 0x1c3a3e, 0x1c3a3e, 1, true)

		addButton(7, translatedMessage("help", player), "help:help", player, 160, 60, 80, 18, tab == "help")
		addButton(8, translatedMessage("staff", player), "help:staff", player, 260, 60, 80, 18, tab == "staff")
		addButton(9, translatedMessage("rules", player), "help:rules", player, 360, 60, 80, 18, tab == "rules")
		addButton(10, translatedMessage("contribute", player), "help:contribute", player, 460, 60, 80, 18, tab == "contribute")
		addButton(11, translatedMessage("changelog", player), "help:changelog", player, 560, 60, 80, 18, tab == "changelog")

		addButton(12, "", "close_help", player, 160, 362, 480, 10, false)
		ui.addTextArea(-20002, "<a href='event:close_help'><p align='center'>Close\n", player, 160, 358, 480, 15, 0, 0, 0, true)
	end

	onEvent("NewPlayer", function(player)
		bindKeyboard(player, 38, true, true)
		bindKeyboard(player, 40, true, true)
		bindKeyboard(player, 72, true, true)
	end)

	onEvent("Keyboard", function(player, key)
		if key == 38 or key == 40 then
			if help[player] then
				scrollWindow(7, player, key == 38)
			end

		elseif key == 72 then -- h
			if help[player] then
				removeHelpMenu(player)
			else
				showHelpMenu(player, "help")
			end
		end
	end)

	onEvent("ParsedChatCommand", function(player, cmd)
		if cmd == "help" then
			showHelpMenu(player, "help")
		end
	end)

	onEvent("RawTextAreaCallback", function(id, player, callback)
		if callback == "help_button" then
			if help[player] then
				removeHelpMenu(player)
			else
				showHelpMenu(player, "help")
			end

		elseif callback == "close_help" then
			removeHelpMenu(player)
		end
	end)

	onEvent("ParsedTextAreaCallback", function(id, player, action, args)
		if action == "help" then
			if args ~= "help" and args ~= "staff" and args ~= "rules" and args ~= "contribute" and args ~= "changelog" then return end
			showHelpMenu(player, args)
		end
	end)

	onEvent("GameStart", function()
		system.disableChatCommandDisplay("help")

		local help_texts = {"help_help", "help_staff", "help_rules", "help_contribute", "help_changelog"}

		local count, page, newline, key, text
		for name, translation in next, translations do
			for index = 1, #help_texts do
				key = name .. "_" .. help_texts[index]
				text = translation[help_texts[index]]
				count = 0
				scrolldata.texts[key] = {}
				text = "\n" .. text
				for slice = 1, #text, (help_texts[index] == "help_staff" and 700 or 800) + (name == "ru" and 250 or 0) do
					page = string.sub(text, slice)
					newline = string.find(page, "\n")
					if newline then
						page = string.sub(page, newline)
						while string.sub(page, 1, 1) == "\n" do
							page = string.sub(page, 2)
						end
						count = count + 1
						scrolldata.texts[key][count] = page
					else
						break
					end
				end
				if (#text < 1100
					or help_texts[index] == "help_help"
					or help_texts[index] == "help_contribute"
					or help_texts[index] == "help_changelog") then
					scrolldata.texts[key] = string.sub(text, 2)
				end
			end
		end
	end)
	-- end of legacy code

	local function closeAllInterfaces(player)
		for index = 1, interfaces_ordered._count do
			if interfaces_ordered[index].open[player] then
				interfaces_ordered[index]:remove(player)
				break
			end
		end

		if Profile.open[player] then
			Profile:remove(player)
		end
		if PowerTracker.open[player] then
			PowerTracker:remove(player)
		end
		if Staff.open[player] then
			Staff:remove(player)
		end
	end

	local function checkProfileRequest(player, data)
		local fetch = profile_request[player]
		if fetch then
			local requester = fetch[1]
			if Profile.open[requester] then
				Profile:update(requester, player, data)
			else
				closeAllInterfaces(requester)
				Profile:show(requester, player, data)
			end
			profile_request[player] = nil
		end
	end

	local function toggleInterface(interface, player)
		if not players_file[player] then return end
		if not checkCooldown(player, "interfaceTrigger", 500) then return end

		if not interface.open[player] then
			closeAllInterfaces(player)

			interface:showDefault(player)
		else
			interface:remove(player)
		end
	end

	function setNameColor(player)
		if players_file[player] and players_file[player].hidden then
			tfm.exec.setNameColor(
				player,

				fastest.player == player and 0xFFFFFF
				or victory[player] and 0xFFFF00
				or (room.xmlMapInfo and player == room.xmlMapInfo.author) and 0x10FFF3
				or 0x148DE6
			)
			return
		end

		tfm.exec.setNameColor(
			player,

			fastest.player == player and 0xFFFFFF -- fastest
			or victory[player] and 0xFFFF00 -- has won

			or (ranks.admin[player] or ranks.bot[player]) and 0xE7342A -- admin / bot
			or ranks.manager[player] and 0xD0A9F0 -- manager
			or (ranks.mod[player] and ranks.mapper[player]) and 0x1
			or (ranks.mod[player] or ranks.trainee[player]) and 0xFFAAAA -- moderator
			or ranks.mapper[player] and 0x25C059 -- mapper
			or ranks.translator[player] and 0xE0B856 -- translator

			or (room.xmlMapInfo and player == room.xmlMapInfo.author) and 0x10FFF3 -- author of the map
			or 0x148DE6 -- default
		)
	end

	local function showPoll(player)
		if not current_poll then return end

		local interface = current_poll.interface
		local results
		if perms[player] and perms[player].start_round_poll then
			results = current_poll.results
			interface = interface.closer
		elseif current_poll.with_close then
			interface = interface.closer
		end

		if current_poll.interface.open[player] then
			interface:update(player, current_poll.translation, current_poll.title, current_poll.buttons, results)
		else
			interface:show(player, current_poll.translation, current_poll.title, current_poll.buttons, results)
		end
	end

	onEvent("GameStart", function()
		for key, interface in next, interfaces do
			interfaces_ordered._count = interfaces_ordered._count + 1
			interfaces_ordered[ interfaces_ordered._count ] = interface
		end
	end)

	onEvent("Keyboard", function(player, key, down, x, y)
		local interface = interfaces[key]
		if interface then
			toggleInterface(interface, player)

		elseif key == 77 or key == 46 then
			if not checkCooldown(player, "keyMort", 1000) then return end

			tfm.exec.killPlayer(player)

		elseif key == 70 then
			if not players_file[player] then return end
			if not checkCooldown(player, "keyHelp", 3000) then return end

			local file = players_file[player]

			if file.settings[8] == 1 then
				file.settings[8] = 0

				if no_help[player] then
					tfm.exec.removeImage(no_help[player])
					no_help[player] = nil
				end
			else
				file.settings[8] = 1

				no_help[player] = tfm.exec.addImage("1722eeef19f.png", "$" .. player, -10, -35)
			end

			savePlayerData(player)
		end
	end)

	onEvent("TextAreaCallback", function(id, player, callback)
		if player == "Tocutoeltuco#5522" and callback == "room_state_check" then
			return ui.addTextArea(id, "", player)
		end

		if not players_file[player] then return end

		local position = string.find(callback, ":", 1, true)
		local action, args
		if not position then
			eventRawTextAreaCallback(id, player, callback)
		else
			eventParsedTextAreaCallback(id, player, string.sub(callback, 1, position - 1), string.sub(callback, position + 1))
		end
	end)

	onEvent("ParsedChatCommand", function(player, cmd, quantity, args)
		if cmd == "lb" then
			toggleInterface(LeaderboardInterface, player)

		elseif cmd == "op" then
			toggleInterface(OptionsInterface, player)

		elseif cmd == "poll" then
			if not perms[player] or not perms[player].start_round_poll then return end

			if quantity == 0 then
				return translatedChatMessage("invalid_syntax", player)
			end

			local action = string.lower(args[1])
			if action == "start" then
				if current_poll then
					return tfm.exec.chatMessage(
						"<v>[#] <r>There is already an ongoing poll on this map. Use <b>!poll see</b> to see the results.", player
					)
				end

				current_poll = {
					interface = polls.small[3],
					voters = {},
					with_close = false,
					with_results = false,
					translation = true,
					title = "like_map",
					buttons = {"yes", "no", "idk"},
					results = {total = 0, [1] = 0, [2] = 0, [3] = 0}
				}
				for player in next, in_room do
					showPoll(player)
				end

			elseif action == "see" then
				if not current_poll then
					return tfm.exec.chatMessage(
						"<v>[#] <r>There is not an active poll on this map. Use <b>!poll start</b> to start a quick one.", player
					)
				end

				showPoll(player)

			elseif action == "stop" then
				if not current_poll then
					return tfm.exec.chatMessage(
						"<v>[#] <r>There is not an active poll on this map. Use <b>!poll start</b> to start a quick one.", player
					)
				end

				local to_remove, count = {}, 0
				for player in next, current_poll.interface.open do
					count = count + 1
					to_remove[count] = player
				end

				for index = 1, count do
					current_poll.interface:remove(to_remove[index])
				end

				current_poll = nil

			else
				return tfm.exec.chatMessage("<v>[#] <r>Unknown action: <b>" .. action .. "</b>.", player)
			end

		elseif cmd == "staff" then
			if Staff.open[player] then return end

			local now = os.time()
			if now >= online_staff.next_request then
				online_staff = {
					next_request = now + 60000,
					next_show = now + 1000,
					requesters = {_count = 1, [1] = player}
				}
				online = {}
				hidden = {}

				local requested = {}
				local member
				for _, rank in next, shown_ranks do
					for index = 1, ranks[rank]._count do
						member = ranks[rank][index]

						if not requested[member] then
							requested[member] = true
							system.loadPlayerData(member)
						end
					end
				end

			elseif online_staff.next_show ~= 0 then
				online_staff.requesters._count = online_staff.requesters._count + 1
				online_staff.requesters[ online_staff.requesters._count ] = player

			else
				closeAllInterfaces(player)
				Staff:show(player)
			end

		elseif cmd == "hide" then
			if not perms[player] or not perms[player].hide then return end

			players_file[player].hidden = not players_file[player].hidden

			if players_file[player].hidden then
				tfm.exec.chatMessage("<v>[#] <d>You're now hidden. Your nickname will be blue and you won't appear in staff list.", player)
			else
				tfm.exec.chatMessage("<v>[#] <d>You're now visible. Everything's back to normal.", player)
			end
			setNameColor(player)

			savePlayerData(player)

		elseif cmd == "track" then
			if not perms[player] or not perms[player].use_tracker then return end

			if PowerTracker.open[player] then return end

			closeAllInterfaces(player)
			PowerTracker:show(player, used_powers)

		elseif cmd == "profile" or cmd == "p" then
			if not checkCooldown(player, "interfaceTrigger", 500) then return end

			if quantity == 0 then
				if Profile.open[player] then
					Profile:update(player, player)
				else
					closeAllInterfaces(player)
					Profile:show(player, player)
				end

			else
				local request = capitalize(args[1])
				if not string.find(request, "#", 1, true) then
					request = request .. "#0000"
				end

				if request == "Parkour#8558" or request == "Holybot#0000" then
					return translatedChatMessage("cant_load_bot_profile", player)
				end

				if players_file[request] then
					if Profile.open[player] then
						Profile:update(player, request)
					else
						closeAllInterfaces(player)
						Profile:show(player, request)
					end
				else
					profile_request[request] = {player, os.time() + 1000}
					system.loadPlayerData(request)
				end
			end
		end
	end)

	onEvent("GameStart", function()
		tfm.exec.disableMinimalistMode(true)

		system.disableChatCommandDisplay("lb")
		system.disableChatCommandDisplay("help")
		system.disableChatCommandDisplay("op")
		system.disableChatCommandDisplay("staff")
		system.disableChatCommandDisplay("track")
		system.disableChatCommandDisplay("profile")
		system.disableChatCommandDisplay("p")
		system.disableChatCommandDisplay("hide")
		system.disableChatCommandDisplay("poll")
	end)

	onEvent("PollVote", function(poll, player, button)
		if not current_poll or current_poll.voters[player] then return end

		current_poll.voters[player] = true
		current_poll.results.total = current_poll.results.total + 1
		current_poll.results[button] = current_poll.results[button] + 1

		local closer = current_poll.interface.closer
		if current_poll.with_results then
			if not current_poll.with_close then
				current_poll.interface:remove(player)
				closer:show(player, current_poll.translation, current_poll.title, current_poll.buttons, current_poll.results)
			else
				closer:update(player, current_poll.translation, current_poll.title, current_poll.buttons, current_poll.results)
			end

			for voter in next, current_poll.voters do
				if voter ~= player and closer.open[voter] then
					closer:update(voter, current_poll.translation, current_poll.title, current_poll.buttons, current_poll.results)
				end
			end

		elseif current_poll.with_close then
			closer:remove(player)

		else
			current_poll.interface:remove(player)
		end

		for viewer in next, closer.open do
			if perms[viewer] and perms[viewer].start_round_poll then
				closer:update(viewer, current_poll.translation, current_poll.title, current_poll.buttons, current_poll.results)
			end
		end
	end)

	onEvent("RawTextAreaCallback", function(id, player, callback)
		if callback == "settings" then
			toggleInterface(OptionsInterface, player)
		elseif callback == "powers" then
			toggleInterface(PowersInterface, player)
		end
	end)

	onEvent("ParsedTextAreaCallback", function(id, player, action, args)
		if action == "emote" then
			local emote = tonumber(args)
			if not emote then return end

			tfm.exec.playEmote(player, emote)
		end
	end)

	onEvent("NewPlayer", function(player)
		for key in next, interfaces do
			bindKeyboard(player, key, true, true)
		end
		bindKeyboard(player, 70, true, true) -- F key

		for _player, img in next, no_help do
			tfm.exec.addImage("1722eeef19f.png", "$" .. _player, -10, -35, player)
		end

		for _player in next, in_room do
			setNameColor(_player)
		end

		if current_poll and not current_poll.voters[player] then
			showPoll(player)
		end
	end)

	onEvent("PlayerLeft", function(player)
		GameInterface.open[player] = nil
	end)

	onEvent("PlayerRespawn", function(player)
		if no_help[player] then
			no_help[player] = tfm.exec.addImage("1722eeef19f.png", "$" .. player, -10, -35)
		end
		setNameColor(player)
	end)

	onEvent("NewGame", function(player)
		reset_powers = false
		no_help = {}

		if current_poll then
			local to_remove, count = {}, 0
			for player in next, current_poll.interface.open do
				count = count + 1
				to_remove[count] = player
			end

			for index = 1, count do
				current_poll.interface:remove(to_remove[index])
			end

			current_poll = nil
		end

		for player in next, in_room do
			if players_file[player] and players_file[player].settings[8] == 1 then
				no_help[player] = tfm.exec.addImage("1722eeef19f.png", "$" .. player, -10, -35)
			end
			setNameColor(player)
		end
	end)

	onEvent("PlayerDataParsed", function(player, data)
		bindKeyboard(player, data.settings[2] == 1 and 77 or 46, true, true)

		if data.settings[8] == 1 then
			no_help[player] = tfm.exec.addImage("1722eeef19f.png", "$" .. player, -10, -35)
		end

		checkProfileRequest(player, data)

		setNameColor(player)

		GameInterface:show(player)
	end)

	onEvent("OutPlayerDataParsed", checkProfileRequest)

	onEvent("Loop", function(elapsed)
		local now = os.time()

		local to_remove, count = {}, 0
		for player, data in next, profile_request do
			if now >= data[2] then
				count = count + 1
				to_remove[count] = player
				translatedChatMessage("cant_load_profile", data[1], player)
			end
		end

		if not reset_powers and elapsed >= 27000 then
			used_powers = {_count = 0}
			reset_powers = true
		end

		if previous_power_quantity ~= used_powers._count then
			previous_power_quantity = used_powers._count

			for player in next, PowerTracker.open do
				PowerTracker:update(player, used_powers)
			end
		end

		for idx = 1, count do
			profile_request[to_remove[idx]] = nil
		end

		if update_at >= now then
			local minutes = math.floor((update_at - now) / 60000)
			local seconds = math.floor((update_at - now) / 1000) % 60
			for player in next, in_room do
				ui.addTextArea(-1, translatedMessage("module_update", player, minutes, seconds), player, 0, 380, 800, 20, 1, 1, 0.7, true)
			end
		end

		if online_staff.next_show ~= 0 and now >= online_staff.next_show then
			online_staff.next_show = 0

			local room_commu = room.community
			local rank_lists = {}
			local commu, players, list
			local rank_name, rank, info
			local player, tbl, hide
			for i = 1, #shown_ranks do
				rank_name = shown_ranks[i]
				rank = ranks[rank_name]

				if rank_name == "trainee" then
					rank_name = "mod"
				end

				info = rank_lists[rank_name]
				if info then
					players, list, hide = info.players, info.list, info.hide
				else
					players, list, hide = {_count = 0}, {_count = 0}, {_count = 0}
					rank_lists[rank_name] = {
						players = players,
						list = list,
						hide = hide
					}
				end

				for index = 1, rank._count do
					player = rank[index]
					commu = online[player]

					if commu then
						if commu == room_commu then
							tbl = list
						else
							tbl = players
						end
					elseif hidden[player] then
						tbl = hide
						commu = true
					end

					if commu then
						tbl._count = tbl._count + 1
						tbl[ tbl._count ] = player
					end
				end
			end

			local offset
			for rank_name, data in next, rank_lists do
				tbl = {_count = data.list._count + data.players._count + data.hide._count}

				for i = 1, data.list._count do
					tbl[i] = data.list[i]
				end

				offset = data.list._count
				for i = 1, data.players._count do
					tbl[i + offset] = data.players[i]
				end

				offset = offset + data.players._count
				for i = 1, data.hide._count do
					tbl[i + offset] = data.hide[i]
				end

				Staff.sorted_members[rank_name] = tbl
			end

			local player
			for index = 1, online_staff.requesters._count do
				player = online_staff.requesters[index]
				closeAllInterfaces(player)
				Staff:show(player)
			end
		end
	end)

	onEvent("PacketReceived", function(packet_id, packet)
		if packet_id == 1 then -- game update
			update_at = os.time() + 60000
		end
	end)
	--[[ End of file modes/parkour/ui.lua ]]--
	--[[ File modes/parkour/init.lua ]]--
	eventGameStart()
	--[[ End of file modes/parkour/init.lua ]]--
	--[[ End of package modes/parkour ]]--
end

if starting == "*\003" then
	is_tribe = true
	tribe = string.sub(room.name, 3)

	initialize_parkour()
else
	local pos
	if starting == "*#" then
		module_name = string.match(room.name, "^%*#([a-z]+)")
		pos = #module_name + 3
	else
		module_name = string.match(room.name, "^[a-z][a-z]%-#([a-z]+)")
		pos = #module_name + 5
	end

	submode = string.match(room.name, "^[^a-zA-Z]-([a-z_]+)", pos)
	if submode then
		flags = string.sub(room.name, pos + #submode + 2)
	end

	if room.name == "*#parkour4bots" then
		--[[ Package modes/bots ]]--
		--[[ File modes/parkour/filemanagers.lua ]]--
		local filemanagers = {
			["20"] = FileManager.new({
				type = "dictionary",
				map = {
					{
						name = "maps",
						type = "array",
						objects = {
							type = "number"
						}
					},
					{
						name = "ranks",
						type = "dictionary",
						objects = {
							type = "number"
						}
					},
					{
						name = "chats",
						type = "dictionary",
						map = {
							{
								name = "mod",
								type = "string",
								length = 10
							},
							{
								name = "mapper",
								type = "string",
								length = 10
							}
						}
					}
				}
			}):disableValidityChecks():prepare(),

			["21"] = FileManager.new({
				type = "dictionary",
				map = {
					{
						name = "ranking",
						type = "array",
						objects = {
							type = "array",
							map = {
								{
									type = "number"
								},
								{
									type = "string",
								},
								{
									type = "number"
								},
								{
									type = "string",
									length = 2
								}
							}
						}
					},
					{
						name = "weekranking",
						type = "array",
						objects = {
							type = "array",
							map = {
								{
									type = "number"
								},
								{
									type = "string",
								},
								{
									type = "number"
								},
								{
									type = "string",
									length = 2
								}
							}
						}
					}
				}
			}):disableValidityChecks():prepare(),

			["22"] = FileManager.new({
				type = "dictionary",
				map = {
					{
						name = "lowmaps",
						type = "array",
						objects = {
							type = "number"
						}
					},
					{
						name = "banned",
						type = "dictionary",
						objects = {
							type = "number"
						}
					}
				}
			}):disableValidityChecks():prepare()
		}
		--[[ End of file modes/parkour/filemanagers.lua ]]--
		--[[ File modes/parkour/communication.lua ]]--
		if room.name == "*#parkour4bots" then
			recv_channel, send_channel = "Sharpiebot#0000", "Parkour#8558"
		else
			recv_channel, send_channel = "Parkour#8558", "Sharpiebot#0000"
		end

		function sendPacket(packet_id, packet) end
		if not is_tribe then
			--[[
				Packets from 4bots:
					0 - join request
					1 - game update
					2 - update pdata
					3 - !ban
					4 - !announce
					5 - !cannounce
					6 - pw request

				Packets to 4bots:
					0 - room crash
					1 - suspect
					2 - ban field set to playerdata
					3 - farm/hack suspect
					4 - weekly lb reset
					5 - pw info
					6 - record submission
			]]

			local last_id = os.time() - 10000
			local next_channel_load = 0

			local common_decoder = {
				["&0"] = "&",
				["&1"] = ";",
				["&2"] = ","
			}
			local common_encoder = {
				["&"] = "&0",
				[";"] = "&1",
				[","] = "&2"
			}

			function sendPacket(packet_id, packet)
				if not add_packet_data then
					add_packet_data = ""
				end

				add_packet_data = add_packet_data .. ";" .. packet_id .. "," .. string.gsub(packet, "[&;,]", common_encoder)
			end

			packet_handler = function(player, data)
				if player == send_channel then
					if not buffer then return end
					local send_id
					send_id, data = string.match(data, "^(%d+)(.*)$")
					if not send_id then
						send_id, data = 0, ""
					else
						send_id = tonumber(send_id)
					end

					local now = os.time()
					if now < send_id + 10000 then
						buffer = data .. buffer
					end

					system.savePlayerData(player, now .. buffer)
					buffer = nil
					if eventPacketSent then
						eventPacketSent()
					end
				elseif player == recv_channel then
					if data == "" then
						data = "0"
					end

					local send_id
					send_id, data = string.match(data, "^(%d+)(.*)$")
					send_id = tonumber(send_id)
					if send_id <= last_id then return end
					last_id = send_id

					if eventPacketReceived then
						for packet_id, packet in string.gmatch(data, ";(%d+),([^;]*)") do
							packet = string.gsub(packet, "&[012]", common_decoder)

							eventPacketReceived(tonumber(packet_id), packet)
						end
					end
				end
			end
			onEvent("PlayerDataLoaded", packet_handler)

			onEvent("Loop", function()
				local now = os.time()
				if now >= next_channel_load then
					next_channel_load = now + 10000

					if eventChannelLoad then
						eventChannelLoad()
					end
					if add_packet_data then
						buffer = add_packet_data
						add_packet_data = nil
						system.loadPlayerData(send_channel)
					end
					system.loadPlayerData(recv_channel)
				end
			end)
		end
		--[[ End of file modes/parkour/communication.lua ]]--
		--[[ File modes/parkour/ranks.lua ]]--
		local band = (bit or bit32).band
		local bxor = (bit or bit32).bxor

		ranks = {
			admin = {_count = 0},
			bot = {_count = 0},
			manager = {_count = 0},
			mod = {_count = 0},
			mapper = {_count = 0},
			trainee = {_count = 0},
			translator = {_count = 0}
		}
		local ranks_id = {
			admin = 2 ^ 0,
			manager = 2 ^ 1,
			mod = 2 ^ 2,
			mapper = 2 ^ 3,
			trainee = 2 ^ 4,
			translator = 2 ^ 5,
			bot = 2 ^ 6
		}
		local ranks_permissions = {
			admin = {}, -- will get every permission
			bot = {}, -- will get every permission
			manager = {
				force_stats = true,
				set_room_limit = true,
				set_map_time = true,
				hide = true,
				handle_map_polls = true,
				see_map_polls = true,
				give_command = true
			},
			mod = {
				ban = true,
				unban = true,
				spectate = true,
				get_player_room = true,
				change_map = true,
				load_custom_map = true,
				kill = true,
				see_private_maps = true,
				use_tracker = true,
				hide = true
			},
			mapper = {
				change_map = true,
				load_custom_map = true,
				enable_review = true,
				hide = true,
				start_round_poll = true,
				see_map_polls = true,
				set_map_time_review = true
			},
			trainee = {
				kill = true,
				spectate = true,
				change_map = true,
				get_player_room = true,
				see_private_maps = true,
				use_tracker = true
			},
			translator = {
				change_map = true,
				hide = true
			}
		}
		player_ranks = {}
		perms = {}

		for rank, perms in next, ranks_permissions do
			if rank ~= "admin" and rank ~= "bot" then
				for perm_name, allowed in next, perms do
					ranks_permissions.admin[perm_name] = allowed
					ranks_permissions.bot[perm_name] = allowed
				end
			end
		end

		onEvent("GameDataLoaded", function(data)
			if data.ranks then
				ranks, perms, player_ranks = {
					admin = {_count = 0},
					bot = {_count = 0},
					manager = {_count = 0},
					mod = {_count = 0},
					mapper = {_count = 0},
					trainee = {_count = 0},
					translator = {_count = 0}
				}, {}, {}
				local player_perms, _player_ranks
				for player, rank in next, data.ranks do
					player_perms, _player_ranks = {}, {}
					for name, id in next, ranks_id do
						if band(rank, id) > 0 then
							_player_ranks[name] = true
							ranks[name][player] = true
							ranks[name]._count = ranks[name]._count + 1
							ranks[name][ ranks[name]._count ] = player
							for perm, enabled in next, ranks_permissions[name] do
								player_perms[perm] = enabled
							end
						end
					end
					player_ranks[player] = _player_ranks
					perms[player] = player_perms
				end
			end
		end)
		--[[ End of file modes/parkour/ranks.lua ]]--
		--[[ File modes/bots/init.lua ]]--
		local files = {
			[1] = 20, -- maps, ranks, chats
			[2] = 22 -- lowmaps, banned
		}
		local next_file_load = os.time() + 61000
		local next_file_check = 0

		local bit = bit or bit32
		local packets = {
			send_other = bit.lshift(1, 8) + 255,
			send_room = bit.lshift(2, 8) + 255,
			send_webhook = bit.lshift(3, 8) + 255,
			modify_rank = bit.lshift(4, 8) + 255,
			synchronize = bit.lshift(5, 8) + 255,
			heartbeat = bit.lshift(6, 8) + 255,
			change_map = bit.lshift(7, 8) + 255,
			file_loaded = bit.lshift(8, 8) + 255,
			current_chat = bit.lshift(9, 8) + 255,
			new_chat = bit.lshift(10, 8) + 255,
			load_map = bit.lshift(11, 8) + 255,
			weekly_reset = bit.lshift(12, 8) + 255,
			room_password = bit.lshift(13, 8) + 255,
			verify_discord = bit.lshift(14, 8) + 255,
			version_mismatch = bit.lshift(15, 8) + 255,
			record_submission = bit.lshift(16, 8) + 255,
			record_badges = bit.lshift(17, 8) + 255,
			simulate_sus = bit.lshift(18, 8) + 255,
			last_sanction = bit.lshift(19, 8) + 255,

			module_crash = bit.lshift(255, 8) + 255
		}

		local hidden_bot = "Tocutoeltuco#5522"
		local parkour_bot = "Parkour#8558"
		local loaded = false
		local chats = {loading = true}
		local killing = {}
		local verifying = {}
		local get_sanction = {}
		local to_do = {}
		local in_room = {}
		local records = {
			all_badges = 9
		}

		local file_actions = {
			high_map_change = {1, true, function(data, map, add)
				for index = #data.maps, 1, -1 do
					if data.maps[index] == map then
						if add then
							return
						else
							table.remove(data.maps, index)
						end
					end
				end

				if add then
					data.maps[#data.maps + 1] = map
				end
			end},

			low_map_change = {2, true, function(data, map, add)
				for index = 1, #data.lowmaps do
					if data.lowmaps[index] == map then
						if add then
							return
						else
							table.remove(data.lowmaps, index)
						end
					end
				end

				if add then
					data.lowmaps[#data.lowmaps + 1] = map
				end
			end},

			new_chat = {1, true, function(data, name, chat)
				data.chats[name] = chat
				chats[name] = chat
				ui.addTextArea(packets.current_chat, name .. "\000" .. chat, parkour_bot)
			end},

			ban_change = {2, true, function(data, id, value)
				data.banned[tostring(id)] = value
			end},

			modify_rank = {1, true, function(data, player, newrank)
				data.ranks[player] = newrank
			end}
		}

		local function schedule(action, arg1, arg2)
			to_do[#to_do + 1] = {file_actions[action], arg1, arg2}
			next_file_check = os.time() + 4000
		end

		local function sendSynchronization()
			local packet
			for rank in next, ranks_id do
				if not packet then
					packet = rank
				else
					packet = packet .. "\001" .. rank
				end
			end

			for player, _ranks in next, player_ranks do
				packet = packet .. "\000" .. player
				for rank in next, _ranks do
					packet = packet .. "\001" .. rank
				end
			end

			ui.addTextArea(packets.synchronize, os.time() .. "\000" .. packet, parkour_bot)
			ui.addTextArea(packets.current_chat, "mod\000" .. chats.mod, parkour_bot)
			ui.addTextArea(packets.current_chat, "mapper\000" .. chats.mapper, parkour_bot)
		end

		onEvent("SavingFile", function(file, data)
			system.saveFile(filemanagers[tostring(file)]:dump(data), file)
		end)

		onEvent("FileLoaded", function(file, data)
			ui.addTextArea(packets.file_loaded, file, hidden_bot)

			data = filemanagers[file]:load(data)
			file = tonumber(file)
			local save = false

			local action
			for index = 1, #to_do do
				action = to_do[index][1]
				if files[action[1]] == file then
					if action[2] then
						save = true
					end

					action[3](data, to_do[index][2], to_do[index][3])
					to_do[index] = nil
				end
			end
			for index = #to_do, 1, -1 do
				if not to_do[index] then
					table.remove(to_do, index)
				end
			end

			eventGameDataLoaded(data)
			if data.chats then
				if chats.loading then
					chats = data.chats
				end
			end

			if not loaded and in_room[parkour_bot] then
				sendSynchronization()
			end
			loaded = true

			if save then
				eventSavingFile(file, data)
			end
		end)

		onEvent("TextAreaCallback", function(id, player, data)
			if player ~= hidden_bot and player ~= parkour_bot then return end

			if id == packets.send_other then
				ui.addTextArea(packets.send_other, data, player == hidden_bot and parkour_bot or hidden_bot)

			elseif id == packets.send_room then
				local packet_id, packet = string.match(data, "^(%d+)\000(.*)$")
				packet_id = tonumber(packet_id)
				if not packet_id then return end

				eventSendingPacket(packet_id, packet)

			elseif id == packets.new_chat then
				local name, chat = string.match(data, "^([^\000]+)\000([^\000]+)$")
				schedule("new_chat", name, chat)
				ui.addTextArea(packets.current_chat, name .. "\000" .. chat, parkour_bot)

			elseif id == packets.modify_rank then
				local player, action, rank = string.match(data, "^([^\000]+)\000([01])\000(.*)$")
				if not player_ranks[player] then
					player_ranks[player] = {
						[rank] = action == "1"
					}
				else
					player_ranks[player][rank] = action == "1"
				end

				local id = 0
				for rank, has in next, player_ranks[player] do
					if has then
						id = id + ranks_id[rank]
					end
				end

				if id == 0 then
					player_ranks[player] = nil
					id = nil
				end

				schedule("modify_rank", player, id)

			elseif id == packets.change_map then
				local rotation, map, add = string.match(data, "^([^\000]+)\000(%d+)\000([01])$")

				schedule(rotation .. "_map_change", tonumber(map), add == "1")

			elseif id == packets.load_map then
				tfm.exec.newGame(data)

			elseif id == packets.verify_discord then
				verifying[data] = true
				system.loadPlayerData(data)

			elseif id == packets.record_badges then
				local name, badge = string.match(data, "^([^\000]+)\000([^\000]+)$")
				badge = tonumber(badge)

				if badge > 1 then
					badge = math.ceil(badge / 5) + 1
				end

				if badge <= records.all_badges then
					records[name] = badge
					system.loadPlayerData(name)
				end

			elseif id == packets.simulate_sus then
				eventPacketReceived(1, data)

			elseif id == packets.last_sanction then
				get_sanction[data] = true
				system.loadPlayerData(data)
			end
		end)

		onEvent("PlayerDataLoaded", function(player, data)
			if player == recv_channel or player == send_channel or data == "" then return end

			data = json.decode(data)
			if data.v ~= data_version then
				return ui.addTextArea(packets.version_mismatch, player)
			end

			local update = false
			if killing[player] then
				data.killed = os.time() + killing[player] * 60 * 1000
				data.kill = killing[player]

				update = true
				killing[player] = nil
			end

			if verifying[player] then
				data.badges[5] = 1
				ui.addTextArea(packets.verify_discord, player)

				update = true
				verifying[player] = nil
			end

			if records[player] then
				if data.badges[6] < records[player] then
					data.badges[6] = records[player]

					update = true
				end
				records[player] = nil
			end

			if get_sanction[player] then
				ui.addTextArea(packets.last_sanction, player .. "\000" .. data.kill)
				get_sanction[player] = nil
			end

			if update then
				system.savePlayerData(player, json.encode(data))
				sendPacket(2, player)
			end
		end)

		onEvent("SendingPacket", function(id, packet)
			if id == 2 then -- !kill
				local player, minutes = string.match(packet, "^([^\000]+)\000([^\000]+)$")
				killing[player] = tonumber(minutes)
				system.loadPlayerData(player)
				return

			elseif id == 3 then -- !ban
				local id, ban_time = string.match(packet, "^[^\000]+\000([^\000]+)\000([^\000]+)$")
				schedule("ban_change", id, tonumber(ban_time))

			elseif id == 4 then -- !announcement
				tfm.exec.chatMessage("<vi>[#parkour] <d>" .. packet)
			end

			sendPacket(id, packet)
		end)

		onEvent("PacketReceived", function(id, packet)
			local args, count = {}, 0
			for slice in string.gmatch(packet, "[^\000]+") do
				count = count + 1
				args[count] = slice
			end

			if id == 0 then
				local _room, event, errormsg = table.unpack(args)
				ui.addTextArea(
					packets.send_webhook,
					"**`[CRASH]:`** `" .. _room .. "` has crashed. <@212634414021214209>: `" .. event .. "`, `" .. errormsg .. "`",
					parkour_bot
				)

			elseif id == 1 then
				local _room, player, id, map, taken = table.unpack(args)
				ui.addTextArea(
					packets.send_webhook,
					"**`[SUS]:`** `" .. player .. "` (`" .. id .. "`) completed the map `" ..
					map .. "` in the room `" .. _room .. "` in `" .. taken .. "` seconds.",
					parkour_bot
				)
				if tonumber(taken) <= 27 then -- autoban!
					schedule("ban_change", id, 1)
					sendPacket(3, player .. "\000" .. id .. "\0001")
					ui.addTextArea(
						packets.send_webhook,
						"**`[BANS]:`** `AntiCheatSystem` has permbanned the player `" .. player .. "` (`" .. id .. "`)",
						parkour_bot
					)
				end

			elseif id == 2 then
				local player, ban = table.unpack(args)
				schedule("ban_change", player, nil)

			elseif id == 3 then
				local _room, id, player, maps = table.unpack(args)
				ui.addTextArea(
					packets.send_webhook,
					"**`[SUS2]:`** `" .. player .. "` (`" .. id .. "`) has got `" .. maps .. "` maps in the last hour.",
					parkour_bot
				)

			elseif id == 4 then
				ui.addTextArea(packets.weekly_reset, packet, parkour_bot)

			elseif id == 5 then
				ui.addTextArea(packets.room_password, packet, parkour_bot)

			elseif id == 6 then
				ui.addTextArea(packets.record_submission, packet, parkour_bot)
			end
		end)

		onEvent("Loop", function()
			ui.addTextArea(packets.heartbeat, "", hidden_bot)

			local now = os.time()
			if #to_do > 0 and now >= next_file_check and now >= next_file_load then
				next_file_load = os.time() + 61000

				system.loadFile(files[to_do[1][1][1]]) -- first action, data, file
			end
		end)

		onEvent("NewPlayer", function(player)
			in_room[player] = true

			if player == parkour_bot and loaded then -- Start sync process
				sendSynchronization()
			end
		end)

		onEvent("PlayerLeft", function(player)
			in_room[player] = nil
		end)

		system.loadFile(files[1])
		tfm.exec.disableAutoNewGame(true)
		tfm.exec.disableAutoTimeLeft(true)
		tfm.exec.disableAfkDeath(true)
		tfm.exec.disableAutoShaman(true)
		tfm.exec.disableMortCommand(true)
		tfm.exec.newGame(0)
		tfm.exec.setRoomMaxPlayers(50)
		--[[ End of file modes/bots/init.lua ]]--
		--[[ End of package modes/bots ]]--
	elseif submode == "freezertag" then
		--[[ Package modes/freezertag ]]--
		--[[ File modes/freezertag/init.lua ]]--
		function eventNewPlayer()
			tfm.exec.chatMessage("<rose>/room #freezertag", player)
		end
		--[[ End of file modes/freezertag/init.lua ]]--
		--[[ End of package modes/freezertag ]]--
	elseif submode == "rocketlaunch" then
		--[[ Package modes/rocketlaunch ]]--
		--[[ File modes/rocketlaunch/init.lua ]]--
		function eventNewPlayer()
			tfm.exec.chatMessage("<rose>/room #freezertag0rocketlaunch", player)
		end
		--[[ End of file modes/rocketlaunch/init.lua ]]--
		--[[ End of package modes/rocketlaunch ]]--
	else
		initialize_parkour()
	end
end

for player in next, room.playerList do
	eventNewPlayer(player)
end

initializingModule = false